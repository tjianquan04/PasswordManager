{
  "version": 3,
  "sources": ["../../dataloader/index.js", "../../@mysten/walrus/node_modules/@mysten/bcs/src/uleb.ts", "../../@mysten/walrus/node_modules/@mysten/bcs/src/reader.ts", "../../@mysten/walrus/node_modules/@mysten/bcs/src/utils.ts", "../../@mysten/walrus/node_modules/@mysten/bcs/src/writer.ts", "../../@mysten/walrus/node_modules/@mysten/bcs/src/bcs-type.ts", "../../@mysten/walrus/node_modules/@mysten/bcs/src/bcs.ts", "../../@mysten/walrus/src/constants.ts", "../../@mysten/walrus/src/contracts/utils/index.ts", "../../@mysten/walrus/src/contracts/walrus/deps/sui/object.ts", "../../@mysten/walrus/src/contracts/walrus/storage_resource.ts", "../../@mysten/walrus/src/contracts/walrus/blob.ts", "../../@mysten/walrus/src/contracts/walrus/deps/sui/vec_map.ts", "../../@mysten/walrus/src/contracts/walrus/metadata.ts", "../../@mysten/walrus/src/contracts/walrus/deps/sui/object_table.ts", "../../@mysten/walrus/src/contracts/walrus/extended_field.ts", "../../@mysten/walrus/src/contracts/walrus/committee.ts", "../../@mysten/walrus/src/contracts/walrus/epoch_parameters.ts", "../../@mysten/walrus/src/contracts/walrus/staking_inner.ts", "../../@mysten/walrus/src/contracts/walrus/deps/sui/group_ops.ts", "../../@mysten/walrus/src/contracts/walrus/event_blob.ts", "../../@mysten/walrus/src/contracts/walrus/storage_node.ts", "../../@mysten/walrus/src/contracts/walrus/pending_values.ts", "../../@mysten/walrus/src/contracts/walrus/deps/sui/table.ts", "../../@mysten/walrus/src/contracts/walrus/deps/sui/balance.ts", "../../@mysten/walrus/src/contracts/walrus/auth.ts", "../../@mysten/walrus/src/contracts/walrus/deps/sui/bag.ts", "../../@mysten/walrus/src/contracts/walrus/staking_pool.ts", "../../@mysten/walrus/src/contracts/walrus/staking.ts", "../../@mysten/walrus/src/contracts/walrus/bls_aggregate.ts", "../../@mysten/walrus/src/contracts/walrus/storage_accounting.ts", "../../@mysten/walrus/src/contracts/walrus/system_state_inner.ts", "../../@mysten/walrus/src/contracts/walrus/system.ts", "../../@mysten/walrus/src/error.ts", "../../@mysten/walrus/src/utils/bcs.ts", "../../@mysten/walrus/src/storage-node/error.ts", "../../@mysten/walrus/src/storage-node/utils.ts", "../../@mysten/walrus/src/storage-node/client.ts", "../../@mysten/walrus/src/utils/index.ts", "../../@mysten/walrus/src/utils/object-loader.ts", "../../@mysten/walrus/src/utils/randomness.ts", "../../@mysten/walrus-wasm/web/walrus_wasm.js", "../../@mysten/walrus/src/wasm.ts", "../../@mysten/walrus/src/upload-relay/client.ts", "../../@mysten/walrus/src/utils/quilts.ts", "../../@mysten/walrus/src/files/readers/quilt-file.ts", "../../@mysten/walrus/src/files/readers/quilt.ts", "../../@mysten/walrus/src/files/readers/blob.ts", "../../@mysten/walrus/src/files/readers/local.ts", "../../@mysten/walrus/src/files/file.ts", "../../@mysten/walrus/src/files/blob.ts", "../../@mysten/walrus/src/utils/retry.ts", "../../@mysten/walrus/src/client.ts"],
  "sourcesContent": ["\"use strict\";\r\n\r\n/**\r\n * Copyright (c) 2019-present, GraphQL Foundation\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\r\n// A Function, which when given an Array of keys, returns a Promise of an Array\r\n// of values or Errors.\r\n// Optionally turn off batching or caching or provide a cache key function or a\r\n// custom cache instance.\r\n// If a custom cache is provided, it must be of this type (a subset of ES6 Map).\r\n\r\n/**\r\n * A `DataLoader` creates a public API for loading data from a particular\r\n * data back-end with unique keys such as the `id` column of a SQL table or\r\n * document name in a MongoDB database, given a batch loading function.\r\n *\r\n * Each `DataLoader` instance contains a unique memoized cache. Use caution when\r\n * used in long-lived applications or those which serve many users with\r\n * different access permissions and consider creating a new instance per\r\n * web request.\r\n */\r\nvar DataLoader =\r\n/*#__PURE__*/\r\nfunction () {\r\n  function DataLoader(batchLoadFn, options) {\r\n    if (typeof batchLoadFn !== 'function') {\r\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + (\"Array<key> and returns Promise<Array<value>>, but got: \" + batchLoadFn + \".\"));\r\n    }\r\n\r\n    this._batchLoadFn = batchLoadFn;\r\n    this._maxBatchSize = getValidMaxBatchSize(options);\r\n    this._batchScheduleFn = getValidBatchScheduleFn(options);\r\n    this._cacheKeyFn = getValidCacheKeyFn(options);\r\n    this._cacheMap = getValidCacheMap(options);\r\n    this._batch = null;\r\n    this.name = getValidName(options);\r\n  } // Private\r\n\r\n\r\n  var _proto = DataLoader.prototype;\r\n\r\n  /**\r\n   * Loads a key, returning a `Promise` for the value represented by that key.\r\n   */\r\n  _proto.load = function load(key) {\r\n    if (key === null || key === undefined) {\r\n      throw new TypeError('The loader.load() function must be called with a value, ' + (\"but got: \" + String(key) + \".\"));\r\n    }\r\n\r\n    var batch = getCurrentBatch(this);\r\n    var cacheMap = this._cacheMap;\r\n    var cacheKey; // If caching and there is a cache-hit, return cached Promise.\r\n\r\n    if (cacheMap) {\r\n      cacheKey = this._cacheKeyFn(key);\r\n      var cachedPromise = cacheMap.get(cacheKey);\r\n\r\n      if (cachedPromise) {\r\n        var cacheHits = batch.cacheHits || (batch.cacheHits = []);\r\n        return new Promise(function (resolve) {\r\n          cacheHits.push(function () {\r\n            resolve(cachedPromise);\r\n          });\r\n        });\r\n      }\r\n    } // Otherwise, produce a new Promise for this key, and enqueue it to be\r\n    // dispatched along with the current batch.\r\n\r\n\r\n    batch.keys.push(key);\r\n    var promise = new Promise(function (resolve, reject) {\r\n      batch.callbacks.push({\r\n        resolve: resolve,\r\n        reject: reject\r\n      });\r\n    }); // If caching, cache this promise.\r\n\r\n    if (cacheMap) {\r\n      cacheMap.set(cacheKey, promise);\r\n    }\r\n\r\n    return promise;\r\n  }\r\n  /**\r\n   * Loads multiple keys, promising an array of values:\r\n   *\r\n   *     var [ a, b ] = await myLoader.loadMany([ 'a', 'b' ]);\r\n   *\r\n   * This is similar to the more verbose:\r\n   *\r\n   *     var [ a, b ] = await Promise.all([\r\n   *       myLoader.load('a'),\r\n   *       myLoader.load('b')\r\n   *     ]);\r\n   *\r\n   * However it is different in the case where any load fails. Where\r\n   * Promise.all() would reject, loadMany() always resolves, however each result\r\n   * is either a value or an Error instance.\r\n   *\r\n   *     var [ a, b, c ] = await myLoader.loadMany([ 'a', 'b', 'badkey' ]);\r\n   *     // c instanceof Error\r\n   *\r\n   */\r\n  ;\r\n\r\n  _proto.loadMany = function loadMany(keys) {\r\n    if (!isArrayLike(keys)) {\r\n      throw new TypeError('The loader.loadMany() function must be called with Array<key> ' + (\"but got: \" + keys + \".\"));\r\n    } // Support ArrayLike by using only minimal property access\r\n\r\n\r\n    var loadPromises = [];\r\n\r\n    for (var i = 0; i < keys.length; i++) {\r\n      loadPromises.push(this.load(keys[i])[\"catch\"](function (error) {\r\n        return error;\r\n      }));\r\n    }\r\n\r\n    return Promise.all(loadPromises);\r\n  }\r\n  /**\r\n   * Clears the value at `key` from the cache, if it exists. Returns itself for\r\n   * method chaining.\r\n   */\r\n  ;\r\n\r\n  _proto.clear = function clear(key) {\r\n    var cacheMap = this._cacheMap;\r\n\r\n    if (cacheMap) {\r\n      var cacheKey = this._cacheKeyFn(key);\r\n\r\n      cacheMap[\"delete\"](cacheKey);\r\n    }\r\n\r\n    return this;\r\n  }\r\n  /**\r\n   * Clears the entire cache. To be used when some event results in unknown\r\n   * invalidations across this particular `DataLoader`. Returns itself for\r\n   * method chaining.\r\n   */\r\n  ;\r\n\r\n  _proto.clearAll = function clearAll() {\r\n    var cacheMap = this._cacheMap;\r\n\r\n    if (cacheMap) {\r\n      cacheMap.clear();\r\n    }\r\n\r\n    return this;\r\n  }\r\n  /**\r\n   * Adds the provided key and value to the cache. If the key already\r\n   * exists, no change is made. Returns itself for method chaining.\r\n   *\r\n   * To prime the cache with an error at a key, provide an Error instance.\r\n   */\r\n  ;\r\n\r\n  _proto.prime = function prime(key, value) {\r\n    var cacheMap = this._cacheMap;\r\n\r\n    if (cacheMap) {\r\n      var cacheKey = this._cacheKeyFn(key); // Only add the key if it does not already exist.\r\n\r\n\r\n      if (cacheMap.get(cacheKey) === undefined) {\r\n        // Cache a rejected promise if the value is an Error, in order to match\r\n        // the behavior of load(key).\r\n        var promise;\r\n\r\n        if (value instanceof Error) {\r\n          promise = Promise.reject(value); // Since this is a case where an Error is intentionally being primed\r\n          // for a given key, we want to disable unhandled promise rejection.\r\n\r\n          promise[\"catch\"](function () {});\r\n        } else {\r\n          promise = Promise.resolve(value);\r\n        }\r\n\r\n        cacheMap.set(cacheKey, promise);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n  /**\r\n   * The name given to this `DataLoader` instance. Useful for APM tools.\r\n   *\r\n   * Is `null` if not set in the constructor.\r\n   */\r\n  ;\r\n\r\n  return DataLoader;\r\n}(); // Private: Enqueue a Job to be executed after all \"PromiseJobs\" Jobs.\r\n//\r\n// ES6 JavaScript uses the concepts Job and JobQueue to schedule work to occur\r\n// after the current execution context has completed:\r\n// http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues\r\n//\r\n// Node.js uses the `process.nextTick` mechanism to implement the concept of a\r\n// Job, maintaining a global FIFO JobQueue for all Jobs, which is flushed after\r\n// the current call stack ends.\r\n//\r\n// When calling `then` on a Promise, it enqueues a Job on a specific\r\n// \"PromiseJobs\" JobQueue which is flushed in Node as a single Job on the\r\n// global JobQueue.\r\n//\r\n// DataLoader batches all loads which occur in a single frame of execution, but\r\n// should include in the batch all loads which occur during the flushing of the\r\n// \"PromiseJobs\" JobQueue after that same execution frame.\r\n//\r\n// In order to avoid the DataLoader dispatch Job occuring before \"PromiseJobs\",\r\n// A Promise Job is created with the sole purpose of enqueuing a global Job,\r\n// ensuring that it always occurs after \"PromiseJobs\" ends.\r\n//\r\n// Node.js's job queue is unique. Browsers do not have an equivalent mechanism\r\n// for enqueuing a job to be performed after promise microtasks and before the\r\n// next macrotask. For browser environments, a macrotask is used (via\r\n// setImmediate or setTimeout) at a potential performance penalty.\r\n\r\n\r\nvar enqueuePostPromiseJob = typeof process === 'object' && typeof process.nextTick === 'function' ? function (fn) {\r\n  if (!resolvedPromise) {\r\n    resolvedPromise = Promise.resolve();\r\n  }\r\n\r\n  resolvedPromise.then(function () {\r\n    process.nextTick(fn);\r\n  });\r\n} : typeof setImmediate === 'function' ? function (fn) {\r\n  setImmediate(fn);\r\n} : function (fn) {\r\n  setTimeout(fn);\r\n}; // Private: cached resolved Promise instance\r\n\r\nvar resolvedPromise; // Private: Describes a batch of requests\r\n\r\n// Private: Either returns the current batch, or creates and schedules a\r\n// dispatch of a new batch for the given loader.\r\nfunction getCurrentBatch(loader) {\r\n  // If there is an existing batch which has not yet dispatched and is within\r\n  // the limit of the batch size, then return it.\r\n  var existingBatch = loader._batch;\r\n\r\n  if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize) {\r\n    return existingBatch;\r\n  } // Otherwise, create a new batch for this loader.\r\n\r\n\r\n  var newBatch = {\r\n    hasDispatched: false,\r\n    keys: [],\r\n    callbacks: []\r\n  }; // Store it on the loader so it may be reused.\r\n\r\n  loader._batch = newBatch; // Then schedule a task to dispatch this batch of requests.\r\n\r\n  loader._batchScheduleFn(function () {\r\n    dispatchBatch(loader, newBatch);\r\n  });\r\n\r\n  return newBatch;\r\n}\r\n\r\nfunction dispatchBatch(loader, batch) {\r\n  // Mark this batch as having been dispatched.\r\n  batch.hasDispatched = true; // If there's nothing to load, resolve any cache hits and return early.\r\n\r\n  if (batch.keys.length === 0) {\r\n    resolveCacheHits(batch);\r\n    return;\r\n  } // Call the provided batchLoadFn for this loader with the batch's keys and\r\n  // with the loader as the `this` context.\r\n\r\n\r\n  var batchPromise;\r\n\r\n  try {\r\n    batchPromise = loader._batchLoadFn(batch.keys);\r\n  } catch (e) {\r\n    return failedDispatch(loader, batch, new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function ' + (\"errored synchronously: \" + String(e) + \".\")));\r\n  } // Assert the expected response from batchLoadFn\r\n\r\n\r\n  if (!batchPromise || typeof batchPromise.then !== 'function') {\r\n    return failedDispatch(loader, batch, new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + (\"not return a Promise: \" + String(batchPromise) + \".\")));\r\n  } // Await the resolution of the call to batchLoadFn.\r\n\r\n\r\n  batchPromise.then(function (values) {\r\n    // Assert the expected resolution from batchLoadFn.\r\n    if (!isArrayLike(values)) {\r\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + (\"not return a Promise of an Array: \" + String(values) + \".\"));\r\n    }\r\n\r\n    if (values.length !== batch.keys.length) {\r\n      throw new TypeError('DataLoader must be constructed with a function which accepts ' + 'Array<key> and returns Promise<Array<value>>, but the function did ' + 'not return a Promise of an Array of the same length as the Array ' + 'of keys.' + (\"\\n\\nKeys:\\n\" + String(batch.keys)) + (\"\\n\\nValues:\\n\" + String(values)));\r\n    } // Resolve all cache hits in the same micro-task as freshly loaded values.\r\n\r\n\r\n    resolveCacheHits(batch); // Step through values, resolving or rejecting each Promise in the batch.\r\n\r\n    for (var i = 0; i < batch.callbacks.length; i++) {\r\n      var _value = values[i];\r\n\r\n      if (_value instanceof Error) {\r\n        batch.callbacks[i].reject(_value);\r\n      } else {\r\n        batch.callbacks[i].resolve(_value);\r\n      }\r\n    }\r\n  })[\"catch\"](function (error) {\r\n    failedDispatch(loader, batch, error);\r\n  });\r\n} // Private: do not cache individual loads if the entire batch dispatch fails,\r\n// but still reject each request so they do not hang.\r\n\r\n\r\nfunction failedDispatch(loader, batch, error) {\r\n  // Cache hits are resolved, even though the batch failed.\r\n  resolveCacheHits(batch);\r\n\r\n  for (var i = 0; i < batch.keys.length; i++) {\r\n    loader.clear(batch.keys[i]);\r\n    batch.callbacks[i].reject(error);\r\n  }\r\n} // Private: Resolves the Promises for any cache hits in this batch.\r\n\r\n\r\nfunction resolveCacheHits(batch) {\r\n  if (batch.cacheHits) {\r\n    for (var i = 0; i < batch.cacheHits.length; i++) {\r\n      batch.cacheHits[i]();\r\n    }\r\n  }\r\n} // Private: given the DataLoader's options, produce a valid max batch size.\r\n\r\n\r\nfunction getValidMaxBatchSize(options) {\r\n  var shouldBatch = !options || options.batch !== false;\r\n\r\n  if (!shouldBatch) {\r\n    return 1;\r\n  }\r\n\r\n  var maxBatchSize = options && options.maxBatchSize;\r\n\r\n  if (maxBatchSize === undefined) {\r\n    return Infinity;\r\n  }\r\n\r\n  if (typeof maxBatchSize !== 'number' || maxBatchSize < 1) {\r\n    throw new TypeError(\"maxBatchSize must be a positive number: \" + maxBatchSize);\r\n  }\r\n\r\n  return maxBatchSize;\r\n} // Private\r\n\r\n\r\nfunction getValidBatchScheduleFn(options) {\r\n  var batchScheduleFn = options && options.batchScheduleFn;\r\n\r\n  if (batchScheduleFn === undefined) {\r\n    return enqueuePostPromiseJob;\r\n  }\r\n\r\n  if (typeof batchScheduleFn !== 'function') {\r\n    throw new TypeError(\"batchScheduleFn must be a function: \" + batchScheduleFn);\r\n  }\r\n\r\n  return batchScheduleFn;\r\n} // Private: given the DataLoader's options, produce a cache key function.\r\n\r\n\r\nfunction getValidCacheKeyFn(options) {\r\n  var cacheKeyFn = options && options.cacheKeyFn;\r\n\r\n  if (cacheKeyFn === undefined) {\r\n    return function (key) {\r\n      return key;\r\n    };\r\n  }\r\n\r\n  if (typeof cacheKeyFn !== 'function') {\r\n    throw new TypeError(\"cacheKeyFn must be a function: \" + cacheKeyFn);\r\n  }\r\n\r\n  return cacheKeyFn;\r\n} // Private: given the DataLoader's options, produce a CacheMap to be used.\r\n\r\n\r\nfunction getValidCacheMap(options) {\r\n  var shouldCache = !options || options.cache !== false;\r\n\r\n  if (!shouldCache) {\r\n    return null;\r\n  }\r\n\r\n  var cacheMap = options && options.cacheMap;\r\n\r\n  if (cacheMap === undefined) {\r\n    return new Map();\r\n  }\r\n\r\n  if (cacheMap !== null) {\r\n    var cacheFunctions = ['get', 'set', 'delete', 'clear'];\r\n    var missingFunctions = cacheFunctions.filter(function (fnName) {\r\n      return cacheMap && typeof cacheMap[fnName] !== 'function';\r\n    });\r\n\r\n    if (missingFunctions.length !== 0) {\r\n      throw new TypeError('Custom cacheMap missing methods: ' + missingFunctions.join(', '));\r\n    }\r\n  }\r\n\r\n  return cacheMap;\r\n}\r\n\r\nfunction getValidName(options) {\r\n  if (options && options.name) {\r\n    return options.name;\r\n  }\r\n\r\n  return null;\r\n} // Private\r\n\r\n\r\nfunction isArrayLike(x) {\r\n  return typeof x === 'object' && x !== null && typeof x.length === 'number' && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));\r\n}\r\n\r\nmodule.exports = DataLoader;", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// Helper utility: write number as an ULEB array.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebEncode(num: number): number[] {\n\tconst arr = [];\n\tlet len = 0;\n\n\tif (num === 0) {\n\t\treturn [0];\n\t}\n\n\twhile (num > 0) {\n\t\tarr[len] = num & 0x7f;\n\t\tif ((num >>= 7)) {\n\t\t\tarr[len] |= 0x80;\n\t\t}\n\t\tlen += 1;\n\t}\n\n\treturn arr;\n}\n\n// Helper utility: decode ULEB as an array of numbers.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebDecode(arr: number[] | Uint8Array): {\n\tvalue: number;\n\tlength: number;\n} {\n\tlet total = 0;\n\tlet shift = 0;\n\tlet len = 0;\n\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tconst byte = arr[len];\n\t\tlen += 1;\n\t\ttotal |= (byte & 0x7f) << shift;\n\t\tif ((byte & 0x80) === 0) {\n\t\t\tbreak;\n\t\t}\n\t\tshift += 7;\n\t}\n\n\treturn {\n\t\tvalue: total,\n\t\tlength: len,\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ulebDecode } from './uleb.js';\n\n/**\n * Class used for reading BCS data chunk by chunk. Meant to be used\n * by some wrapper, which will make sure that data is valid and is\n * matching the desired format.\n *\n * @example\n * // data for this example is:\n * // { a: u8, b: u32, c: bool, d: u64 }\n *\n * let reader = new BcsReader(\"647f1a060001ffffe7890423c78a050102030405\");\n * let field1 = reader.read8();\n * let field2 = reader.read32();\n * let field3 = reader.read8() === '1'; // bool\n * let field4 = reader.read64();\n * // ....\n *\n * Reading vectors is another deal in bcs. To read a vector, you first need to read\n * its length using {@link readULEB}. Here's an example:\n * @example\n * // data encoded: { field: [1, 2, 3, 4, 5] }\n * let reader = new BcsReader(\"050102030405\");\n * let vec_length = reader.readULEB();\n * let elements = [];\n * for (let i = 0; i < vec_length; i++) {\n *   elements.push(reader.read8());\n * }\n * console.log(elements); // [1,2,3,4,5]\n *\n * @param {String} data HEX-encoded data (serialized BCS)\n */\nexport class BcsReader {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\n\t/**\n\t * @param {Uint8Array} data Data to use as a buffer.\n\t */\n\tconstructor(data: Uint8Array) {\n\t\tthis.dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\t}\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number) {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Read U8 value from the buffer and shift cursor by 1.\n\t * @returns\n\t */\n\tread8(): number {\n\t\tconst value = this.dataView.getUint8(this.bytePosition);\n\t\tthis.shift(1);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U16 value from the buffer and shift cursor by 2.\n\t * @returns\n\t */\n\tread16(): number {\n\t\tconst value = this.dataView.getUint16(this.bytePosition, true);\n\t\tthis.shift(2);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U32 value from the buffer and shift cursor by 4.\n\t * @returns\n\t */\n\tread32(): number {\n\t\tconst value = this.dataView.getUint32(this.bytePosition, true);\n\t\tthis.shift(4);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U64 value from the buffer and shift cursor by 8.\n\t * @returns\n\t */\n\tread64(): string {\n\t\tconst value1 = this.read32();\n\t\tconst value2 = this.read32();\n\n\t\tconst result = value2.toString(16) + value1.toString(16).padStart(8, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 16.\n\t */\n\tread128(): string {\n\t\tconst value1 = BigInt(this.read64());\n\t\tconst value2 = BigInt(this.read64());\n\t\tconst result = value2.toString(16) + value1.toString(16).padStart(16, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 32.\n\t * @returns\n\t */\n\tread256(): string {\n\t\tconst value1 = BigInt(this.read128());\n\t\tconst value2 = BigInt(this.read128());\n\t\tconst result = value2.toString(16) + value1.toString(16).padStart(32, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read `num` number of bytes from the buffer and shift cursor by `num`.\n\t * @param num Number of bytes to read.\n\t */\n\treadBytes(num: number): Uint8Array {\n\t\tconst start = this.bytePosition + this.dataView.byteOffset;\n\t\tconst value = new Uint8Array(this.dataView.buffer, start, num);\n\n\t\tthis.shift(num);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read ULEB value - an integer of varying size. Used for enum indexes and\n\t * vector lengths.\n\t * @returns {Number} The ULEB value.\n\t */\n\treadULEB(): number {\n\t\tconst start = this.bytePosition + this.dataView.byteOffset;\n\t\tconst buffer = new Uint8Array(this.dataView.buffer, start);\n\t\tconst { value, length } = ulebDecode(buffer);\n\n\t\tthis.shift(length);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read a BCS vector: read a length and then apply function `cb` X times\n\t * where X is the length of the vector, defined as ULEB in BCS bytes.\n\t * @param cb Callback to process elements of vector.\n\t * @returns {Array<Any>} Array of the resulting values, returned by callback.\n\t */\n\treadVec(cb: (reader: BcsReader, i: number, length: number) => any): any[] {\n\t\tconst length = this.readULEB();\n\t\tconst result = [];\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tresult.push(cb(this, i, length));\n\t\t}\n\t\treturn result;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, fromBase64, fromHex, toBase58, toBase64, toHex } from '@mysten/utils';\nimport type { Encoding } from './types.js';\n\n/**\n * Encode data with either `hex` or `base64`.\n *\n * @param {Uint8Array} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {String} Encoded value.\n */\nexport function encodeStr(data: Uint8Array, encoding: Encoding): string {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn toBase58(data);\n\t\tcase 'base64':\n\t\t\treturn toBase64(data);\n\t\tcase 'hex':\n\t\t\treturn toHex(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\n/**\n * Decode either `base64` or `hex` data.\n *\n * @param {String} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {Uint8Array} Encoded value.\n */\nexport function decodeStr(data: string, encoding: Encoding): Uint8Array {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn fromBase58(data);\n\t\tcase 'base64':\n\t\t\treturn fromBase64(data);\n\t\tcase 'hex':\n\t\t\treturn fromHex(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\nexport function splitGenericParameters(\n\tstr: string,\n\tgenericSeparators: [string, string] = ['<', '>'],\n) {\n\tconst [left, right] = genericSeparators;\n\tconst tok = [];\n\tlet word = '';\n\tlet nestedAngleBrackets = 0;\n\n\tfor (let i = 0; i < str.length; i++) {\n\t\tconst char = str[i];\n\t\tif (char === left) {\n\t\t\tnestedAngleBrackets++;\n\t\t}\n\t\tif (char === right) {\n\t\t\tnestedAngleBrackets--;\n\t\t}\n\t\tif (nestedAngleBrackets === 0 && char === ',') {\n\t\t\ttok.push(word.trim());\n\t\t\tword = '';\n\t\t\tcontinue;\n\t\t}\n\t\tword += char;\n\t}\n\n\ttok.push(word.trim());\n\n\treturn tok;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Encoding } from './types.js';\nimport { ulebEncode } from './uleb.js';\nimport { encodeStr } from './utils.js';\n\nexport interface BcsWriterOptions {\n\t/** The initial size (in bytes) of the buffer tht will be allocated */\n\tinitialSize?: number;\n\t/** The maximum size (in bytes) that the buffer is allowed to grow to */\n\tmaxSize?: number;\n\t/** The amount of bytes that will be allocated whenever additional memory is required */\n\tallocateSize?: number;\n}\n\n/**\n * Class used to write BCS data into a buffer. Initializer requires\n * some size of a buffer to init; default value for this buffer is 1KB.\n *\n * Most methods are chainable, so it is possible to write them in one go.\n *\n * @example\n * let serialized = new BcsWriter()\n *   .write8(10)\n *   .write32(1000000)\n *   .write64(10000001000000)\n *   .hex();\n */\n\n/**\n * Set of methods that allows data encoding/decoding as standalone\n * BCS value or a part of a composed structure/vector.\n */\nexport class BcsWriter {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\tprivate size: number;\n\tprivate maxSize: number;\n\tprivate allocateSize: number;\n\n\tconstructor({\n\t\tinitialSize = 1024,\n\t\tmaxSize = Infinity,\n\t\tallocateSize = 1024,\n\t}: BcsWriterOptions = {}) {\n\t\tthis.size = initialSize;\n\t\tthis.maxSize = maxSize;\n\t\tthis.allocateSize = allocateSize;\n\t\tthis.dataView = new DataView(new ArrayBuffer(initialSize));\n\t}\n\n\tprivate ensureSizeOrGrow(bytes: number) {\n\t\tconst requiredSize = this.bytePosition + bytes;\n\t\tif (requiredSize > this.size) {\n\t\t\tconst nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n\t\t\tif (requiredSize > nextSize) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.size = nextSize;\n\t\t\tconst nextBuffer = new ArrayBuffer(this.size);\n\t\t\tnew Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n\t\t\tthis.dataView = new DataView(nextBuffer);\n\t\t}\n\t}\n\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number): this {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U8 value into a buffer and shift cursor position by 1.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite8(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(1);\n\t\tthis.dataView.setUint8(this.bytePosition, Number(value));\n\t\treturn this.shift(1);\n\t}\n\t/**\n\t * Write a U16 value into a buffer and shift cursor position by 2.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite16(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(2);\n\t\tthis.dataView.setUint16(this.bytePosition, Number(value), true);\n\t\treturn this.shift(2);\n\t}\n\t/**\n\t * Write a U32 value into a buffer and shift cursor position by 4.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite32(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(4);\n\t\tthis.dataView.setUint32(this.bytePosition, Number(value), true);\n\t\treturn this.shift(4);\n\t}\n\t/**\n\t * Write a U64 value into a buffer and shift cursor position by 8.\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite64(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U128 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite128(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U256 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite256(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a ULEB value into a buffer and shift cursor position by number of bytes\n\t * written.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twriteULEB(value: number): this {\n\t\tulebEncode(value).forEach((el) => this.write8(el));\n\t\treturn this;\n\t}\n\t/**\n\t * Write a vector into a buffer by first writing the vector length and then calling\n\t * a callback on each passed value.\n\t *\n\t * @param {Array<Any>} vector Array of elements to write.\n\t * @param {WriteVecCb} cb Callback to call on each element of the vector.\n\t * @returns {this}\n\t */\n\twriteVec(vector: any[], cb: (writer: BcsWriter, el: any, i: number, len: number) => void): this {\n\t\tthis.writeULEB(vector.length);\n\t\tArray.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds support for iterations over the object.\n\t * @returns {Uint8Array}\n\t */\n\t*[Symbol.iterator](): Iterator<number, Iterable<number>> {\n\t\tfor (let i = 0; i < this.bytePosition; i++) {\n\t\t\tyield this.dataView.getUint8(i);\n\t\t}\n\t\treturn this.toBytes();\n\t}\n\n\t/**\n\t * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n\t * @returns {Uint8Array} Resulting bcs.\n\t */\n\ttoBytes(): Uint8Array {\n\t\treturn new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n\t}\n\n\t/**\n\t * Represent data as 'hex' or 'base64'\n\t * @param encoding Encoding to use: 'base64' or 'hex'\n\t */\n\ttoString(encoding: Encoding): string {\n\t\treturn encodeStr(this.toBytes(), encoding);\n\t}\n}\n\nfunction toLittleEndian(bigint: bigint, size: number) {\n\tconst result = new Uint8Array(size);\n\tlet i = 0;\n\twhile (bigint > 0) {\n\t\tresult[i] = Number(bigint % BigInt(256));\n\t\tbigint = bigint / BigInt(256);\n\t\ti += 1;\n\t}\n\treturn result;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, fromBase64, toBase58, toBase64, fromHex, toHex } from '@mysten/utils';\nimport { BcsReader } from './reader.js';\nimport { ulebEncode } from './uleb.js';\nimport type { BcsWriterOptions } from './writer.js';\nimport { BcsWriter } from './writer.js';\nimport type { EnumInputShape, EnumOutputShape, JoinString } from './types.js';\n\nexport interface BcsTypeOptions<T, Input = T, Name extends string = string> {\n\tname?: Name;\n\tvalidate?: (value: Input) => void;\n}\n\nexport class BcsType<T, Input = T, const Name extends string = string> {\n\t$inferType!: T;\n\t$inferInput!: Input;\n\tname: Name;\n\tread: (reader: BcsReader) => T;\n\tserializedSize: (value: Input, options?: BcsWriterOptions) => number | null;\n\tvalidate: (value: Input) => void;\n\t#write: (value: Input, writer: BcsWriter) => void;\n\t#serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\n\tconstructor(\n\t\toptions: {\n\t\t\tname: Name;\n\t\t\tread: (reader: BcsReader) => T;\n\t\t\twrite: (value: Input, writer: BcsWriter) => void;\n\t\t\tserialize?: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\t\t\tserializedSize?: (value: Input) => number | null;\n\t\t\tvalidate?: (value: Input) => void;\n\t\t} & BcsTypeOptions<T, Input, Name>,\n\t) {\n\t\tthis.name = options.name;\n\t\tthis.read = options.read;\n\t\tthis.serializedSize = options.serializedSize ?? (() => null);\n\t\tthis.#write = options.write;\n\t\tthis.#serialize =\n\t\t\toptions.serialize ??\n\t\t\t((value, options) => {\n\t\t\t\tconst writer = new BcsWriter({\n\t\t\t\t\tinitialSize: this.serializedSize(value) ?? undefined,\n\t\t\t\t\t...options,\n\t\t\t\t});\n\t\t\t\tthis.#write(value, writer);\n\t\t\t\treturn writer.toBytes();\n\t\t\t});\n\n\t\tthis.validate = options.validate ?? (() => {});\n\t}\n\n\twrite(value: Input, writer: BcsWriter) {\n\t\tthis.validate(value);\n\t\tthis.#write(value, writer);\n\t}\n\n\tserialize(value: Input, options?: BcsWriterOptions) {\n\t\tthis.validate(value);\n\t\treturn new SerializedBcs(this, this.#serialize(value, options));\n\t}\n\n\tparse(bytes: Uint8Array): T {\n\t\tconst reader = new BcsReader(bytes);\n\t\treturn this.read(reader);\n\t}\n\n\tfromHex(hex: string) {\n\t\treturn this.parse(fromHex(hex));\n\t}\n\n\tfromBase58(b64: string) {\n\t\treturn this.parse(fromBase58(b64));\n\t}\n\n\tfromBase64(b64: string) {\n\t\treturn this.parse(fromBase64(b64));\n\t}\n\n\ttransform<T2 = T, Input2 = Input, NewName extends string = Name>({\n\t\tname,\n\t\tinput,\n\t\toutput,\n\t\tvalidate,\n\t}: {\n\t\tinput?: (val: Input2) => Input;\n\t\toutput?: (value: T) => T2;\n\t} & BcsTypeOptions<T2, Input2, NewName>) {\n\t\treturn new BcsType<T2, Input2, NewName>({\n\t\t\tname: (name ?? this.name) as NewName,\n\t\t\tread: (reader) => (output ? output(this.read(reader)) : (this.read(reader) as never)),\n\t\t\twrite: (value, writer) => this.#write(input ? input(value) : (value as never), writer),\n\t\t\tserializedSize: (value) => this.serializedSize(input ? input(value) : (value as never)),\n\t\t\tserialize: (value, options) =>\n\t\t\t\tthis.#serialize(input ? input(value) : (value as never), options),\n\t\t\tvalidate: (value) => {\n\t\t\t\tvalidate?.(value);\n\t\t\t\tthis.validate(input ? input(value) : (value as never));\n\t\t\t},\n\t\t});\n\t}\n}\n\nconst SERIALIZED_BCS_BRAND = Symbol.for('@mysten/serialized-bcs') as never;\nexport function isSerializedBcs(obj: unknown): obj is SerializedBcs<unknown> {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[SERIALIZED_BCS_BRAND] === true;\n}\n\nexport class SerializedBcs<T, Input = T> {\n\t#schema: BcsType<T, Input>;\n\t#bytes: Uint8Array;\n\n\t// Used to brand SerializedBcs so that they can be identified, even between multiple copies\n\t// of the @mysten/bcs package are installed\n\tget [SERIALIZED_BCS_BRAND]() {\n\t\treturn true;\n\t}\n\n\tconstructor(type: BcsType<T, Input>, schema: Uint8Array) {\n\t\tthis.#schema = type;\n\t\tthis.#bytes = schema;\n\t}\n\n\ttoBytes() {\n\t\treturn this.#bytes;\n\t}\n\n\ttoHex() {\n\t\treturn toHex(this.#bytes);\n\t}\n\n\ttoBase64() {\n\t\treturn toBase64(this.#bytes);\n\t}\n\n\ttoBase58() {\n\t\treturn toBase58(this.#bytes);\n\t}\n\n\tparse() {\n\t\treturn this.#schema.parse(this.#bytes);\n\t}\n}\n\nexport function fixedSizeBcsType<T, Input = T, const Name extends string = string>({\n\tsize,\n\t...options\n}: {\n\tname: Name;\n\tsize: number;\n\tread: (reader: BcsReader) => T;\n\twrite: (value: Input, writer: BcsWriter) => void;\n} & BcsTypeOptions<T, Input, Name>) {\n\treturn new BcsType<T, Input, Name>({\n\t\t...options,\n\t\tserializedSize: () => size,\n\t});\n}\n\nexport function uIntBcsType<const Name extends string = string>({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: Name;\n\tsize: number;\n\treadMethod: `read${8 | 16 | 32}`;\n\twriteMethod: `write${8 | 16 | 32}`;\n\tmaxValue: number;\n} & BcsTypeOptions<number, number, Name>) {\n\treturn fixedSizeBcsType<number, number, Name>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](value),\n\t\tvalidate: (value) => {\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function bigUIntBcsType<const Name extends string = string>({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: Name;\n\tsize: number;\n\treadMethod: `read${64 | 128 | 256}`;\n\twriteMethod: `write${64 | 128 | 256}`;\n\tmaxValue: bigint;\n} & BcsTypeOptions<string, string | number | bigint>) {\n\treturn fixedSizeBcsType<string, string | number | bigint, Name>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](BigInt(value)),\n\t\tvalidate: (val) => {\n\t\t\tconst value = BigInt(val);\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function dynamicSizeBcsType<T, Input = T, const Name extends string = string>({\n\tserialize,\n\t...options\n}: {\n\tname: Name;\n\tread: (reader: BcsReader) => T;\n\tserialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n} & BcsTypeOptions<T, Input>) {\n\tconst type = new BcsType<T, Input>({\n\t\t...options,\n\t\tserialize,\n\t\twrite: (value, writer) => {\n\t\t\tfor (const byte of type.serialize(value).toBytes()) {\n\t\t\t\twriter.write8(byte);\n\t\t\t}\n\t\t},\n\t});\n\n\treturn type;\n}\n\nexport function stringLikeBcsType<const Name extends string = string>({\n\ttoBytes,\n\tfromBytes,\n\t...options\n}: {\n\tname: Name;\n\ttoBytes: (value: string) => Uint8Array;\n\tfromBytes: (bytes: Uint8Array) => string;\n\tserializedSize?: (value: string) => number | null;\n} & BcsTypeOptions<string, string, Name>) {\n\treturn new BcsType<string, string, Name>({\n\t\t...options,\n\t\tread: (reader) => {\n\t\t\tconst length = reader.readULEB();\n\t\t\tconst bytes = reader.readBytes(length);\n\n\t\t\treturn fromBytes(bytes);\n\t\t},\n\t\twrite: (hex, writer) => {\n\t\t\tconst bytes = toBytes(hex);\n\t\t\twriter.writeULEB(bytes.length);\n\t\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\t\twriter.write8(bytes[i]);\n\t\t\t}\n\t\t},\n\t\tserialize: (value) => {\n\t\t\tconst bytes = toBytes(value);\n\t\t\tconst size = ulebEncode(bytes.length);\n\t\t\tconst result = new Uint8Array(size.length + bytes.length);\n\t\t\tresult.set(size, 0);\n\t\t\tresult.set(bytes, size.length);\n\n\t\t\treturn result;\n\t\t},\n\t\tvalidate: (value) => {\n\t\t\tif (typeof value !== 'string') {\n\t\t\t\tthrow new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function lazyBcsType<T, Input>(cb: () => BcsType<T, Input>) {\n\tlet lazyType: BcsType<T, Input> | null = null;\n\tfunction getType() {\n\t\tif (!lazyType) {\n\t\t\tlazyType = cb();\n\t\t}\n\t\treturn lazyType;\n\t}\n\n\treturn new BcsType<T, Input>({\n\t\tname: 'lazy' as never,\n\t\tread: (data) => getType().read(data),\n\t\tserializedSize: (value) => getType().serializedSize(value),\n\t\twrite: (value, writer) => getType().write(value, writer),\n\t\tserialize: (value, options) => getType().serialize(value, options).toBytes(),\n\t});\n}\n\nexport interface BcsStructOptions<\n\tT extends Record<string, BcsType<any>>,\n\tName extends string = string,\n> extends Omit<\n\t\tBcsTypeOptions<\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t},\n\t\t\tName\n\t\t>,\n\t\t'name'\n\t> {\n\tname: Name;\n\tfields: T;\n}\n\nexport class BcsStruct<\n\tT extends Record<string, BcsType<any>>,\n\tconst Name extends string = string,\n> extends BcsType<\n\t{\n\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t},\n\t{\n\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t},\n\tName\n> {\n\tconstructor({ name, fields, ...options }: BcsStructOptions<T, Name>) {\n\t\tconst canonicalOrder = Object.entries(fields);\n\n\t\tsuper({\n\t\t\tname,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tconst size = type.serializedSize(values[field]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: Record<string, unknown> = {};\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tresult[field] = type.read(reader);\n\t\t\t\t}\n\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\ttype.write(value[field], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n}\n\nexport interface BcsEnumOptions<\n\tT extends Record<string, BcsType<any> | null>,\n\tName extends string = string,\n> extends Omit<\n\t\tBcsTypeOptions<\n\t\t\tEnumOutputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any, any> ? U : true;\n\t\t\t}>,\n\t\t\tEnumInputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U, any> ? U : boolean | object | null;\n\t\t\t}>,\n\t\t\tName\n\t\t>,\n\t\t'name'\n\t> {\n\tname: Name;\n\tfields: T;\n}\n\nexport class BcsEnum<\n\tT extends Record<string, BcsType<any> | null>,\n\tconst Name extends string = string,\n> extends BcsType<\n\tEnumOutputShape<{\n\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n\t}>,\n\tEnumInputShape<{\n\t\t[K in keyof T]: T[K] extends BcsType<any, infer U, any> ? U : boolean | object | null;\n\t}>,\n\tName\n> {\n\tconstructor({ fields, ...options }: BcsEnumOptions<T, Name>) {\n\t\tconst canonicalOrder = Object.entries(fields as object);\n\t\tsuper({\n\t\t\tread: (reader) => {\n\t\t\t\tconst index = reader.readULEB();\n\n\t\t\t\tconst enumEntry = canonicalOrder[index];\n\t\t\t\tif (!enumEntry) {\n\t\t\t\t\tthrow new TypeError(`Unknown value ${index} for enum ${name}`);\n\t\t\t\t}\n\n\t\t\t\tconst [kind, type] = enumEntry;\n\n\t\t\t\treturn {\n\t\t\t\t\t[kind]: type?.read(reader) ?? true,\n\t\t\t\t\t$kind: kind,\n\t\t\t\t} as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst [name, val] = Object.entries(value).filter(([name]) =>\n\t\t\t\t\tObject.hasOwn(fields, name),\n\t\t\t\t)[0];\n\n\t\t\t\tfor (let i = 0; i < canonicalOrder.length; i++) {\n\t\t\t\t\tconst [optionName, optionType] = canonicalOrder[i];\n\t\t\t\t\tif (optionName === name) {\n\t\t\t\t\t\twriter.writeULEB(i);\n\t\t\t\t\t\toptionType?.write(val, writer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\n\t\t\t\tconst keys = Object.keys(value).filter(\n\t\t\t\t\t(k) => value[k] !== undefined && Object.hasOwn(fields, k),\n\t\t\t\t);\n\n\t\t\t\tif (keys.length !== 1) {\n\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t`Expected object with one key, but found ${keys.length} for type ${name}}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst [variant] = keys;\n\n\t\t\t\tif (!Object.hasOwn(fields, variant)) {\n\t\t\t\t\tthrow new TypeError(`Invalid enum variant ${variant}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n}\n\nexport interface BcsTupleOptions<T extends readonly BcsType<any>[], Name extends string>\n\textends Omit<\n\t\tBcsTypeOptions<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof T]: T[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t},\n\t\t\tName\n\t\t>,\n\t\t'name'\n\t> {\n\tname?: Name;\n\tfields: T;\n}\n\nexport class BcsTuple<\n\tconst T extends readonly BcsType<any>[],\n\tconst Name extends\n\t\tstring = `(${JoinString<{ [K in keyof T]: T[K] extends BcsType<any, any, infer T> ? T : never }, ', '>})`,\n> extends BcsType<\n\t{\n\t\t-readonly [K in keyof T]: T[K] extends BcsType<infer T, any> ? T : never;\n\t},\n\t{\n\t\t[K in keyof T]: T[K] extends BcsType<any, infer T> ? T : never;\n\t},\n\tName\n> {\n\tconstructor({ fields, name, ...options }: BcsTupleOptions<T, Name>) {\n\t\tsuper({\n\t\t\tname: name ?? (`(${fields.map((t) => t.name).join(', ')})` as never),\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (let i = 0; i < fields.length; i++) {\n\t\t\t\t\tconst size = fields[i].serializedSize(values[i]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: unknown[] = [];\n\t\t\t\tfor (const field of fields) {\n\t\t\t\t\tresult.push(field.read(reader));\n\t\t\t\t}\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < fields.length; i++) {\n\t\t\t\t\tfields[i].write(value[i], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== fields.length) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${fields.length}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsTypeOptions } from './bcs-type.js';\nimport {\n\tBcsEnum,\n\tBcsStruct,\n\tBcsTuple,\n\tBcsType,\n\tbigUIntBcsType,\n\tdynamicSizeBcsType,\n\tfixedSizeBcsType,\n\tlazyBcsType,\n\tstringLikeBcsType,\n\tuIntBcsType,\n} from './bcs-type.js';\nimport type {\n\tEnumInputShape,\n\tEnumOutputShape,\n\tInferBcsInput,\n\tInferBcsType,\n\tJoinString,\n} from './types.js';\nimport { ulebEncode } from './uleb.js';\n\nfunction fixedArray<T extends BcsType<any>, Name extends string = string>(\n\tsize: number,\n\ttype: T,\n\toptions?: BcsTypeOptions<\n\t\tInferBcsType<T>[],\n\t\tIterable<InferBcsInput<T>> & { length: number },\n\t\tName\n\t>,\n): BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name>;\nfunction fixedArray<T, Input, Name extends string = string>(\n\tsize: number,\n\ttype: BcsType<T, Input>,\n\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }, Name>,\n): BcsType<T[], Iterable<Input> & { length: number }, Name>;\nfunction fixedArray<T extends BcsType<any>, Name extends string = `${T['name']}[${number}]`>(\n\tsize: number,\n\ttype: T,\n\toptions?: BcsTypeOptions<\n\t\tInferBcsType<T>[],\n\t\tIterable<InferBcsInput<T>> & { length: number },\n\t\tName\n\t>,\n): BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name> {\n\treturn new BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name>({\n\t\tread: (reader) => {\n\t\t\tconst result: InferBcsType<T>[] = new Array(size);\n\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\tresult[i] = type.read(reader);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\twrite: (value, writer) => {\n\t\t\tfor (const item of value) {\n\t\t\t\ttype.write(item, writer);\n\t\t\t}\n\t\t},\n\t\t...options,\n\t\tname: (options?.name ?? `${type.name}[${size}]`) as Name,\n\t\tvalidate: (value) => {\n\t\t\toptions?.validate?.(value);\n\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t}\n\t\t\tif (value.length !== size) {\n\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t}\n\t\t},\n\t});\n}\n\nfunction option<T extends BcsType<any>>(\n\ttype: T,\n): BcsType<InferBcsType<T> | null, InferBcsInput<T> | null | undefined, `Option<${T['name']}>`>;\nfunction option<T, Input, Name extends string = string>(\n\ttype: BcsType<T, Input, Name>,\n): BcsType<T | null, Input | null | undefined>;\nfunction option<T extends BcsType<any>>(\n\ttype: T,\n): BcsType<InferBcsType<T> | null, InferBcsInput<T> | null | undefined, `Option<${T['name']}>`> {\n\treturn bcs\n\t\t.enum(`Option<${type.name}>`, {\n\t\t\tNone: null,\n\t\t\tSome: type,\n\t\t})\n\t\t.transform({\n\t\t\tinput: (value: InferBcsInput<T> | null | undefined) => {\n\t\t\t\tif (value == null) {\n\t\t\t\t\treturn { None: true };\n\t\t\t\t}\n\n\t\t\t\treturn { Some: value };\n\t\t\t},\n\t\t\toutput: (value) => {\n\t\t\t\tif (value.$kind === 'Some') {\n\t\t\t\t\treturn value.Some as InferBcsType<T>;\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t},\n\t\t});\n}\n\nfunction vector<T extends BcsType<any>, Name extends string = `vector<${T['name']}>`>(\n\ttype: T,\n\toptions?: BcsTypeOptions<\n\t\tInferBcsType<T>[],\n\t\tIterable<InferBcsInput<T>> & { length: number },\n\t\tName\n\t>,\n): BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name>;\nfunction vector<T, Input, Name extends string = string>(\n\ttype: BcsType<T, Input, Name>,\n\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }, `vector<${Name}>`>,\n): BcsType<T[], Iterable<Input> & { length: number }, `vector<${Name}>`>;\nfunction vector<T extends BcsType<any>, Name extends string = `vector<${T['name']}>`>(\n\ttype: T,\n\toptions?: BcsTypeOptions<\n\t\tInferBcsType<T>[],\n\t\tIterable<InferBcsInput<T>> & { length: number },\n\t\tName\n\t>,\n): BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name> {\n\treturn new BcsType<InferBcsType<T>[], Iterable<InferBcsInput<T>> & { length: number }, Name>({\n\t\tread: (reader) => {\n\t\t\tconst length = reader.readULEB();\n\t\t\tconst result: InferBcsType<T>[] = new Array(length);\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tresult[i] = type.read(reader);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\twrite: (value, writer) => {\n\t\t\twriter.writeULEB(value.length);\n\t\t\tfor (const item of value) {\n\t\t\t\ttype.write(item, writer);\n\t\t\t}\n\t\t},\n\t\t...options,\n\t\tname: (options?.name ?? `vector<${type.name}>`) as Name,\n\t\tvalidate: (value) => {\n\t\t\toptions?.validate?.(value);\n\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t}\n\t\t},\n\t});\n}\n\nfunction map<K extends BcsType<any>, V extends BcsType<any>>(\n\tkeyType: K,\n\tvalueType: V,\n): BcsType<\n\tMap<InferBcsType<K>, InferBcsType<V>>,\n\tMap<InferBcsInput<K>, InferBcsInput<V>>,\n\t`Map<${K['name']}, ${V['name']}>`\n>;\nfunction map<K, V, InputK = K, InputV = V>(\n\tkeyType: BcsType<K, InputK>,\n\tvalueType: BcsType<V, InputV>,\n): BcsType<Map<K, V>, Map<InputK, InputV>, `Map<${string}, ${string}>`>;\nfunction map<K extends BcsType<any>, V extends BcsType<any>>(\n\tkeyType: K,\n\tvalueType: V,\n): BcsType<\n\tMap<InferBcsType<K>, InferBcsType<V>>,\n\tMap<InferBcsInput<K>, InferBcsInput<V>>,\n\t`Map<${K['name']}, ${V['name']}>`\n> {\n\treturn bcs.vector(bcs.tuple([keyType, valueType])).transform({\n\t\tname: `Map<${keyType.name}, ${valueType.name}>`,\n\t\tinput: (value: Map<InferBcsInput<K>, InferBcsInput<V>>) => {\n\t\t\treturn [...value.entries()];\n\t\t},\n\t\toutput: (value) => {\n\t\t\tconst result = new Map<InferBcsType<K>, InferBcsType<V>>();\n\t\t\tfor (const [key, val] of value) {\n\t\t\t\tresult.set(key, val);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t});\n}\n\nexport const bcs = {\n\t/**\n\t * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n\t * @example\n\t * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n\t */\n\tu8(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\treadMethod: 'read8',\n\t\t\twriteMethod: 'write8',\n\t\t\tsize: 1,\n\t\t\tmaxValue: 2 ** 8 - 1,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u8') as 'u8',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n\t * @example\n\t * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n\t */\n\tu16(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\treadMethod: 'read16',\n\t\t\twriteMethod: 'write16',\n\t\t\tsize: 2,\n\t\t\tmaxValue: 2 ** 16 - 1,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u16') as 'u16',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n\t * @example\n\t * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n\t */\n\tu32(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\treadMethod: 'read32',\n\t\t\twriteMethod: 'write32',\n\t\t\tsize: 4,\n\t\t\tmaxValue: 2 ** 32 - 1,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u32') as 'u32',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n\t * @example\n\t * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n\t */\n\tu64(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\treadMethod: 'read64',\n\t\t\twriteMethod: 'write64',\n\t\t\tsize: 8,\n\t\t\tmaxValue: 2n ** 64n - 1n,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u64') as 'u64',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n\t * @example\n\t * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu128(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\treadMethod: 'read128',\n\t\t\twriteMethod: 'write128',\n\t\t\tsize: 16,\n\t\t\tmaxValue: 2n ** 128n - 1n,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u128') as 'u128',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n\t * @example\n\t * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu256(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\treadMethod: 'read256',\n\t\t\twriteMethod: 'write256',\n\t\t\tsize: 32,\n\t\t\tmaxValue: 2n ** 256n - 1n,\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'u256') as 'u256',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write boolean values.\n\t * @example\n\t * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n\t */\n\tbool(options?: BcsTypeOptions<boolean>) {\n\t\treturn fixedSizeBcsType({\n\t\t\tsize: 1,\n\t\t\tread: (reader) => reader.read8() === 1,\n\t\t\twrite: (value, writer) => writer.write8(value ? 1 : 0),\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'bool') as 'bool',\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'boolean') {\n\t\t\t\t\tthrow new TypeError(`Expected boolean, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n\t * @example\n\t *\n\t */\n\tuleb128(options?: BcsTypeOptions<number>) {\n\t\treturn dynamicSizeBcsType({\n\t\t\tread: (reader) => reader.readULEB(),\n\t\t\tserialize: (value) => {\n\t\t\t\treturn Uint8Array.from(ulebEncode(value));\n\t\t\t},\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'uleb128') as 'uleb128',\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a fixed length byte array\n\t * @param size The number of bytes this types represents\n\t * @example\n\t * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n\t */\n\tbytes<T extends number>(size: T, options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn fixedSizeBcsType<Uint8Array, Iterable<number>, `bytes[${T}]`>({\n\t\t\tsize,\n\t\t\tread: (reader) => reader.readBytes(size),\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst array = new Uint8Array(value);\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\twriter.write8(array[i] ?? 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tname: (options?.name ?? `bytes[${size}]`) as `bytes[${T}]`,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a variable length byte array\n\t *\n\t * @example\n\t * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]\n\t */\n\tbyteVector(options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn new BcsType<Uint8Array, Iterable<number>, 'vector<u8>'>({\n\t\t\tread: (reader) => {\n\t\t\t\tconst length = reader.readULEB();\n\n\t\t\t\treturn reader.readBytes(length);\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst array = new Uint8Array(value);\n\t\t\t\twriter.writeULEB(array.length);\n\t\t\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\t\t\twriter.write8(array[i] ?? 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'vector<u8>') as 'vector<u8>',\n\t\t\tserializedSize: (value) => {\n\t\t\t\tconst length = 'length' in value ? (value.length as number) : null;\n\t\t\t\treturn length == null ? null : ulebEncode(length).length + length;\n\t\t\t},\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n\t * @example\n\t * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n\t */\n\tstring(options?: BcsTypeOptions<string>) {\n\t\treturn stringLikeBcsType({\n\t\t\ttoBytes: (value) => new TextEncoder().encode(value),\n\t\t\tfromBytes: (bytes) => new TextDecoder().decode(bytes),\n\t\t\t...options,\n\t\t\tname: (options?.name ?? 'string') as 'string',\n\t\t});\n\t},\n\t/**\n\t * Creates a BcsType that represents a fixed length array of a given type\n\t * @param size The number of elements in the array\n\t * @param type The BcsType of each element in the array\n\t * @example\n\t * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n\t */\n\tfixedArray,\n\n\t/**\n\t * Creates a BcsType representing an optional value\n\t * @param type The BcsType of the optional value\n\t * @example\n\t * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n\t * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n\t */\n\toption,\n\n\t/**\n\t * Creates a BcsType representing a variable length vector of a given type\n\t * @param type The BcsType of each element in the vector\n\t *\n\t * @example\n\t * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n\t */\n\tvector,\n\n\t/**\n\t * Creates a BcsType representing a tuple of a given set of types\n\t * @param types The BcsTypes for each element in the tuple\n\t *\n\t * @example\n\t * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n\t * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n\t */\n\ttuple<\n\t\tconst T extends readonly BcsType<any, any>[],\n\t\tconst Name extends\n\t\t\tstring = `(${JoinString<{ [K in keyof T]: T[K] extends BcsType<any, any, infer T> ? T : never }, ', '>})`,\n\t>(\n\t\tfields: T,\n\t\toptions?: BcsTypeOptions<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof T]: T[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t},\n\t\t\tName\n\t\t>,\n\t) {\n\t\treturn new BcsTuple<T, Name>({\n\t\t\tfields,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a struct of a given set of fields\n\t * @param name The name of the struct\n\t * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n\t *\n\t * @example\n\t * const struct = bcs.struct('MyStruct', {\n\t *  a: bcs.u8(),\n\t *  b: bcs.string(),\n\t * })\n\t * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t */\n\tstruct<T extends Record<string, BcsType<any>>, const Name extends string = string>(\n\t\tname: Name,\n\t\tfields: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t\t}\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\treturn new BcsStruct<T>({\n\t\t\tname,\n\t\t\tfields,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an enum of a given set of options\n\t * @param name The name of the enum\n\t * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n\t * null can be used to represent a variant with no data.\n\t *\n\t * @example\n\t * const enum = bcs.enum('MyEnum', {\n\t *   A: bcs.u8(),\n\t *   B: bcs.string(),\n\t *   C: null,\n\t * })\n\t * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n\t * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n\t */\n\tenum<T extends Record<string, BcsType<any> | null>, const Name extends string = string>(\n\t\tname: Name,\n\t\tfields: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\tEnumOutputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any, any> ? U : true;\n\t\t\t\t}>,\n\t\t\t\tEnumInputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U, any> ? U : boolean | object | null;\n\t\t\t\t}>,\n\t\t\t\tName\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\treturn new BcsEnum<T, Name>({\n\t\t\tname,\n\t\t\tfields,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a map of a given key and value type\n\t * @param keyType The BcsType of the key\n\t * @param valueType The BcsType of the value\n\t * @example\n\t * const map = bcs.map(bcs.u8(), bcs.string())\n\t * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n\t */\n\tmap,\n\n\t/**\n\t * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n\t * @param cb A callback that returns the BcsType\n\t */\n\tlazy<T extends BcsType<any>>(cb: () => T): T {\n\t\treturn lazyBcsType(cb) as T;\n\t},\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BlobStatus } from './storage-node/types.js';\nimport type { WalrusPackageConfig } from './types.js';\n\nexport const TESTNET_WALRUS_PACKAGE_CONFIG = {\n\tsystemObjectId: '0x6c2547cbbc38025cf3adac45f63cb0a8d12ecf777cdc75a4971612bf97fdf6af',\n\tstakingPoolId: '0xbe46180321c30aab2f8b3501e24048377287fa708018a5b7c2792b35fe339ee3',\n\texchangeIds: [\n\t\t'0xf4d164ea2def5fe07dc573992a029e010dba09b1a8dcbc44c5c2e79567f39073',\n\t\t'0x19825121c52080bb1073662231cfea5c0e4d905fd13e95f21e9a018f2ef41862',\n\t\t'0x83b454e524c71f30803f4d6c302a86fb6a39e96cdfb873c2d1e93bc1c26a3bc5',\n\t\t'0x8d63209cf8589ce7aef8f262437163c67577ed09f3e636a9d8e0813843fb8bf1',\n\t],\n} satisfies WalrusPackageConfig;\n\nexport const MAINNET_WALRUS_PACKAGE_CONFIG = {\n\tsystemObjectId: '0x2134d52768ea07e8c43570ef975eb3e4c27a39fa6396bef985b5abc58d03ddd2',\n\tstakingPoolId: '0x10b9d30c28448939ce6c4d6c6e0ffce4a7f8a4ada8248bdad09ef8b70e4a3904',\n} satisfies WalrusPackageConfig;\n\n// Ranking of blob status types from earliest -> latest in the lifecycle of a blob.\nexport const statusLifecycleRank: Record<BlobStatus['type'], number> = {\n\tnonexistent: 0,\n\tdeletable: 1,\n\tpermanent: 2,\n\tinvalid: 3,\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport type { BcsType, TypeTag } from '@mysten/sui/bcs';\nimport { bcs, TypeTagSerializer, BcsStruct, BcsEnum, BcsTuple } from '@mysten/sui/bcs';\nimport { normalizeSuiAddress } from '@mysten/sui/utils';\nimport type { TransactionArgument } from '@mysten/sui/transactions';\nimport { isArgument } from '@mysten/sui/transactions';\n\nconst MOVE_STDLIB_ADDRESS = normalizeSuiAddress('0x1');\nconst SUI_FRAMEWORK_ADDRESS = normalizeSuiAddress('0x2');\nconst SUI_SYSTEM_ADDRESS = normalizeSuiAddress('0x3');\n\nexport type RawTransactionArgument<T> = T | TransactionArgument;\n\nexport function getPureBcsSchema(typeTag: string | TypeTag): BcsType<any> | null {\n\tconst parsedTag = typeof typeTag === 'string' ? TypeTagSerializer.parseFromStr(typeTag) : typeTag;\n\n\tif ('u8' in parsedTag) {\n\t\treturn bcs.U8;\n\t} else if ('u16' in parsedTag) {\n\t\treturn bcs.U16;\n\t} else if ('u32' in parsedTag) {\n\t\treturn bcs.U32;\n\t} else if ('u64' in parsedTag) {\n\t\treturn bcs.U64;\n\t} else if ('u128' in parsedTag) {\n\t\treturn bcs.U128;\n\t} else if ('u256' in parsedTag) {\n\t\treturn bcs.U256;\n\t} else if ('address' in parsedTag) {\n\t\treturn bcs.Address;\n\t} else if ('bool' in parsedTag) {\n\t\treturn bcs.Bool;\n\t} else if ('vector' in parsedTag) {\n\t\tconst type = getPureBcsSchema(parsedTag.vector);\n\t\treturn type ? bcs.vector(type) : null;\n\t} else if ('struct' in parsedTag) {\n\t\tconst structTag = parsedTag.struct;\n\t\tconst pkg = normalizeSuiAddress(parsedTag.struct.address);\n\n\t\tif (pkg === MOVE_STDLIB_ADDRESS) {\n\t\t\tif (\n\t\t\t\t(structTag.module === 'ascii' || structTag.module === 'string') &&\n\t\t\t\tstructTag.name === 'String'\n\t\t\t) {\n\t\t\t\treturn bcs.String;\n\t\t\t}\n\n\t\t\tif (structTag.module === 'option' && structTag.name === 'Option') {\n\t\t\t\tconst type = getPureBcsSchema(structTag.typeParams[0]);\n\t\t\t\treturn type ? bcs.vector(type) : null;\n\t\t\t}\n\t\t}\n\n\t\tif (pkg === SUI_FRAMEWORK_ADDRESS && structTag.module === 'Object' && structTag.name === 'ID') {\n\t\t\treturn bcs.Address;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nexport function normalizeMoveArguments(\n\targs: unknown[] | object,\n\targTypes: string[],\n\tparameterNames?: string[],\n) {\n\tif (parameterNames && argTypes.length !== parameterNames.length) {\n\t\tthrow new Error(\n\t\t\t`Invalid number of parameterNames, expected ${argTypes.length}, got ${parameterNames.length}`,\n\t\t);\n\t}\n\n\tconst normalizedArgs: TransactionArgument[] = [];\n\n\tlet index = 0;\n\tfor (const [i, argType] of argTypes.entries()) {\n\t\tif (argType === `${SUI_FRAMEWORK_ADDRESS}::deny_list::DenyList`) {\n\t\t\tnormalizedArgs.push((tx) => tx.object.denyList());\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (argType === `${SUI_FRAMEWORK_ADDRESS}::random::Random`) {\n\t\t\tnormalizedArgs.push((tx) => tx.object.random());\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (argType === `${SUI_FRAMEWORK_ADDRESS}::clock::Clock`) {\n\t\t\tnormalizedArgs.push((tx) => tx.object.clock());\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (argType === `${SUI_SYSTEM_ADDRESS}::sui_system::SuiSystemState`) {\n\t\t\tnormalizedArgs.push((tx) => tx.object.system());\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet arg;\n\t\tif (Array.isArray(args)) {\n\t\t\tif (index >= args.length) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Invalid number of arguments, expected at least ${index + 1}, got ${args.length}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\targ = args[index];\n\t\t} else {\n\t\t\tif (!parameterNames) {\n\t\t\t\tthrow new Error(`Expected arguments to be passed as an array`);\n\t\t\t}\n\t\t\tconst name = parameterNames[index];\n\t\t\targ = args[name as keyof typeof args];\n\n\t\t\tif (arg == null) {\n\t\t\t\tthrow new Error(`Parameter ${name} is required`);\n\t\t\t}\n\t\t}\n\n\t\tindex += 1;\n\n\t\tif (typeof arg === 'function' || isArgument(arg)) {\n\t\t\tnormalizedArgs.push(arg as TransactionArgument);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst type = argTypes[i];\n\t\tconst bcsType = getPureBcsSchema(type);\n\n\t\tif (bcsType) {\n\t\t\tconst bytes = bcsType.serialize(arg as never);\n\t\t\tnormalizedArgs.push((tx) => tx.pure(bytes));\n\t\t\tcontinue;\n\t\t} else if (typeof arg === 'string') {\n\t\t\tnormalizedArgs.push((tx) => tx.object(arg));\n\t\t\tcontinue;\n\t\t}\n\n\t\tthrow new Error(`Invalid argument ${stringify(arg)} for type ${type}`);\n\t}\n\n\treturn normalizedArgs;\n}\n\nexport class MoveStruct<\n\tT extends Record<string, BcsType<any>>,\n\tconst Name extends string = string,\n> extends BcsStruct<T, Name> {}\n\nexport class MoveEnum<\n\tT extends Record<string, BcsType<any> | null>,\n\tconst Name extends string,\n> extends BcsEnum<T, Name> {}\n\nexport class MoveTuple<\n\tT extends readonly BcsType<any>[],\n\tconst Name extends string,\n> extends BcsTuple<T, Name> {}\n\nfunction stringify(val: unknown) {\n\tif (typeof val === 'object') {\n\t\treturn JSON.stringify(val, (val: unknown) => val);\n\t}\n\tif (typeof val === 'bigint') {\n\t\treturn val.toString();\n\t}\n\n\treturn val;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/** Sui object identifiers */\n\nimport { MoveStruct } from '../../../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nconst $moduleName = '0x2::object';\nexport const UID = new MoveStruct({\n\tname: `${$moduleName}::UID`,\n\tfields: {\n\t\tid: bcs.Address,\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveStruct, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as object from './deps/sui/object.js';\nconst $moduleName = '@local-pkg/walrus::storage_resource';\nexport const Storage = new MoveStruct({\n\tname: `${$moduleName}::Storage`,\n\tfields: {\n\t\tid: object.UID,\n\t\tstart_epoch: bcs.u32(),\n\t\tend_epoch: bcs.u32(),\n\t\tstorage_size: bcs.u64(),\n\t},\n});\nexport interface StartEpochArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface StartEpochOptions {\n\tpackage?: string;\n\targuments: StartEpochArguments | [self: RawTransactionArgument<string>];\n}\nexport function startEpoch(options: StartEpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_resource::Storage`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'start_epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface EndEpochArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface EndEpochOptions {\n\tpackage?: string;\n\targuments: EndEpochArguments | [self: RawTransactionArgument<string>];\n}\nexport function endEpoch(options: EndEpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_resource::Storage`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'end_epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SizeArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface SizeOptions {\n\tpackage?: string;\n\targuments: SizeArguments | [self: RawTransactionArgument<string>];\n}\nexport function size(options: SizeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_resource::Storage`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'size',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SplitByEpochArguments {\n\tstorage: RawTransactionArgument<string>;\n\tsplitEpoch: RawTransactionArgument<number>;\n}\nexport interface SplitByEpochOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SplitByEpochArguments\n\t\t| [storage: RawTransactionArgument<string>, splitEpoch: RawTransactionArgument<number>];\n}\n/**\n * Splits the storage object into two based on `split_epoch`.\n *\n * `storage` is modified to cover the period from `start_epoch` to `split_epoch`\n * and a new storage object covering `split_epoch` to `end_epoch` is returned.\n */\nexport function splitByEpoch(options: SplitByEpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_resource::Storage`, 'u32'] satisfies string[];\n\tconst parameterNames = ['storage', 'splitEpoch'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'split_by_epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SplitBySizeArguments {\n\tstorage: RawTransactionArgument<string>;\n\tsplitSize: RawTransactionArgument<number | bigint>;\n}\nexport interface SplitBySizeOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SplitBySizeArguments\n\t\t| [storage: RawTransactionArgument<string>, splitSize: RawTransactionArgument<number | bigint>];\n}\n/**\n * Splits the storage object into two based on `split_size`.\n *\n * `storage` is modified to cover `split_size` and a new object covering\n * `storage.storage_size - split_size` is created.\n */\nexport function splitBySize(options: SplitBySizeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_resource::Storage`, 'u64'] satisfies string[];\n\tconst parameterNames = ['storage', 'splitSize'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'split_by_size',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface FusePeriodsArguments {\n\tfirst: RawTransactionArgument<string>;\n\tsecond: RawTransactionArgument<string>;\n}\nexport interface FusePeriodsOptions {\n\tpackage?: string;\n\targuments:\n\t\t| FusePeriodsArguments\n\t\t| [first: RawTransactionArgument<string>, second: RawTransactionArgument<string>];\n}\n/** Fuse two storage objects that cover adjacent periods with the same storage size. */\nexport function fusePeriods(options: FusePeriodsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::storage_resource::Storage`,\n\t\t`${packageAddress}::storage_resource::Storage`,\n\t] satisfies string[];\n\tconst parameterNames = ['first', 'second'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'fuse_periods',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface FuseAmountArguments {\n\tfirst: RawTransactionArgument<string>;\n\tsecond: RawTransactionArgument<string>;\n}\nexport interface FuseAmountOptions {\n\tpackage?: string;\n\targuments:\n\t\t| FuseAmountArguments\n\t\t| [first: RawTransactionArgument<string>, second: RawTransactionArgument<string>];\n}\n/** Fuse two storage objects that cover the same period. */\nexport function fuseAmount(options: FuseAmountOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::storage_resource::Storage`,\n\t\t`${packageAddress}::storage_resource::Storage`,\n\t] satisfies string[];\n\tconst parameterNames = ['first', 'second'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'fuse_amount',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface FuseArguments {\n\tfirst: RawTransactionArgument<string>;\n\tsecond: RawTransactionArgument<string>;\n}\nexport interface FuseOptions {\n\tpackage?: string;\n\targuments:\n\t\t| FuseArguments\n\t\t| [first: RawTransactionArgument<string>, second: RawTransactionArgument<string>];\n}\n/**\n * Fuse two storage objects that either cover the same period or adjacent periods\n * with the same storage size.\n */\nexport function fuse(options: FuseOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::storage_resource::Storage`,\n\t\t`${packageAddress}::storage_resource::Storage`,\n\t] satisfies string[];\n\tconst parameterNames = ['first', 'second'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'fuse',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface DestroyArguments {\n\tstorage: RawTransactionArgument<string>;\n}\nexport interface DestroyOptions {\n\tpackage?: string;\n\targuments: DestroyArguments | [storage: RawTransactionArgument<string>];\n}\n/** Destructor for [Storage] objects. */\nexport function destroy(options: DestroyOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_resource::Storage`] satisfies string[];\n\tconst parameterNames = ['storage'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_resource',\n\t\t\tfunction: 'destroy',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveStruct, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as object from './deps/sui/object.js';\nimport * as storage_resource from './storage_resource.js';\nconst $moduleName = '@local-pkg/walrus::blob';\nexport const Blob = new MoveStruct({\n\tname: `${$moduleName}::Blob`,\n\tfields: {\n\t\tid: object.UID,\n\t\tregistered_epoch: bcs.u32(),\n\t\tblob_id: bcs.u256(),\n\t\tsize: bcs.u64(),\n\t\tencoding_type: bcs.u8(),\n\t\tcertified_epoch: bcs.option(bcs.u32()),\n\t\tstorage: storage_resource.Storage,\n\t\tdeletable: bcs.bool(),\n\t},\n});\nexport const BlobIdDerivation = new MoveStruct({\n\tname: `${$moduleName}::BlobIdDerivation`,\n\tfields: {\n\t\tencoding_type: bcs.u8(),\n\t\tsize: bcs.u64(),\n\t\troot_hash: bcs.u256(),\n\t},\n});\nexport interface ObjectIdArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface ObjectIdOptions {\n\tpackage?: string;\n\targuments: ObjectIdArguments | [self: RawTransactionArgument<string>];\n}\nexport function objectId(options: ObjectIdOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'object_id',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RegisteredEpochArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface RegisteredEpochOptions {\n\tpackage?: string;\n\targuments: RegisteredEpochArguments | [self: RawTransactionArgument<string>];\n}\nexport function registeredEpoch(options: RegisteredEpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'registered_epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface BlobIdArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface BlobIdOptions {\n\tpackage?: string;\n\targuments: BlobIdArguments | [self: RawTransactionArgument<string>];\n}\nexport function blobId(options: BlobIdOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'blob_id',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SizeArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface SizeOptions {\n\tpackage?: string;\n\targuments: SizeArguments | [self: RawTransactionArgument<string>];\n}\nexport function size(options: SizeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'size',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface EncodingTypeArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface EncodingTypeOptions {\n\tpackage?: string;\n\targuments: EncodingTypeArguments | [self: RawTransactionArgument<string>];\n}\nexport function encodingType(options: EncodingTypeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'encoding_type',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface CertifiedEpochArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface CertifiedEpochOptions {\n\tpackage?: string;\n\targuments: CertifiedEpochArguments | [self: RawTransactionArgument<string>];\n}\nexport function certifiedEpoch(options: CertifiedEpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'certified_epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface StorageArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface StorageOptions {\n\tpackage?: string;\n\targuments: StorageArguments | [self: RawTransactionArgument<string>];\n}\nexport function storage(options: StorageOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'storage',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface IsDeletableArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface IsDeletableOptions {\n\tpackage?: string;\n\targuments: IsDeletableArguments | [self: RawTransactionArgument<string>];\n}\nexport function isDeletable(options: IsDeletableOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'is_deletable',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface EncodedSizeArguments {\n\tself: RawTransactionArgument<string>;\n\tnShards: RawTransactionArgument<number>;\n}\nexport interface EncodedSizeOptions {\n\tpackage?: string;\n\targuments:\n\t\t| EncodedSizeArguments\n\t\t| [self: RawTransactionArgument<string>, nShards: RawTransactionArgument<number>];\n}\nexport function encodedSize(options: EncodedSizeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`, 'u16'] satisfies string[];\n\tconst parameterNames = ['self', 'nShards'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'encoded_size',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface EndEpochArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface EndEpochOptions {\n\tpackage?: string;\n\targuments: EndEpochArguments | [self: RawTransactionArgument<string>];\n}\nexport function endEpoch(options: EndEpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'end_epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface DeriveBlobIdArguments {\n\trootHash: RawTransactionArgument<number | bigint>;\n\tencodingType: RawTransactionArgument<number>;\n\tsize: RawTransactionArgument<number | bigint>;\n}\nexport interface DeriveBlobIdOptions {\n\tpackage?: string;\n\targuments:\n\t\t| DeriveBlobIdArguments\n\t\t| [\n\t\t\t\trootHash: RawTransactionArgument<number | bigint>,\n\t\t\t\tencodingType: RawTransactionArgument<number>,\n\t\t\t\tsize: RawTransactionArgument<number | bigint>,\n\t\t  ];\n}\n/** Derives the blob_id for a blob given the root_hash, encoding_type and size. */\nexport function deriveBlobId(options: DeriveBlobIdOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = ['u256', 'u8', 'u64'] satisfies string[];\n\tconst parameterNames = ['rootHash', 'encodingType', 'size'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'derive_blob_id',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface BurnArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface BurnOptions {\n\tpackage?: string;\n\targuments: BurnArguments | [self: RawTransactionArgument<string>];\n}\n/**\n * Allow the owner of a blob object to destroy it.\n *\n * This function also burns any [`Metadata`] associated with the blob, if present.\n */\nexport function burn(options: BurnOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'burn',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface AddMetadataArguments {\n\tself: RawTransactionArgument<string>;\n\tmetadata: RawTransactionArgument<string>;\n}\nexport interface AddMetadataOptions {\n\tpackage?: string;\n\targuments:\n\t\t| AddMetadataArguments\n\t\t| [self: RawTransactionArgument<string>, metadata: RawTransactionArgument<string>];\n}\n/**\n * Adds the metadata dynamic field to the Blob.\n *\n * Aborts if the metadata is already present.\n */\nexport function addMetadata(options: AddMetadataOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::blob::Blob`,\n\t\t`${packageAddress}::metadata::Metadata`,\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'metadata'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'add_metadata',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface AddOrReplaceMetadataArguments {\n\tself: RawTransactionArgument<string>;\n\tmetadata: RawTransactionArgument<string>;\n}\nexport interface AddOrReplaceMetadataOptions {\n\tpackage?: string;\n\targuments:\n\t\t| AddOrReplaceMetadataArguments\n\t\t| [self: RawTransactionArgument<string>, metadata: RawTransactionArgument<string>];\n}\n/**\n * Adds the metadata dynamic field to the Blob, replacing the existing metadata if\n * present.\n *\n * Returns the replaced metadata if present.\n */\nexport function addOrReplaceMetadata(options: AddOrReplaceMetadataOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::blob::Blob`,\n\t\t`${packageAddress}::metadata::Metadata`,\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'metadata'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'add_or_replace_metadata',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface TakeMetadataArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface TakeMetadataOptions {\n\tpackage?: string;\n\targuments: TakeMetadataArguments | [self: RawTransactionArgument<string>];\n}\n/**\n * Removes the metadata dynamic field from the Blob, returning the contained\n * `Metadata`.\n *\n * Aborts if the metadata does not exist.\n */\nexport function takeMetadata(options: TakeMetadataOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::blob::Blob`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'take_metadata',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface InsertOrUpdateMetadataPairArguments {\n\tself: RawTransactionArgument<string>;\n\tkey: RawTransactionArgument<string>;\n\tvalue: RawTransactionArgument<string>;\n}\nexport interface InsertOrUpdateMetadataPairOptions {\n\tpackage?: string;\n\targuments:\n\t\t| InsertOrUpdateMetadataPairArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tkey: RawTransactionArgument<string>,\n\t\t\t\tvalue: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Inserts a key-value pair into the metadata.\n *\n * If the key is already present, the value is updated. Creates new metadata on the\n * Blob object if it does not exist already.\n */\nexport function insertOrUpdateMetadataPair(options: InsertOrUpdateMetadataPairOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::blob::Blob`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'key', 'value'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'insert_or_update_metadata_pair',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RemoveMetadataPairArguments {\n\tself: RawTransactionArgument<string>;\n\tkey: RawTransactionArgument<string>;\n}\nexport interface RemoveMetadataPairOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RemoveMetadataPairArguments\n\t\t| [self: RawTransactionArgument<string>, key: RawTransactionArgument<string>];\n}\n/**\n * Removes the metadata associated with the given key.\n *\n * Aborts if the metadata does not exist.\n */\nexport function removeMetadataPair(options: RemoveMetadataPairOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::blob::Blob`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'key'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'remove_metadata_pair',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RemoveMetadataPairIfExistsArguments {\n\tself: RawTransactionArgument<string>;\n\tkey: RawTransactionArgument<string>;\n}\nexport interface RemoveMetadataPairIfExistsOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RemoveMetadataPairIfExistsArguments\n\t\t| [self: RawTransactionArgument<string>, key: RawTransactionArgument<string>];\n}\n/** Removes and returns the metadata associated with the given key, if it exists. */\nexport function removeMetadataPairIfExists(options: RemoveMetadataPairIfExistsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::blob::Blob`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'key'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'blob',\n\t\t\tfunction: 'remove_metadata_pair_if_exists',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { bcs } from '@mysten/sui/bcs';\nimport type { BcsType } from '@mysten/sui/bcs';\nimport { MoveStruct } from '../../../utils/index.js';\nconst $moduleName = '0x2::vec_map';\n/** An entry in the map */\nexport function Entry<K extends BcsType<any>, V extends BcsType<any>>(...typeParameters: [K, V]) {\n\treturn new MoveStruct({\n\t\tname: `${$moduleName}::Entry<${typeParameters[0].name as K['name']}, ${typeParameters[1].name as V['name']}>`,\n\t\tfields: {\n\t\t\tkey: typeParameters[0],\n\t\t\tvalue: typeParameters[1],\n\t\t},\n\t});\n}\n/**\n * A map data structure backed by a vector. The map is guaranteed not to contain\n * duplicate keys, but entries are _not_ sorted by key--entries are included in\n * insertion order. All operations are O(N) in the size of the map--the intention\n * of this data structure is only to provide the convenience of programming against\n * a map API. Large maps should use handwritten parent/child relationships instead.\n * Maps that need sorted iteration rather than insertion order iteration should\n * also be handwritten.\n */\nexport function VecMap<K extends BcsType<any>, V extends BcsType<any>>(...typeParameters: [K, V]) {\n\treturn new MoveStruct({\n\t\tname: `${$moduleName}::VecMap<${typeParameters[0].name as K['name']}, ${typeParameters[1].name as V['name']}>`,\n\t\tfields: {\n\t\t\tcontents: bcs.vector(Entry(typeParameters[0], typeParameters[1])),\n\t\t},\n\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/** Contains the metadata for Blobs on Walrus. */\n\nimport { MoveStruct, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as vec_map from './deps/sui/vec_map.js';\nconst $moduleName = '@local-pkg/walrus::metadata';\nexport const Metadata = new MoveStruct({\n\tname: `${$moduleName}::Metadata`,\n\tfields: {\n\t\tmetadata: vec_map.VecMap(bcs.string(), bcs.string()),\n\t},\n});\nexport interface NewOptions {\n\tpackage?: string;\n\targuments?: [];\n}\n/** Creates a new instance of Metadata. */\nexport function _new(options: NewOptions = {}) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'metadata',\n\t\t\tfunction: 'new',\n\t\t});\n}\nexport interface InsertOrUpdateArguments {\n\tself: RawTransactionArgument<string>;\n\tkey: RawTransactionArgument<string>;\n\tvalue: RawTransactionArgument<string>;\n}\nexport interface InsertOrUpdateOptions {\n\tpackage?: string;\n\targuments:\n\t\t| InsertOrUpdateArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tkey: RawTransactionArgument<string>,\n\t\t\t\tvalue: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Inserts a key-value pair into the metadata.\n *\n * If the key is already present, the value is updated.\n */\nexport function insertOrUpdate(options: InsertOrUpdateOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::metadata::Metadata`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'key', 'value'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'metadata',\n\t\t\tfunction: 'insert_or_update',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RemoveArguments {\n\tself: RawTransactionArgument<string>;\n\tkey: RawTransactionArgument<string>;\n}\nexport interface RemoveOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RemoveArguments\n\t\t| [self: RawTransactionArgument<string>, key: RawTransactionArgument<string>];\n}\n/** Removes the metadata associated with the given key. */\nexport function remove(options: RemoveOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::metadata::Metadata`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'key'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'metadata',\n\t\t\tfunction: 'remove',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RemoveIfExistsArguments {\n\tself: RawTransactionArgument<string>;\n\tkey: RawTransactionArgument<string>;\n}\nexport interface RemoveIfExistsOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RemoveIfExistsArguments\n\t\t| [self: RawTransactionArgument<string>, key: RawTransactionArgument<string>];\n}\n/**\n * Removes the metadata associated with the given key, if it exists.\n *\n * Optionally returns the previous value associated with the key.\n */\nexport function removeIfExists(options: RemoveIfExistsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::metadata::Metadata`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'key'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'metadata',\n\t\t\tfunction: 'remove_if_exists',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Similar to `sui::table`, an `ObjectTable<K, V>` is a map-like collection. But\n * unlike `sui::table`, the values bound to these dynamic fields _must_ be objects\n * themselves. This allows for the objects to still exist within in storage, which\n * may be important for external tools. The difference is otherwise not observable\n * from within Move.\n */\n\nimport { MoveStruct } from '../../../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport * as object from './object.js';\nconst $moduleName = '0x2::object_table';\nexport const ObjectTable = new MoveStruct({\n\tname: `${$moduleName}::ObjectTable`,\n\tfields: {\n\t\t/** the ID of this table */\n\t\tid: object.UID,\n\t\t/** the number of key-value pairs in the table */\n\t\tsize: bcs.u64(),\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/** Module: extended_field */\n\nimport { MoveStruct, MoveTuple, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { BcsType } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as object from './deps/sui/object.js';\nconst $moduleName = '@local-pkg/walrus::extended_field';\nexport const ExtendedField = new MoveStruct({\n\tname: `${$moduleName}::ExtendedField`,\n\tfields: {\n\t\tid: object.UID,\n\t},\n});\nexport const Key = new MoveTuple({ name: `${$moduleName}::Key`, fields: [bcs.bool()] });\nexport interface NewArguments<T extends BcsType<any>> {\n\tvalue: RawTransactionArgument<T>;\n}\nexport interface NewOptions<T extends BcsType<any>> {\n\tpackage?: string;\n\targuments: NewArguments<T> | [value: RawTransactionArgument<T>];\n\ttypeArguments: [string];\n}\n/** Creates a new extended field with the given value. */\nexport function _new<T extends BcsType<any>>(options: NewOptions<T>) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${options.typeArguments[0]}`] satisfies string[];\n\tconst parameterNames = ['value'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'extended_field',\n\t\t\tfunction: 'new',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t\ttypeArguments: options.typeArguments,\n\t\t});\n}\nexport interface BorrowArguments {\n\tfield: RawTransactionArgument<string>;\n}\nexport interface BorrowOptions {\n\tpackage?: string;\n\targuments: BorrowArguments | [field: RawTransactionArgument<string>];\n\ttypeArguments: [string];\n}\n/** Borrows the value stored in the extended field. */\nexport function borrow(options: BorrowOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::extended_field::ExtendedField<${options.typeArguments[0]}>`,\n\t] satisfies string[];\n\tconst parameterNames = ['field'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'extended_field',\n\t\t\tfunction: 'borrow',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t\ttypeArguments: options.typeArguments,\n\t\t});\n}\nexport interface BorrowMutArguments {\n\tfield: RawTransactionArgument<string>;\n}\nexport interface BorrowMutOptions {\n\tpackage?: string;\n\targuments: BorrowMutArguments | [field: RawTransactionArgument<string>];\n\ttypeArguments: [string];\n}\n/** Borrows the value stored in the extended field mutably. */\nexport function borrowMut(options: BorrowMutOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::extended_field::ExtendedField<${options.typeArguments[0]}>`,\n\t] satisfies string[];\n\tconst parameterNames = ['field'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'extended_field',\n\t\t\tfunction: 'borrow_mut',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t\ttypeArguments: options.typeArguments,\n\t\t});\n}\nexport interface SwapArguments<T extends BcsType<any>> {\n\tfield: RawTransactionArgument<string>;\n\tvalue: RawTransactionArgument<T>;\n}\nexport interface SwapOptions<T extends BcsType<any>> {\n\tpackage?: string;\n\targuments:\n\t\t| SwapArguments<T>\n\t\t| [field: RawTransactionArgument<string>, value: RawTransactionArgument<T>];\n\ttypeArguments: [string];\n}\n/** Swaps the value stored in the extended field with the given value. */\nexport function swap<T extends BcsType<any>>(options: SwapOptions<T>) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::extended_field::ExtendedField<${options.typeArguments[0]}>`,\n\t\t`${options.typeArguments[0]}`,\n\t] satisfies string[];\n\tconst parameterNames = ['field', 'value'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'extended_field',\n\t\t\tfunction: 'swap',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t\ttypeArguments: options.typeArguments,\n\t\t});\n}\nexport interface DestroyArguments {\n\tfield: RawTransactionArgument<string>;\n}\nexport interface DestroyOptions {\n\tpackage?: string;\n\targuments: DestroyArguments | [field: RawTransactionArgument<string>];\n\ttypeArguments: [string];\n}\n/** Destroys the extended field and returns the value stored in it. */\nexport function destroy(options: DestroyOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::extended_field::ExtendedField<${options.typeArguments[0]}>`,\n\t] satisfies string[];\n\tconst parameterNames = ['field'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'extended_field',\n\t\t\tfunction: 'destroy',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t\ttypeArguments: options.typeArguments,\n\t\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This module defines the `Committee` struct which stores the current committee\n * with shard assignments. Additionally, it manages transitions / transfers of\n * shards between committees with the least amount of changes.\n */\n\nimport { MoveTuple, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as vec_map from './deps/sui/vec_map.js';\nconst $moduleName = '@local-pkg/walrus::committee';\nexport const Committee = new MoveTuple({\n\tname: `${$moduleName}::Committee`,\n\tfields: [vec_map.VecMap(bcs.Address, bcs.vector(bcs.u16()))],\n});\nexport interface ShardsArguments {\n\tcmt: RawTransactionArgument<string>;\n\tnodeId: RawTransactionArgument<string>;\n}\nexport interface ShardsOptions {\n\tpackage?: string;\n\targuments:\n\t\t| ShardsArguments\n\t\t| [cmt: RawTransactionArgument<string>, nodeId: RawTransactionArgument<string>];\n}\n/** Get the shards assigned to the given `node_id`. */\nexport function shards(options: ShardsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::committee::Committee`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::object::ID',\n\t] satisfies string[];\n\tconst parameterNames = ['cmt', 'nodeId'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'committee',\n\t\t\tfunction: 'shards',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SizeArguments {\n\tcmt: RawTransactionArgument<string>;\n}\nexport interface SizeOptions {\n\tpackage?: string;\n\targuments: SizeArguments | [cmt: RawTransactionArgument<string>];\n}\n/** Get the number of nodes in the committee. */\nexport function size(options: SizeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::committee::Committee`] satisfies string[];\n\tconst parameterNames = ['cmt'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'committee',\n\t\t\tfunction: 'size',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface InnerArguments {\n\tcmt: RawTransactionArgument<string>;\n}\nexport interface InnerOptions {\n\tpackage?: string;\n\targuments: InnerArguments | [cmt: RawTransactionArgument<string>];\n}\n/** Get the inner representation of the committee. */\nexport function inner(options: InnerOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::committee::Committee`] satisfies string[];\n\tconst parameterNames = ['cmt'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'committee',\n\t\t\tfunction: 'inner',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ToInnerArguments {\n\tcmt: RawTransactionArgument<string>;\n}\nexport interface ToInnerOptions {\n\tpackage?: string;\n\targuments: ToInnerArguments | [cmt: RawTransactionArgument<string>];\n}\n/** Copy the inner representation of the committee. */\nexport function toInner(options: ToInnerOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::committee::Committee`] satisfies string[];\n\tconst parameterNames = ['cmt'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'committee',\n\t\t\tfunction: 'to_inner',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveStruct } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nconst $moduleName = '@local-pkg/walrus::epoch_parameters';\nexport const EpochParams = new MoveStruct({\n\tname: `${$moduleName}::EpochParams`,\n\tfields: {\n\t\t/** The storage capacity of the system. */\n\t\ttotal_capacity_size: bcs.u64(),\n\t\t/** The price per unit size of storage. */\n\t\tstorage_price_per_unit_size: bcs.u64(),\n\t\t/** The write price per unit size. */\n\t\twrite_price_per_unit_size: bcs.u64(),\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveEnum, MoveStruct } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport * as object_table from './deps/sui/object_table.js';\nimport * as extended_field from './extended_field.js';\nimport * as committee from './committee.js';\nimport * as epoch_parameters from './epoch_parameters.js';\nconst $moduleName = '@local-pkg/walrus::staking_inner';\n/** The epoch state. */\nexport const EpochState = new MoveEnum({\n\tname: `${$moduleName}::EpochState`,\n\tfields: {\n\t\tEpochChangeSync: bcs.u16(),\n\t\tEpochChangeDone: bcs.u64(),\n\t\tNextParamsSelected: bcs.u64(),\n\t},\n});\nexport const StakingInnerV1 = new MoveStruct({\n\tname: `${$moduleName}::StakingInnerV1`,\n\tfields: {\n\t\t/** The number of shards in the system. */\n\t\tn_shards: bcs.u16(),\n\t\t/** The duration of an epoch in ms. Does not affect the first (zero) epoch. */\n\t\tepoch_duration: bcs.u64(),\n\t\t/**\n\t\t * Special parameter, used only for the first epoch. The timestamp when the first\n\t\t * epoch can be started.\n\t\t */\n\t\tfirst_epoch_start: bcs.u64(),\n\t\t/**\n\t\t * Stored staking pools, each identified by a unique `ID` and contains the\n\t\t * `StakingPool` object. Uses `ObjectTable` to make the pool discovery easier by\n\t\t * avoiding wrapping.\n\t\t *\n\t\t * The key is the ID of the staking pool.\n\t\t */\n\t\tpools: object_table.ObjectTable,\n\t\t/**\n\t\t * The current epoch of the Walrus system. The epochs are not the same as the Sui\n\t\t * epochs, not to be mistaken with `ctx.epoch()`.\n\t\t */\n\t\tepoch: bcs.u32(),\n\t\t/** Stores the active set of storage nodes. Tracks the total amount of staked WAL. */\n\t\tactive_set: extended_field.ExtendedField,\n\t\t/** The next committee in the system. */\n\t\tnext_committee: bcs.option(committee.Committee),\n\t\t/** The current committee in the system. */\n\t\tcommittee: committee.Committee,\n\t\t/** The previous committee in the system. */\n\t\tprevious_committee: committee.Committee,\n\t\t/** The next epoch parameters. */\n\t\tnext_epoch_params: bcs.option(epoch_parameters.EpochParams),\n\t\t/** The state of the current epoch. */\n\t\tepoch_state: EpochState,\n\t\t/**\n\t\t * The public keys for the next epoch. The keys are stored in a sorted `VecMap`,\n\t\t * and mirror the order of the nodes in the `next_committee`. The value is set in\n\t\t * the `select_committee` function and consumed in the `next_bls_committee`\n\t\t * function.\n\t\t */\n\t\tnext_epoch_public_keys: extended_field.ExtendedField,\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/** Generic Move and native functions for group operations. */\n\nimport { MoveStruct } from '../../../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nconst $moduleName = '0x2::group_ops';\nexport const Element = new MoveStruct({\n\tname: `${$moduleName}::Element`,\n\tfields: {\n\t\tbytes: bcs.vector(bcs.u8()),\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/** Module to certify event blobs. */\n\nimport { MoveStruct } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport * as vec_map from './deps/sui/vec_map.js';\nconst $moduleName = '@local-pkg/walrus::event_blob';\nexport const EventBlobAttestation = new MoveStruct({\n\tname: `${$moduleName}::EventBlobAttestation`,\n\tfields: {\n\t\tcheckpoint_sequence_num: bcs.u64(),\n\t\tepoch: bcs.u32(),\n\t},\n});\nexport const EventBlob = new MoveStruct({\n\tname: `${$moduleName}::EventBlob`,\n\tfields: {\n\t\t/** Blob id of the certified event blob. */\n\t\tblob_id: bcs.u256(),\n\t\t/** Ending sui checkpoint of the certified event blob. */\n\t\tending_checkpoint_sequence_number: bcs.u64(),\n\t},\n});\nexport const EventBlobCertificationState = new MoveStruct({\n\tname: `${$moduleName}::EventBlobCertificationState`,\n\tfields: {\n\t\t/** Latest certified event blob. */\n\t\tlatest_certified_blob: bcs.option(EventBlob),\n\t\t/** Current event blob being attested. */\n\t\taggregate_weight_per_blob: vec_map.VecMap(EventBlob, bcs.u16()),\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveStruct, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as group_ops from './deps/sui/group_ops.js';\nimport * as extended_field from './extended_field.js';\nimport * as object from './deps/sui/object.js';\nimport * as event_blob from './event_blob.js';\nconst $moduleName = '@local-pkg/walrus::storage_node';\nexport const StorageNodeInfo = new MoveStruct({\n\tname: `${$moduleName}::StorageNodeInfo`,\n\tfields: {\n\t\tname: bcs.string(),\n\t\tnode_id: bcs.Address,\n\t\tnetwork_address: bcs.string(),\n\t\tpublic_key: group_ops.Element,\n\t\tnext_epoch_public_key: bcs.option(group_ops.Element),\n\t\tnetwork_public_key: bcs.vector(bcs.u8()),\n\t\tmetadata: extended_field.ExtendedField,\n\t},\n});\nexport const StorageNodeCap = new MoveStruct({\n\tname: `${$moduleName}::StorageNodeCap`,\n\tfields: {\n\t\tid: object.UID,\n\t\tnode_id: bcs.Address,\n\t\tlast_epoch_sync_done: bcs.u32(),\n\t\tlast_event_blob_attestation: bcs.option(event_blob.EventBlobAttestation),\n\t\t/** Stores the Merkle root of the deny list for the storage node. */\n\t\tdeny_list_root: bcs.u256(),\n\t\t/** Stores the sequence number of the deny list for the storage node. */\n\t\tdeny_list_sequence: bcs.u64(),\n\t\t/** Stores the size of the deny list for the storage node. */\n\t\tdeny_list_size: bcs.u64(),\n\t},\n});\nexport interface IdArguments {\n\tcap: RawTransactionArgument<string>;\n}\nexport interface IdOptions {\n\tpackage?: string;\n\targuments: IdArguments | [cap: RawTransactionArgument<string>];\n}\n/** Return the node ID of the storage node. */\nexport function id(options: IdOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_node::StorageNodeInfo`] satisfies string[];\n\tconst parameterNames = ['cap'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_node',\n\t\t\tfunction: 'id',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface NodeIdArguments {\n\tcap: RawTransactionArgument<string>;\n}\nexport interface NodeIdOptions {\n\tpackage?: string;\n\targuments: NodeIdArguments | [cap: RawTransactionArgument<string>];\n}\n/** Return the pool ID of the storage node. */\nexport function nodeId(options: NodeIdOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_node::StorageNodeCap`] satisfies string[];\n\tconst parameterNames = ['cap'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_node',\n\t\t\tfunction: 'node_id',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface LastEpochSyncDoneArguments {\n\tcap: RawTransactionArgument<string>;\n}\nexport interface LastEpochSyncDoneOptions {\n\tpackage?: string;\n\targuments: LastEpochSyncDoneArguments | [cap: RawTransactionArgument<string>];\n}\n/**\n * Return the last epoch in which the storage node attested that it has finished\n * syncing.\n */\nexport function lastEpochSyncDone(options: LastEpochSyncDoneOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_node::StorageNodeCap`] satisfies string[];\n\tconst parameterNames = ['cap'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_node',\n\t\t\tfunction: 'last_epoch_sync_done',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface LastEventBlobAttestationArguments {\n\tcap: RawTransactionArgument<string>;\n}\nexport interface LastEventBlobAttestationOptions {\n\tpackage?: string;\n\targuments: LastEventBlobAttestationArguments | [cap: RawTransactionArgument<string>];\n}\n/** Return the latest event blob attestation. */\nexport function lastEventBlobAttestation(options: LastEventBlobAttestationOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_node::StorageNodeCap`] satisfies string[];\n\tconst parameterNames = ['cap'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_node',\n\t\t\tfunction: 'last_event_blob_attestation',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface DenyListRootArguments {\n\tcap: RawTransactionArgument<string>;\n}\nexport interface DenyListRootOptions {\n\tpackage?: string;\n\targuments: DenyListRootArguments | [cap: RawTransactionArgument<string>];\n}\n/** Return the deny list root of the storage node. */\nexport function denyListRoot(options: DenyListRootOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_node::StorageNodeCap`] satisfies string[];\n\tconst parameterNames = ['cap'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_node',\n\t\t\tfunction: 'deny_list_root',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface DenyListSequenceArguments {\n\tcap: RawTransactionArgument<string>;\n}\nexport interface DenyListSequenceOptions {\n\tpackage?: string;\n\targuments: DenyListSequenceArguments | [cap: RawTransactionArgument<string>];\n}\n/** Return the deny list sequence number of the storage node. */\nexport function denyListSequence(options: DenyListSequenceOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::storage_node::StorageNodeCap`] satisfies string[];\n\tconst parameterNames = ['cap'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_node',\n\t\t\tfunction: 'deny_list_sequence',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveTuple } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport * as vec_map from './deps/sui/vec_map.js';\nconst $moduleName = '@local-pkg/walrus::pending_values';\nexport const PendingValues = new MoveTuple({\n\tname: `${$moduleName}::PendingValues`,\n\tfields: [vec_map.VecMap(bcs.u32(), bcs.u64())],\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * A table is a map-like collection. But unlike a traditional collection, it's keys\n * and values are not stored within the `Table` value, but instead are stored using\n * Sui's object system. The `Table` struct acts only as a handle into the object\n * system to retrieve those keys and values. Note that this means that `Table`\n * values with exactly the same key-value mapping will not be equal, with `==`, at\n * runtime. For example\n *\n * ```\n * let table1 = table::new<u64, bool>();\n * let table2 = table::new<u64, bool>();\n * table::add(&mut table1, 0, false);\n * table::add(&mut table1, 1, true);\n * table::add(&mut table2, 0, false);\n * table::add(&mut table2, 1, true);\n * // table1 does not equal table2, despite having the same entries\n * assert!(&table1 != &table2);\n * ```\n */\n\nimport { MoveStruct } from '../../../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport * as object from './object.js';\nconst $moduleName = '0x2::table';\nexport const Table = new MoveStruct({\n\tname: `${$moduleName}::Table`,\n\tfields: {\n\t\t/** the ID of this table */\n\t\tid: object.UID,\n\t\t/** the number of key-value pairs in the table */\n\t\tsize: bcs.u64(),\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * A storable handler for Balances in general. Is used in the `Coin` module to\n * allow balance operations and can be used to implement custom coins with `Supply`\n * and `Balance`s.\n */\n\nimport { MoveStruct } from '../../../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nconst $moduleName = '0x2::balance';\nexport const Balance = new MoveStruct({\n\tname: `${$moduleName}::Balance`,\n\tfields: {\n\t\tvalue: bcs.u64(),\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveEnum, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { BcsType } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nconst $moduleName = '@local-pkg/walrus::auth';\n/**\n * Authentication for either a sender or an object. Unlike the `Authorized` type,\n * it cannot be stored and must be used or ignored in the same transaction.\n */\nexport const Authenticated = new MoveEnum({\n\tname: `${$moduleName}::Authenticated`,\n\tfields: {\n\t\tSender: bcs.Address,\n\t\tObject: bcs.Address,\n\t},\n});\n/**\n * Defines the ways to authorize an action. It can be either an address - checked\n * with `ctx.sender()`, - or an object - checked with `object::id(..)`.\n */\nexport const Authorized = new MoveEnum({\n\tname: `${$moduleName}::Authorized`,\n\tfields: {\n\t\tAddress: bcs.Address,\n\t\tObjectID: bcs.Address,\n\t},\n});\nexport interface AuthenticateSenderOptions {\n\tpackage?: string;\n\targuments?: [];\n}\n/** Authenticates the sender as the authorizer. */\nexport function authenticateSender(options: AuthenticateSenderOptions = {}) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'auth',\n\t\t\tfunction: 'authenticate_sender',\n\t\t});\n}\nexport interface AuthenticateWithObjectArguments<T extends BcsType<any>> {\n\tobj: RawTransactionArgument<T>;\n}\nexport interface AuthenticateWithObjectOptions<T extends BcsType<any>> {\n\tpackage?: string;\n\targuments: AuthenticateWithObjectArguments<T> | [obj: RawTransactionArgument<T>];\n\ttypeArguments: [string];\n}\n/** Authenticates an object as the authorizer. */\nexport function authenticateWithObject<T extends BcsType<any>>(\n\toptions: AuthenticateWithObjectOptions<T>,\n) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${options.typeArguments[0]}`] satisfies string[];\n\tconst parameterNames = ['obj'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'auth',\n\t\t\tfunction: 'authenticate_with_object',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t\ttypeArguments: options.typeArguments,\n\t\t});\n}\nexport interface AuthorizedAddressArguments {\n\taddr: RawTransactionArgument<string>;\n}\nexport interface AuthorizedAddressOptions {\n\tpackage?: string;\n\targuments: AuthorizedAddressArguments | [addr: RawTransactionArgument<string>];\n}\n/** Returns the `Authorized` as an address. */\nexport function authorizedAddress(options: AuthorizedAddressOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = ['address'] satisfies string[];\n\tconst parameterNames = ['addr'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'auth',\n\t\t\tfunction: 'authorized_address',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface AuthorizedObjectArguments {\n\tid: RawTransactionArgument<string>;\n}\nexport interface AuthorizedObjectOptions {\n\tpackage?: string;\n\targuments: AuthorizedObjectArguments | [id: RawTransactionArgument<string>];\n}\n/** Returns the `Authorized` as an object. */\nexport function authorizedObject(options: AuthorizedObjectOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::object::ID',\n\t] satisfies string[];\n\tconst parameterNames = ['id'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'auth',\n\t\t\tfunction: 'authorized_object',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * A bag is a heterogeneous map-like collection. The collection is similar to\n * `sui::table` in that its keys and values are not stored within the `Bag` value,\n * but instead are stored using Sui's object system. The `Bag` struct acts only as\n * a handle into the object system to retrieve those keys and values. Note that\n * this means that `Bag` values with exactly the same key-value mapping will not be\n * equal, with `==`, at runtime. For example\n *\n * ```\n * let bag1 = bag::new();\n * let bag2 = bag::new();\n * bag::add(&mut bag1, 0, false);\n * bag::add(&mut bag1, 1, true);\n * bag::add(&mut bag2, 0, false);\n * bag::add(&mut bag2, 1, true);\n * // bag1 does not equal bag2, despite having the same entries\n * assert!(&bag1 != &bag2);\n * ```\n *\n * At it's core, `sui::bag` is a wrapper around `UID` that allows for access to\n * `sui::dynamic_field` while preventing accidentally stranding field values. A\n * `UID` can be deleted, even if it has dynamic fields associated with it, but a\n * bag, on the other hand, must be empty to be destroyed.\n */\n\nimport { MoveStruct } from '../../../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport * as object from './object.js';\nconst $moduleName = '0x2::bag';\nexport const Bag = new MoveStruct({\n\tname: `${$moduleName}::Bag`,\n\tfields: {\n\t\t/** the ID of this bag */\n\t\tid: object.UID,\n\t\t/** the number of key-value pairs in the bag */\n\t\tsize: bcs.u64(),\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/** Module: staking_pool */\n\nimport { MoveStruct, MoveEnum } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport * as object from './deps/sui/object.js';\nimport * as storage_node from './storage_node.js';\nimport * as pending_values from './pending_values.js';\nimport * as table from './deps/sui/table.js';\nimport * as balance from './deps/sui/balance.js';\nimport * as auth from './auth.js';\nimport * as bag from './deps/sui/bag.js';\nconst $moduleName = '@local-pkg/walrus::staking_pool';\nexport const VotingParams = new MoveStruct({\n\tname: `${$moduleName}::VotingParams`,\n\tfields: {\n\t\t/** Voting: storage price for the next epoch. */\n\t\tstorage_price: bcs.u64(),\n\t\t/** Voting: write price for the next epoch. */\n\t\twrite_price: bcs.u64(),\n\t\t/** Voting: node capacity for the next epoch. */\n\t\tnode_capacity: bcs.u64(),\n\t},\n});\n/** Represents the state of the staking pool. */\nexport const PoolState = new MoveEnum({\n\tname: `${$moduleName}::PoolState`,\n\tfields: {\n\t\tActive: null,\n\t\tWithdrawing: bcs.u32(),\n\t\tWithdrawn: null,\n\t},\n});\nexport const StakingPool = new MoveStruct({\n\tname: `${$moduleName}::StakingPool`,\n\tfields: {\n\t\tid: object.UID,\n\t\t/** The current state of the pool. */\n\t\tstate: PoolState,\n\t\t/** Current epoch's pool parameters. */\n\t\tvoting_params: VotingParams,\n\t\t/** The storage node info for the pool. */\n\t\tnode_info: storage_node.StorageNodeInfo,\n\t\t/**\n\t\t * The epoch when the pool is / will be activated. Serves information purposes\n\t\t * only, the checks are performed in the `state` property.\n\t\t */\n\t\tactivation_epoch: bcs.u32(),\n\t\t/** Epoch when the pool was last updated. */\n\t\tlatest_epoch: bcs.u32(),\n\t\t/** Currently staked WAL in the pool + rewards pool. */\n\t\twal_balance: bcs.u64(),\n\t\t/** The total number of shares in the current epoch. */\n\t\tnum_shares: bcs.u64(),\n\t\t/**\n\t\t * The amount of the shares that will be withdrawn in E+1 or E+2. We use this\n\t\t * amount to calculate the WAL withdrawal in the `process_pending_stake`.\n\t\t */\n\t\tpending_shares_withdraw: pending_values.PendingValues,\n\t\t/**\n\t\t * The amount of the stake requested for withdrawal for a node that may part of the\n\t\t * next committee. Stores principals of not yet active stakes. In practice, those\n\t\t * tokens are staked for exactly one epoch.\n\t\t */\n\t\tpre_active_withdrawals: pending_values.PendingValues,\n\t\t/**\n\t\t * The pending commission rate for the pool. Commission rate is applied in E+2, so\n\t\t * we store the value for the matching epoch and apply it in the `advance_epoch`\n\t\t * function.\n\t\t */\n\t\tpending_commission_rate: pending_values.PendingValues,\n\t\t/** The commission rate for the pool, in basis points. */\n\t\tcommission_rate: bcs.u16(),\n\t\t/**\n\t\t * Historical exchange rates for the pool. The key is the epoch when the exchange\n\t\t * rate was set, and the value is the exchange rate (the ratio of the amount of WAL\n\t\t * tokens for the pool shares).\n\t\t */\n\t\texchange_rates: table.Table,\n\t\t/**\n\t\t * The amount of stake that will be added to the `wal_balance`. Can hold up to two\n\t\t * keys: E+1 and E+2, due to the differences in the activation epoch.\n\t\t *\n\t\t * ```\n\t\t * E+1 -> Balance\n\t\t * E+2 -> Balance\n\t\t * ```\n\t\t *\n\t\t * Single key is cleared in the `advance_epoch` function, leaving only the next\n\t\t * epoch's stake.\n\t\t */\n\t\tpending_stake: pending_values.PendingValues,\n\t\t/** The rewards that the pool has received from being in the committee. */\n\t\trewards_pool: balance.Balance,\n\t\t/** The commission that the pool has received from the rewards. */\n\t\tcommission: balance.Balance,\n\t\t/** An Object or an address which can claim the commission. */\n\t\tcommission_receiver: auth.Authorized,\n\t\t/** An Object or address that can authorize governance actions, such as upgrades. */\n\t\tgovernance_authorized: auth.Authorized,\n\t\t/** Reserved for future use and migrations. */\n\t\textra_fields: bag.Bag,\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/** Module: staking */\n\nimport { MoveStruct, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as object from './deps/sui/object.js';\nconst $moduleName = '@local-pkg/walrus::staking';\nexport const Staking = new MoveStruct({\n\tname: `${$moduleName}::Staking`,\n\tfields: {\n\t\tid: object.UID,\n\t\tversion: bcs.u64(),\n\t\tpackage_id: bcs.Address,\n\t\tnew_package_id: bcs.option(bcs.Address),\n\t},\n});\nexport interface RegisterCandidateArguments {\n\tstaking: RawTransactionArgument<string>;\n\tname: RawTransactionArgument<string>;\n\tnetworkAddress: RawTransactionArgument<string>;\n\tmetadata: RawTransactionArgument<string>;\n\tpublicKey: RawTransactionArgument<number[]>;\n\tnetworkPublicKey: RawTransactionArgument<number[]>;\n\tproofOfPossession: RawTransactionArgument<number[]>;\n\tcommissionRate: RawTransactionArgument<number>;\n\tstoragePrice: RawTransactionArgument<number | bigint>;\n\twritePrice: RawTransactionArgument<number | bigint>;\n\tnodeCapacity: RawTransactionArgument<number | bigint>;\n}\nexport interface RegisterCandidateOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RegisterCandidateArguments\n\t\t| [\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tname: RawTransactionArgument<string>,\n\t\t\t\tnetworkAddress: RawTransactionArgument<string>,\n\t\t\t\tmetadata: RawTransactionArgument<string>,\n\t\t\t\tpublicKey: RawTransactionArgument<number[]>,\n\t\t\t\tnetworkPublicKey: RawTransactionArgument<number[]>,\n\t\t\t\tproofOfPossession: RawTransactionArgument<number[]>,\n\t\t\t\tcommissionRate: RawTransactionArgument<number>,\n\t\t\t\tstoragePrice: RawTransactionArgument<number | bigint>,\n\t\t\t\twritePrice: RawTransactionArgument<number | bigint>,\n\t\t\t\tnodeCapacity: RawTransactionArgument<number | bigint>,\n\t\t  ];\n}\n/**\n * Creates a staking pool for the candidate, registers the candidate as a storage\n * node.\n */\nexport function registerCandidate(options: RegisterCandidateOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t\t`${packageAddress}::node_metadata::NodeMetadata`,\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t\t'u16',\n\t\t'u64',\n\t\t'u64',\n\t\t'u64',\n\t] satisfies string[];\n\tconst parameterNames = [\n\t\t'staking',\n\t\t'name',\n\t\t'networkAddress',\n\t\t'metadata',\n\t\t'publicKey',\n\t\t'networkPublicKey',\n\t\t'proofOfPossession',\n\t\t'commissionRate',\n\t\t'storagePrice',\n\t\t'writePrice',\n\t\t'nodeCapacity',\n\t];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'register_candidate',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetNextCommissionArguments {\n\tstaking: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tcommissionRate: RawTransactionArgument<number>;\n}\nexport interface SetNextCommissionOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetNextCommissionArguments\n\t\t| [\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tcommissionRate: RawTransactionArgument<number>,\n\t\t  ];\n}\n/**\n * Sets next_commission in the staking pool, which will then take effect as\n * commission rate one epoch after setting the value (to allow stakers to react to\n * setting this).\n */\nexport function setNextCommission(options: SetNextCommissionOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'u16',\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'cap', 'commissionRate'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_next_commission',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface CollectCommissionArguments {\n\tstaking: RawTransactionArgument<string>;\n\tnodeId: RawTransactionArgument<string>;\n\tauth: RawTransactionArgument<string>;\n}\nexport interface CollectCommissionOptions {\n\tpackage?: string;\n\targuments:\n\t\t| CollectCommissionArguments\n\t\t| [\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tnodeId: RawTransactionArgument<string>,\n\t\t\t\tauth: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Collects the commission for the node. Transaction sender must be the\n * `CommissionReceiver` for the `StakingPool`.\n */\nexport function collectCommission(options: CollectCommissionOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::object::ID',\n\t\t`${packageAddress}::auth::Authenticated`,\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'nodeId', 'auth'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'collect_commission',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetCommissionReceiverArguments {\n\tstaking: RawTransactionArgument<string>;\n\tnodeId: RawTransactionArgument<string>;\n\tauth: RawTransactionArgument<string>;\n\treceiver: RawTransactionArgument<string>;\n}\nexport interface SetCommissionReceiverOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetCommissionReceiverArguments\n\t\t| [\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tnodeId: RawTransactionArgument<string>,\n\t\t\t\tauth: RawTransactionArgument<string>,\n\t\t\t\treceiver: RawTransactionArgument<string>,\n\t\t  ];\n}\n/** Sets the commission receiver for the node. */\nexport function setCommissionReceiver(options: SetCommissionReceiverOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::object::ID',\n\t\t`${packageAddress}::auth::Authenticated`,\n\t\t`${packageAddress}::auth::Authorized`,\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'nodeId', 'auth', 'receiver'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_commission_receiver',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetGovernanceAuthorizedArguments {\n\tstaking: RawTransactionArgument<string>;\n\tnodeId: RawTransactionArgument<string>;\n\tauth: RawTransactionArgument<string>;\n\tauthorized: RawTransactionArgument<string>;\n}\nexport interface SetGovernanceAuthorizedOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetGovernanceAuthorizedArguments\n\t\t| [\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tnodeId: RawTransactionArgument<string>,\n\t\t\t\tauth: RawTransactionArgument<string>,\n\t\t\t\tauthorized: RawTransactionArgument<string>,\n\t\t  ];\n}\n/** Sets the governance authorized object for the pool. */\nexport function setGovernanceAuthorized(options: SetGovernanceAuthorizedOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::object::ID',\n\t\t`${packageAddress}::auth::Authenticated`,\n\t\t`${packageAddress}::auth::Authorized`,\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'nodeId', 'auth', 'authorized'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_governance_authorized',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface CommitteeArguments {\n\tstaking: RawTransactionArgument<string>;\n}\nexport interface CommitteeOptions {\n\tpackage?: string;\n\targuments: CommitteeArguments | [staking: RawTransactionArgument<string>];\n}\n/** Get the current committee. */\nexport function committee(options: CommitteeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::staking::Staking`] satisfies string[];\n\tconst parameterNames = ['staking'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'committee',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ComputeNextCommitteeArguments {\n\tstaking: RawTransactionArgument<string>;\n}\nexport interface ComputeNextCommitteeOptions {\n\tpackage?: string;\n\targuments: ComputeNextCommitteeArguments | [staking: RawTransactionArgument<string>];\n}\n/** Computes the committee for the next epoch. */\nexport function computeNextCommittee(options: ComputeNextCommitteeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::staking::Staking`] satisfies string[];\n\tconst parameterNames = ['staking'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'compute_next_committee',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetStoragePriceVoteArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tstoragePrice: RawTransactionArgument<number | bigint>;\n}\nexport interface SetStoragePriceVoteOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetStoragePriceVoteArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tstoragePrice: RawTransactionArgument<number | bigint>,\n\t\t  ];\n}\n/** Sets the storage price vote for the pool. */\nexport function setStoragePriceVote(options: SetStoragePriceVoteOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'u64',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'storagePrice'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_storage_price_vote',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetWritePriceVoteArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\twritePrice: RawTransactionArgument<number | bigint>;\n}\nexport interface SetWritePriceVoteOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetWritePriceVoteArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\twritePrice: RawTransactionArgument<number | bigint>,\n\t\t  ];\n}\n/** Sets the write price vote for the pool. */\nexport function setWritePriceVote(options: SetWritePriceVoteOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'u64',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'writePrice'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_write_price_vote',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetNodeCapacityVoteArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tnodeCapacity: RawTransactionArgument<number | bigint>;\n}\nexport interface SetNodeCapacityVoteOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetNodeCapacityVoteArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tnodeCapacity: RawTransactionArgument<number | bigint>,\n\t\t  ];\n}\n/** Sets the node capacity vote for the pool. */\nexport function setNodeCapacityVote(options: SetNodeCapacityVoteOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'u64',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'nodeCapacity'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_node_capacity_vote',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface NodeMetadataArguments {\n\tself: RawTransactionArgument<string>;\n\tnodeId: RawTransactionArgument<string>;\n}\nexport interface NodeMetadataOptions {\n\tpackage?: string;\n\targuments:\n\t\t| NodeMetadataArguments\n\t\t| [self: RawTransactionArgument<string>, nodeId: RawTransactionArgument<string>];\n}\n/** Get `NodeMetadata` for the given node. */\nexport function nodeMetadata(options: NodeMetadataOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::object::ID',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'nodeId'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'node_metadata',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetNextPublicKeyArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tpublicKey: RawTransactionArgument<number[]>;\n\tproofOfPossession: RawTransactionArgument<number[]>;\n}\nexport interface SetNextPublicKeyOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetNextPublicKeyArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tpublicKey: RawTransactionArgument<number[]>,\n\t\t\t\tproofOfPossession: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/**\n * Sets the public key of a node to be used starting from the next epoch for which\n * the node is selected.\n */\nexport function setNextPublicKey(options: SetNextPublicKeyOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'publicKey', 'proofOfPossession'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_next_public_key',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetNameArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tname: RawTransactionArgument<string>;\n}\nexport interface SetNameOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetNameArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tname: RawTransactionArgument<string>,\n\t\t  ];\n}\n/** Sets the name of a storage node. */\nexport function setName(options: SetNameOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'name'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_name',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetNetworkAddressArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tnetworkAddress: RawTransactionArgument<string>;\n}\nexport interface SetNetworkAddressOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetNetworkAddressArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tnetworkAddress: RawTransactionArgument<string>,\n\t\t  ];\n}\n/** Sets the network address or host of a storage node. */\nexport function setNetworkAddress(options: SetNetworkAddressOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000001::string::String',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'networkAddress'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_network_address',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetNetworkPublicKeyArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tnetworkPublicKey: RawTransactionArgument<number[]>;\n}\nexport interface SetNetworkPublicKeyOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetNetworkPublicKeyArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tnetworkPublicKey: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/** Sets the public key used for TLS communication for a node. */\nexport function setNetworkPublicKey(options: SetNetworkPublicKeyOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'vector<u8>',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'networkPublicKey'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_network_public_key',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface SetNodeMetadataArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tmetadata: RawTransactionArgument<string>;\n}\nexport interface SetNodeMetadataOptions {\n\tpackage?: string;\n\targuments:\n\t\t| SetNodeMetadataArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tmetadata: RawTransactionArgument<string>,\n\t\t  ];\n}\n/** Sets the metadata of a storage node. */\nexport function setNodeMetadata(options: SetNodeMetadataOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t`${packageAddress}::node_metadata::NodeMetadata`,\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'metadata'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'set_node_metadata',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface VotingEndArguments {\n\tstaking: RawTransactionArgument<string>;\n}\nexport interface VotingEndOptions {\n\tpackage?: string;\n\targuments: VotingEndArguments | [staking: RawTransactionArgument<string>];\n}\n/**\n * Ends the voting period and runs the apportionment if the current time allows.\n *\n * This function is permissionless and can be called by anyone. Emits the\n * `EpochParametersSelected` event.\n */\nexport function votingEnd(options: VotingEndOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock',\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'clock'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'voting_end',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface InitiateEpochChangeArguments {\n\tstaking: RawTransactionArgument<string>;\n\tsystem: RawTransactionArgument<string>;\n}\nexport interface InitiateEpochChangeOptions {\n\tpackage?: string;\n\targuments:\n\t\t| InitiateEpochChangeArguments\n\t\t| [staking: RawTransactionArgument<string>, system: RawTransactionArgument<string>];\n}\n/**\n * Initiates the epoch change if the current time allows.\n *\n * Emits the `EpochChangeStart` event.\n */\nexport function initiateEpochChange(options: InitiateEpochChangeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::system::System`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock',\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'system', 'clock'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'initiate_epoch_change',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface EpochSyncDoneArguments {\n\tstaking: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tepoch: RawTransactionArgument<number>;\n}\nexport interface EpochSyncDoneOptions {\n\tpackage?: string;\n\targuments:\n\t\t| EpochSyncDoneArguments\n\t\t| [\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tepoch: RawTransactionArgument<number>,\n\t\t  ];\n}\n/**\n * Signals to the contract that the node has received all its shards for the new\n * epoch.\n */\nexport function epochSyncDone(options: EpochSyncDoneOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'u32',\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::clock::Clock',\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'cap', 'epoch', 'clock'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'epoch_sync_done',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface StakeWithPoolArguments {\n\tstaking: RawTransactionArgument<string>;\n\ttoStake: RawTransactionArgument<string>;\n\tnodeId: RawTransactionArgument<string>;\n}\nexport interface StakeWithPoolOptions {\n\tpackage?: string;\n\targuments:\n\t\t| StakeWithPoolArguments\n\t\t| [\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\ttoStake: RawTransactionArgument<string>,\n\t\t\t\tnodeId: RawTransactionArgument<string>,\n\t\t  ];\n}\n/** Stake `Coin` with the staking pool. */\nexport function stakeWithPool(options: StakeWithPoolOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${packageAddress}::wal::WAL>`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::object::ID',\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'toStake', 'nodeId'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'stake_with_pool',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RequestWithdrawStakeArguments {\n\tstaking: RawTransactionArgument<string>;\n\tstakedWal: RawTransactionArgument<string>;\n}\nexport interface RequestWithdrawStakeOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RequestWithdrawStakeArguments\n\t\t| [staking: RawTransactionArgument<string>, stakedWal: RawTransactionArgument<string>];\n}\n/**\n * Marks the amount as a withdrawal to be processed and removes it from the stake\n * weight of the node.\n *\n * Allows the user to call `withdraw_stake` after the epoch change to the next\n * epoch and shard transfer is done.\n */\nexport function requestWithdrawStake(options: RequestWithdrawStakeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::staked_wal::StakedWal`,\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'stakedWal'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'request_withdraw_stake',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface WithdrawStakeArguments {\n\tstaking: RawTransactionArgument<string>;\n\tstakedWal: RawTransactionArgument<string>;\n}\nexport interface WithdrawStakeOptions {\n\tpackage?: string;\n\targuments:\n\t\t| WithdrawStakeArguments\n\t\t| [staking: RawTransactionArgument<string>, stakedWal: RawTransactionArgument<string>];\n}\n/** Withdraws the staked amount from the staking pool. */\nexport function withdrawStake(options: WithdrawStakeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::staked_wal::StakedWal`,\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'stakedWal'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'withdraw_stake',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface TryJoinActiveSetArguments {\n\tstaking: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n}\nexport interface TryJoinActiveSetOptions {\n\tpackage?: string;\n\targuments:\n\t\t| TryJoinActiveSetArguments\n\t\t| [staking: RawTransactionArgument<string>, cap: RawTransactionArgument<string>];\n}\n/**\n * Allows a node to join the active set if it has sufficient stake.\n *\n * This can be useful if another node in the active set had its stake reduced below\n * that of the current node. In that case, the current node will be added to the\n * active set either the next time stake is added or by calling this function.\n */\nexport function tryJoinActiveSet(options: TryJoinActiveSetOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'cap'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'try_join_active_set',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface AddCommissionToPoolsArguments {\n\tstaking: RawTransactionArgument<string>;\n\tnodeIds: RawTransactionArgument<string[]>;\n\tcommissions: RawTransactionArgument<string[]>;\n}\nexport interface AddCommissionToPoolsOptions {\n\tpackage?: string;\n\targuments:\n\t\t| AddCommissionToPoolsArguments\n\t\t| [\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tnodeIds: RawTransactionArgument<string[]>,\n\t\t\t\tcommissions: RawTransactionArgument<string[]>,\n\t\t  ];\n}\n/** Adds `commissions[i]` to the commission of pool `node_ids[i]`. */\nexport function addCommissionToPools(options: AddCommissionToPoolsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t'vector<0x0000000000000000000000000000000000000000000000000000000000000002::object::ID>',\n\t\t`vector<0x0000000000000000000000000000000000000000000000000000000000000002::balance::Balance<${packageAddress}::wal::WAL>>`,\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'nodeIds', 'commissions'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'add_commission_to_pools',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface EpochArguments {\n\tstaking: RawTransactionArgument<string>;\n}\nexport interface EpochOptions {\n\tpackage?: string;\n\targuments: EpochArguments | [staking: RawTransactionArgument<string>];\n}\n/** Returns the current epoch of the staking object. */\nexport function epoch(options: EpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::staking::Staking`] satisfies string[];\n\tconst parameterNames = ['staking'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface CalculateRewardsArguments {\n\tstaking: RawTransactionArgument<string>;\n\tnodeId: RawTransactionArgument<string>;\n\tstakedPrincipal: RawTransactionArgument<number | bigint>;\n\tactivationEpoch: RawTransactionArgument<number>;\n\twithdrawEpoch: RawTransactionArgument<number>;\n}\nexport interface CalculateRewardsOptions {\n\tpackage?: string;\n\targuments:\n\t\t| CalculateRewardsArguments\n\t\t| [\n\t\t\t\tstaking: RawTransactionArgument<string>,\n\t\t\t\tnodeId: RawTransactionArgument<string>,\n\t\t\t\tstakedPrincipal: RawTransactionArgument<number | bigint>,\n\t\t\t\tactivationEpoch: RawTransactionArgument<number>,\n\t\t\t\twithdrawEpoch: RawTransactionArgument<number>,\n\t\t  ];\n}\n/**\n * Calculates the rewards for an amount with value `staked_principal`, staked in\n * the pool with the given `node_id` between `activation_epoch` and\n * `withdraw_epoch`.\n *\n * This function can be used with `dev_inspect` to calculate the expected rewards\n * for a `StakedWal` object or, more generally, the returns provided by a given\n * node over a given period.\n */\nexport function calculateRewards(options: CalculateRewardsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t'0x0000000000000000000000000000000000000000000000000000000000000002::object::ID',\n\t\t'u64',\n\t\t'u32',\n\t\t'u32',\n\t] satisfies string[];\n\tconst parameterNames = [\n\t\t'staking',\n\t\t'nodeId',\n\t\t'stakedPrincipal',\n\t\t'activationEpoch',\n\t\t'withdrawEpoch',\n\t];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'calculate_rewards',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface CanWithdrawStakedWalEarlyArguments {\n\tstaking: RawTransactionArgument<string>;\n\tstakedWal: RawTransactionArgument<string>;\n}\nexport interface CanWithdrawStakedWalEarlyOptions {\n\tpackage?: string;\n\targuments:\n\t\t| CanWithdrawStakedWalEarlyArguments\n\t\t| [staking: RawTransactionArgument<string>, stakedWal: RawTransactionArgument<string>];\n}\n/**\n * Call `staked_wal::can_withdraw_early` to allow calling this method in\n * applications.\n */\nexport function canWithdrawStakedWalEarly(options: CanWithdrawStakedWalEarlyOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::staking::Staking`,\n\t\t`${packageAddress}::staked_wal::StakedWal`,\n\t] satisfies string[];\n\tconst parameterNames = ['staking', 'stakedWal'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'staking',\n\t\t\tfunction: 'can_withdraw_staked_wal_early',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveStruct, MoveEnum } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport * as group_ops from './deps/sui/group_ops.js';\nconst $moduleName = '@local-pkg/walrus::bls_aggregate';\nexport const BlsCommitteeMember = new MoveStruct({\n\tname: `${$moduleName}::BlsCommitteeMember`,\n\tfields: {\n\t\tpublic_key: group_ops.Element,\n\t\tweight: bcs.u16(),\n\t\tnode_id: bcs.Address,\n\t},\n});\nexport const BlsCommittee = new MoveStruct({\n\tname: `${$moduleName}::BlsCommittee`,\n\tfields: {\n\t\t/** A vector of committee members */\n\t\tmembers: bcs.vector(BlsCommitteeMember),\n\t\t/** The total number of shards held by the committee */\n\t\tn_shards: bcs.u16(),\n\t\t/** The epoch in which the committee is active. */\n\t\tepoch: bcs.u32(),\n\t\t/** The aggregation of public keys for all members of the committee */\n\t\ttotal_aggregated_key: group_ops.Element,\n\t},\n});\n/** The type of weight verification to perform. */\nexport const RequiredWeight = new MoveEnum({\n\tname: `${$moduleName}::RequiredWeight`,\n\tfields: {\n\t\t/** Verify that the signers form a quorum. */\n\t\tQuorum: null,\n\t\t/** Verify that the signers include at least one correct node. */\n\t\tOneCorrectNode: null,\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveStruct, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as balance from './deps/sui/balance.js';\nconst $moduleName = '@local-pkg/walrus::storage_accounting';\nexport const FutureAccounting = new MoveStruct({\n\tname: `${$moduleName}::FutureAccounting`,\n\tfields: {\n\t\tepoch: bcs.u32(),\n\t\t/**\n\t\t * This field stores `used_capacity` for the epoch. Currently, impossible to rename\n\t\t * due to package upgrade limitations.\n\t\t */\n\t\tused_capacity: bcs.u64(),\n\t\trewards_to_distribute: balance.Balance,\n\t},\n});\nexport const FutureAccountingRingBuffer = new MoveStruct({\n\tname: `${$moduleName}::FutureAccountingRingBuffer`,\n\tfields: {\n\t\tcurrent_index: bcs.u32(),\n\t\tlength: bcs.u32(),\n\t\tring_buffer: bcs.vector(FutureAccounting),\n\t},\n});\nexport interface MaxEpochsAheadArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface MaxEpochsAheadOptions {\n\tpackage?: string;\n\targuments: MaxEpochsAheadArguments | [self: RawTransactionArgument<string>];\n}\n/** The maximum number of epochs for which we can use `self`. */\nexport function maxEpochsAhead(options: MaxEpochsAheadOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::storage_accounting::FutureAccountingRingBuffer`,\n\t] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_accounting',\n\t\t\tfunction: 'max_epochs_ahead',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RingLookupArguments {\n\tself: RawTransactionArgument<string>;\n\tepochsInFuture: RawTransactionArgument<number>;\n}\nexport interface RingLookupOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RingLookupArguments\n\t\t| [self: RawTransactionArgument<string>, epochsInFuture: RawTransactionArgument<number>];\n}\n/** Read-only lookup for an element in the `FutureAccountingRingBuffer` */\nexport function ringLookup(options: RingLookupOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::storage_accounting::FutureAccountingRingBuffer`,\n\t\t'u32',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'epochsInFuture'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_accounting',\n\t\t\tfunction: 'ring_lookup',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface EpochArguments {\n\taccounting: RawTransactionArgument<string>;\n}\nexport interface EpochOptions {\n\tpackage?: string;\n\targuments: EpochArguments | [accounting: RawTransactionArgument<string>];\n}\n/** Accessor for epoch, read-only. */\nexport function epoch(options: EpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::storage_accounting::FutureAccounting`,\n\t] satisfies string[];\n\tconst parameterNames = ['accounting'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_accounting',\n\t\t\tfunction: 'epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface UsedCapacityArguments {\n\taccounting: RawTransactionArgument<string>;\n}\nexport interface UsedCapacityOptions {\n\tpackage?: string;\n\targuments: UsedCapacityArguments | [accounting: RawTransactionArgument<string>];\n}\n/** Accessor for used_capacity, read-only. */\nexport function usedCapacity(options: UsedCapacityOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::storage_accounting::FutureAccounting`,\n\t] satisfies string[];\n\tconst parameterNames = ['accounting'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_accounting',\n\t\t\tfunction: 'used_capacity',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RewardsArguments {\n\taccounting: RawTransactionArgument<string>;\n}\nexport interface RewardsOptions {\n\tpackage?: string;\n\targuments: RewardsArguments | [accounting: RawTransactionArgument<string>];\n}\n/** Accessor for rewards, read-only. */\nexport function rewards(options: RewardsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::storage_accounting::FutureAccounting`,\n\t] satisfies string[];\n\tconst parameterNames = ['accounting'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'storage_accounting',\n\t\t\tfunction: 'rewards',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { MoveStruct } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport * as bls_aggregate from './bls_aggregate.js';\nimport * as storage_accounting from './storage_accounting.js';\nimport * as event_blob from './event_blob.js';\nimport * as extended_field from './extended_field.js';\nconst $moduleName = '@local-pkg/walrus::system_state_inner';\nexport const SystemStateInnerV1 = new MoveStruct({\n\tname: `${$moduleName}::SystemStateInnerV1`,\n\tfields: {\n\t\t/** The current committee, with the current epoch. */\n\t\tcommittee: bls_aggregate.BlsCommittee,\n\t\t/**\n\t\t * Maximum capacity size for the current and future epochs. Changed by voting on\n\t\t * the epoch parameters.\n\t\t */\n\t\ttotal_capacity_size: bcs.u64(),\n\t\t/** Contains the used capacity size for the current epoch. */\n\t\tused_capacity_size: bcs.u64(),\n\t\t/** The price per unit size of storage. */\n\t\tstorage_price_per_unit_size: bcs.u64(),\n\t\t/** The write price per unit size. */\n\t\twrite_price_per_unit_size: bcs.u64(),\n\t\t/** Accounting ring buffer for future epochs. */\n\t\tfuture_accounting: storage_accounting.FutureAccountingRingBuffer,\n\t\t/** Event blob certification state */\n\t\tevent_blob_certification_state: event_blob.EventBlobCertificationState,\n\t\t/**\n\t\t * Sizes of deny lists for storage nodes. Only current committee members can\n\t\t * register their updates in this map. Hence, we don't expect it to bloat.\n\t\t *\n\t\t * Max number of stored entries is ~6500. If there's any concern about the\n\t\t * performance of the map, it can be cleaned up as a side effect of the updates /\n\t\t * registrations.\n\t\t */\n\t\tdeny_list_sizes: extended_field.ExtendedField,\n\t},\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/** Module: system */\n\nimport { MoveStruct, normalizeMoveArguments } from '../utils/index.js';\nimport type { RawTransactionArgument } from '../utils/index.js';\nimport { bcs } from '@mysten/sui/bcs';\nimport type { Transaction } from '@mysten/sui/transactions';\nimport * as object from './deps/sui/object.js';\nconst $moduleName = '@local-pkg/walrus::system';\nexport const System = new MoveStruct({\n\tname: `${$moduleName}::System`,\n\tfields: {\n\t\tid: object.UID,\n\t\tversion: bcs.u64(),\n\t\tpackage_id: bcs.Address,\n\t\tnew_package_id: bcs.option(bcs.Address),\n\t},\n});\nexport interface InvalidateBlobIdArguments {\n\tsystem: RawTransactionArgument<string>;\n\tsignature: RawTransactionArgument<number[]>;\n\tmembersBitmap: RawTransactionArgument<number[]>;\n\tmessage: RawTransactionArgument<number[]>;\n}\nexport interface InvalidateBlobIdOptions {\n\tpackage?: string;\n\targuments:\n\t\t| InvalidateBlobIdArguments\n\t\t| [\n\t\t\t\tsystem: RawTransactionArgument<string>,\n\t\t\t\tsignature: RawTransactionArgument<number[]>,\n\t\t\t\tmembersBitmap: RawTransactionArgument<number[]>,\n\t\t\t\tmessage: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/**\n * === Public Functions === Marks blob as invalid given an invalid blob\n * certificate.\n */\nexport function invalidateBlobId(options: InvalidateBlobIdOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t] satisfies string[];\n\tconst parameterNames = ['system', 'signature', 'membersBitmap', 'message'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'invalidate_blob_id',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface CertifyEventBlobArguments {\n\tsystem: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tblobId: RawTransactionArgument<number | bigint>;\n\trootHash: RawTransactionArgument<number | bigint>;\n\tsize: RawTransactionArgument<number | bigint>;\n\tencodingType: RawTransactionArgument<number>;\n\tendingCheckpointSequenceNum: RawTransactionArgument<number | bigint>;\n\tepoch: RawTransactionArgument<number>;\n}\nexport interface CertifyEventBlobOptions {\n\tpackage?: string;\n\targuments:\n\t\t| CertifyEventBlobArguments\n\t\t| [\n\t\t\t\tsystem: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tblobId: RawTransactionArgument<number | bigint>,\n\t\t\t\trootHash: RawTransactionArgument<number | bigint>,\n\t\t\t\tsize: RawTransactionArgument<number | bigint>,\n\t\t\t\tencodingType: RawTransactionArgument<number>,\n\t\t\t\tendingCheckpointSequenceNum: RawTransactionArgument<number | bigint>,\n\t\t\t\tepoch: RawTransactionArgument<number>,\n\t\t  ];\n}\n/** Certifies a blob containing Walrus events. */\nexport function certifyEventBlob(options: CertifyEventBlobOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'u256',\n\t\t'u256',\n\t\t'u64',\n\t\t'u8',\n\t\t'u64',\n\t\t'u32',\n\t] satisfies string[];\n\tconst parameterNames = [\n\t\t'system',\n\t\t'cap',\n\t\t'blobId',\n\t\t'rootHash',\n\t\t'size',\n\t\t'encodingType',\n\t\t'endingCheckpointSequenceNum',\n\t\t'epoch',\n\t];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'certify_event_blob',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ReserveSpaceArguments {\n\tself: RawTransactionArgument<string>;\n\tstorageAmount: RawTransactionArgument<number | bigint>;\n\tepochsAhead: RawTransactionArgument<number>;\n\tpayment: RawTransactionArgument<string>;\n}\nexport interface ReserveSpaceOptions {\n\tpackage?: string;\n\targuments:\n\t\t| ReserveSpaceArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tstorageAmount: RawTransactionArgument<number | bigint>,\n\t\t\t\tepochsAhead: RawTransactionArgument<number>,\n\t\t\t\tpayment: RawTransactionArgument<string>,\n\t\t  ];\n}\n/** Allows buying a storage reservation for a given period of epochs. */\nexport function reserveSpace(options: ReserveSpaceOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t'u64',\n\t\t'u32',\n\t\t`0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${packageAddress}::wal::WAL>`,\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'storageAmount', 'epochsAhead', 'payment'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'reserve_space',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ReserveSpaceForEpochsArguments {\n\tself: RawTransactionArgument<string>;\n\tstorageAmount: RawTransactionArgument<number | bigint>;\n\tstartEpoch: RawTransactionArgument<number>;\n\tendEpoch: RawTransactionArgument<number>;\n\tpayment: RawTransactionArgument<string>;\n}\nexport interface ReserveSpaceForEpochsOptions {\n\tpackage?: string;\n\targuments:\n\t\t| ReserveSpaceForEpochsArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tstorageAmount: RawTransactionArgument<number | bigint>,\n\t\t\t\tstartEpoch: RawTransactionArgument<number>,\n\t\t\t\tendEpoch: RawTransactionArgument<number>,\n\t\t\t\tpayment: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Allows buying a storage reservation for a given period of epochs.\n *\n * Returns a storage resource for the period between `start_epoch` (inclusive) and\n * `end_epoch` (exclusive). If `start_epoch` has already passed, reserves space\n * starting from the current epoch.\n */\nexport function reserveSpaceForEpochs(options: ReserveSpaceForEpochsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t'u64',\n\t\t'u32',\n\t\t'u32',\n\t\t`0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${packageAddress}::wal::WAL>`,\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'storageAmount', 'startEpoch', 'endEpoch', 'payment'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'reserve_space_for_epochs',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RegisterBlobArguments {\n\tself: RawTransactionArgument<string>;\n\tstorage: RawTransactionArgument<string>;\n\tblobId: RawTransactionArgument<number | bigint>;\n\trootHash: RawTransactionArgument<number | bigint>;\n\tsize: RawTransactionArgument<number | bigint>;\n\tencodingType: RawTransactionArgument<number>;\n\tdeletable: RawTransactionArgument<boolean>;\n\twritePayment: RawTransactionArgument<string>;\n}\nexport interface RegisterBlobOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RegisterBlobArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tstorage: RawTransactionArgument<string>,\n\t\t\t\tblobId: RawTransactionArgument<number | bigint>,\n\t\t\t\trootHash: RawTransactionArgument<number | bigint>,\n\t\t\t\tsize: RawTransactionArgument<number | bigint>,\n\t\t\t\tencodingType: RawTransactionArgument<number>,\n\t\t\t\tdeletable: RawTransactionArgument<boolean>,\n\t\t\t\twritePayment: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Registers a new blob in the system. `size` is the size of the unencoded blob.\n * The reserved space in `storage` must be at least the size of the encoded blob.\n */\nexport function registerBlob(options: RegisterBlobOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`${packageAddress}::storage_resource::Storage`,\n\t\t'u256',\n\t\t'u256',\n\t\t'u64',\n\t\t'u8',\n\t\t'bool',\n\t\t`0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${packageAddress}::wal::WAL>`,\n\t] satisfies string[];\n\tconst parameterNames = [\n\t\t'self',\n\t\t'storage',\n\t\t'blobId',\n\t\t'rootHash',\n\t\t'size',\n\t\t'encodingType',\n\t\t'deletable',\n\t\t'writePayment',\n\t];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'register_blob',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface CertifyBlobArguments {\n\tself: RawTransactionArgument<string>;\n\tblob: RawTransactionArgument<string>;\n\tsignature: RawTransactionArgument<number[]>;\n\tsignersBitmap: RawTransactionArgument<number[]>;\n\tmessage: RawTransactionArgument<number[]>;\n}\nexport interface CertifyBlobOptions {\n\tpackage?: string;\n\targuments:\n\t\t| CertifyBlobArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tblob: RawTransactionArgument<string>,\n\t\t\t\tsignature: RawTransactionArgument<number[]>,\n\t\t\t\tsignersBitmap: RawTransactionArgument<number[]>,\n\t\t\t\tmessage: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/**\n * Certify that a blob will be available in the storage system until the end epoch\n * of the storage associated with it.\n */\nexport function certifyBlob(options: CertifyBlobOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`${packageAddress}::blob::Blob`,\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'blob', 'signature', 'signersBitmap', 'message'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'certify_blob',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface DeleteBlobArguments {\n\tself: RawTransactionArgument<string>;\n\tblob: RawTransactionArgument<string>;\n}\nexport interface DeleteBlobOptions {\n\tpackage?: string;\n\targuments:\n\t\t| DeleteBlobArguments\n\t\t| [self: RawTransactionArgument<string>, blob: RawTransactionArgument<string>];\n}\n/** Deletes a deletable blob and returns the contained storage resource. */\nexport function deleteBlob(options: DeleteBlobOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`${packageAddress}::blob::Blob`,\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'blob'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'delete_blob',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ExtendBlobWithResourceArguments {\n\tself: RawTransactionArgument<string>;\n\tblob: RawTransactionArgument<string>;\n\textension: RawTransactionArgument<string>;\n}\nexport interface ExtendBlobWithResourceOptions {\n\tpackage?: string;\n\targuments:\n\t\t| ExtendBlobWithResourceArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tblob: RawTransactionArgument<string>,\n\t\t\t\textension: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Extend the period of validity of a blob with a new storage resource. The new\n * storage resource must be the same size as the storage resource used in the blob,\n * and have a longer period of validity.\n */\nexport function extendBlobWithResource(options: ExtendBlobWithResourceOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`${packageAddress}::blob::Blob`,\n\t\t`${packageAddress}::storage_resource::Storage`,\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'blob', 'extension'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'extend_blob_with_resource',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface ExtendBlobArguments {\n\tself: RawTransactionArgument<string>;\n\tblob: RawTransactionArgument<string>;\n\textendedEpochs: RawTransactionArgument<number>;\n\tpayment: RawTransactionArgument<string>;\n}\nexport interface ExtendBlobOptions {\n\tpackage?: string;\n\targuments:\n\t\t| ExtendBlobArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tblob: RawTransactionArgument<string>,\n\t\t\t\textendedEpochs: RawTransactionArgument<number>,\n\t\t\t\tpayment: RawTransactionArgument<string>,\n\t\t  ];\n}\n/**\n * Extend the period of validity of a blob by extending its contained storage\n * resource by `extended_epochs` epochs.\n */\nexport function extendBlob(options: ExtendBlobOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`${packageAddress}::blob::Blob`,\n\t\t'u32',\n\t\t`0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${packageAddress}::wal::WAL>`,\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'blob', 'extendedEpochs', 'payment'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'extend_blob',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface AddSubsidyArguments {\n\tsystem: RawTransactionArgument<string>;\n\tsubsidy: RawTransactionArgument<string>;\n\tepochsAhead: RawTransactionArgument<number>;\n}\nexport interface AddSubsidyOptions {\n\tpackage?: string;\n\targuments:\n\t\t| AddSubsidyArguments\n\t\t| [\n\t\t\t\tsystem: RawTransactionArgument<string>,\n\t\t\t\tsubsidy: RawTransactionArgument<string>,\n\t\t\t\tepochsAhead: RawTransactionArgument<number>,\n\t\t  ];\n}\n/**\n * Adds rewards to the system for the specified number of epochs ahead. The rewards\n * are split equally across the future accounting ring buffer up to the specified\n * epoch.\n */\nexport function addSubsidy(options: AddSubsidyOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${packageAddress}::wal::WAL>`,\n\t\t'u32',\n\t] satisfies string[];\n\tconst parameterNames = ['system', 'subsidy', 'epochsAhead'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'add_subsidy',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface AddPerEpochSubsidiesArguments {\n\tsystem: RawTransactionArgument<string>;\n\tsubsidies: RawTransactionArgument<string[]>;\n}\nexport interface AddPerEpochSubsidiesOptions {\n\tpackage?: string;\n\targuments:\n\t\t| AddPerEpochSubsidiesArguments\n\t\t| [system: RawTransactionArgument<string>, subsidies: RawTransactionArgument<string[]>];\n}\n/**\n * Adds rewards to the system for future epochs, where `subsidies[i]` is added to\n * the rewards of epoch `system.epoch() + i`.\n */\nexport function addPerEpochSubsidies(options: AddPerEpochSubsidiesOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`vector<0x0000000000000000000000000000000000000000000000000000000000000002::balance::Balance<${packageAddress}::wal::WAL>>`,\n\t] satisfies string[];\n\tconst parameterNames = ['system', 'subsidies'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'add_per_epoch_subsidies',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface UpdateProtocolVersionArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tsignature: RawTransactionArgument<number[]>;\n\tmembersBitmap: RawTransactionArgument<number[]>;\n\tmessage: RawTransactionArgument<number[]>;\n}\nexport interface UpdateProtocolVersionOptions {\n\tpackage?: string;\n\targuments:\n\t\t| UpdateProtocolVersionArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tsignature: RawTransactionArgument<number[]>,\n\t\t\t\tmembersBitmap: RawTransactionArgument<number[]>,\n\t\t\t\tmessage: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/** Node collects signatures on the protocol version event and emits it. */\nexport function updateProtocolVersion(options: UpdateProtocolVersionOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'signature', 'membersBitmap', 'message'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'update_protocol_version',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface RegisterDenyListUpdateArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tdenyListRoot: RawTransactionArgument<number | bigint>;\n\tdenyListSequence: RawTransactionArgument<number | bigint>;\n}\nexport interface RegisterDenyListUpdateOptions {\n\tpackage?: string;\n\targuments:\n\t\t| RegisterDenyListUpdateArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tdenyListRoot: RawTransactionArgument<number | bigint>,\n\t\t\t\tdenyListSequence: RawTransactionArgument<number | bigint>,\n\t\t  ];\n}\n/** Register a deny list update. */\nexport function registerDenyListUpdate(options: RegisterDenyListUpdateOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'u256',\n\t\t'u64',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'denyListRoot', 'denyListSequence'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'register_deny_list_update',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface UpdateDenyListArguments {\n\tself: RawTransactionArgument<string>;\n\tcap: RawTransactionArgument<string>;\n\tsignature: RawTransactionArgument<number[]>;\n\tmembersBitmap: RawTransactionArgument<number[]>;\n\tmessage: RawTransactionArgument<number[]>;\n}\nexport interface UpdateDenyListOptions {\n\tpackage?: string;\n\targuments:\n\t\t| UpdateDenyListArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tcap: RawTransactionArgument<string>,\n\t\t\t\tsignature: RawTransactionArgument<number[]>,\n\t\t\t\tmembersBitmap: RawTransactionArgument<number[]>,\n\t\t\t\tmessage: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/** Perform the update of the deny list. */\nexport function updateDenyList(options: UpdateDenyListOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t`${packageAddress}::storage_node::StorageNodeCap`,\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'cap', 'signature', 'membersBitmap', 'message'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'update_deny_list',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface DeleteDenyListedBlobArguments {\n\tself: RawTransactionArgument<string>;\n\tsignature: RawTransactionArgument<number[]>;\n\tmembersBitmap: RawTransactionArgument<number[]>;\n\tmessage: RawTransactionArgument<number[]>;\n}\nexport interface DeleteDenyListedBlobOptions {\n\tpackage?: string;\n\targuments:\n\t\t| DeleteDenyListedBlobArguments\n\t\t| [\n\t\t\t\tself: RawTransactionArgument<string>,\n\t\t\t\tsignature: RawTransactionArgument<number[]>,\n\t\t\t\tmembersBitmap: RawTransactionArgument<number[]>,\n\t\t\t\tmessage: RawTransactionArgument<number[]>,\n\t\t  ];\n}\n/** Delete a blob that is deny listed by f+1 members. */\nexport function deleteDenyListedBlob(options: DeleteDenyListedBlobOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [\n\t\t`${packageAddress}::system::System`,\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t\t'vector<u8>',\n\t] satisfies string[];\n\tconst parameterNames = ['self', 'signature', 'membersBitmap', 'message'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'delete_deny_listed_blob',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface EpochArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface EpochOptions {\n\tpackage?: string;\n\targuments: EpochArguments | [self: RawTransactionArgument<string>];\n}\n/** Get epoch. Uses the committee to get the epoch. */\nexport function epoch(options: EpochOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::system::System`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'epoch',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface TotalCapacitySizeArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface TotalCapacitySizeOptions {\n\tpackage?: string;\n\targuments: TotalCapacitySizeArguments | [self: RawTransactionArgument<string>];\n}\n/** Accessor for total capacity size. */\nexport function totalCapacitySize(options: TotalCapacitySizeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::system::System`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'total_capacity_size',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface UsedCapacitySizeArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface UsedCapacitySizeOptions {\n\tpackage?: string;\n\targuments: UsedCapacitySizeArguments | [self: RawTransactionArgument<string>];\n}\n/** Accessor for used capacity size. */\nexport function usedCapacitySize(options: UsedCapacitySizeOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::system::System`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'used_capacity_size',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface NShardsArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface NShardsOptions {\n\tpackage?: string;\n\targuments: NShardsArguments | [self: RawTransactionArgument<string>];\n}\n/** Accessor for the number of shards. */\nexport function nShards(options: NShardsOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::system::System`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'n_shards',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface FutureAccountingArguments {\n\tself: RawTransactionArgument<string>;\n}\nexport interface FutureAccountingOptions {\n\tpackage?: string;\n\targuments: FutureAccountingArguments | [self: RawTransactionArgument<string>];\n}\n/** Read-only access to the accounting ring buffer. */\nexport function futureAccounting(options: FutureAccountingOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::system::System`] satisfies string[];\n\tconst parameterNames = ['self'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'future_accounting',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\nexport interface VersionArguments {\n\tsystem: RawTransactionArgument<string>;\n}\nexport interface VersionOptions {\n\tpackage?: string;\n\targuments: VersionArguments | [system: RawTransactionArgument<string>];\n}\nexport function version(options: VersionOptions) {\n\tconst packageAddress = options.package ?? '@local-pkg/walrus';\n\tconst argumentsTypes = [`${packageAddress}::system::System`] satisfies string[];\n\tconst parameterNames = ['system'];\n\treturn (tx: Transaction) =>\n\t\ttx.moveCall({\n\t\t\tpackage: packageAddress,\n\t\t\tmodule: 'system',\n\t\t\tfunction: 'version',\n\t\t\targuments: normalizeMoveArguments(options.arguments, argumentsTypes, parameterNames),\n\t\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport class WalrusClientError extends Error {}\n\nexport class RetryableWalrusClientError extends WalrusClientError {}\n\n/** Thrown when the client could not retrieve the status of a blob from any storage node. */\nexport class NoBlobStatusReceivedError extends WalrusClientError {}\n\n/** Thrown when the client could not retrieve a verified blob status for the blob. */\nexport class NoVerifiedBlobStatusReceivedError extends WalrusClientError {}\n\n/** Thrown when the client could not retrieve blob metadata from any storage node. */\nexport class NoBlobMetadataReceivedError extends RetryableWalrusClientError {}\n\n/** Thrown when the client could not retrieve enough slivers to reconstruct the blob. */\nexport class NotEnoughSliversReceivedError extends RetryableWalrusClientError {}\n\n/** Thrown when the client could not write enough slivers to upload the blob. */\nexport class NotEnoughBlobConfirmationsError extends RetryableWalrusClientError {}\n\n/** Thrown when the client is currently behind the current epoch. */\nexport class BehindCurrentEpochError extends RetryableWalrusClientError {}\n\n/** Thrown when a blob is not certified or determined to not exist. */\nexport class BlobNotCertifiedError extends RetryableWalrusClientError {}\n\n/** Thrown when a blob was determined to be incorrectly encoded. */\nexport class InconsistentBlobError extends WalrusClientError {}\n\n/** Thrown when blob is blocked by a quorum of storage nodes. */\nexport class BlobBlockedError extends Error {}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType } from '@mysten/sui/bcs';\nimport { bcs } from '@mysten/sui/bcs';\n\nconst MerkleNode = bcs.enum('MerkleNode', {\n\tEmpty: null,\n\tDigest: bcs.bytes(32),\n});\n\nconst SliverPairMetadata = bcs.struct('SliverPairMetadata', {\n\tprimary_hash: MerkleNode,\n\tsecondary_hash: MerkleNode,\n});\n\nexport const EncodingType = bcs\n\t.enum('EncodingType', {\n\t\tRedStuff: null,\n\t\tRS2: null,\n\t})\n\t.transform({\n\t\tinput: (\n\t\t\tencodingType:\n\t\t\t\t| { RedStuff: boolean | object | null }\n\t\t\t\t| { RS2: boolean | object | null }\n\t\t\t\t| 'RedStuff'\n\t\t\t\t| 'RS2',\n\t\t) =>\n\t\t\ttypeof encodingType === 'string'\n\t\t\t\t? ({ [encodingType]: null } as Exclude<typeof encodingType, string>)\n\t\t\t\t: encodingType,\n\t\toutput: (encodingType) => encodingType,\n\t});\n\nexport const BlobMetadataV1 = bcs.struct('BlobMetadataV1', {\n\tencoding_type: EncodingType,\n\tunencoded_length: bcs.u64(),\n\thashes: bcs.vector(SliverPairMetadata),\n});\n\nexport const BlobMetadata = bcs.enum('BlobMetadata', {\n\tV1: BlobMetadataV1,\n});\n\nexport const BlobId = bcs.u256().transform({\n\tinput: (blobId: string | bigint) => (typeof blobId === 'string' ? blobIdToInt(blobId) : blobId),\n\toutput: (id: string) => blobIdFromInt(id),\n});\n\nexport function blobIdFromInt(blobId: bigint | string): string {\n\treturn bcs\n\t\t.u256()\n\t\t.serialize(blobId)\n\t\t.toBase64()\n\t\t.replace(/=*$/, '')\n\t\t.replaceAll('+', '-')\n\t\t.replaceAll('/', '_');\n}\n\nexport function blobIdFromBytes(blobId: Uint8Array): string {\n\treturn blobIdFromInt(bcs.u256().parse(blobId));\n}\n\nexport function blobIdToInt(blobId: string): bigint {\n\treturn BigInt(bcs.u256().fromBase64(blobId.replaceAll('-', '+').replaceAll('_', '/')));\n}\n\nexport const BlobMetadataWithId = bcs.struct('BlobMetadataWithId', {\n\tblobId: BlobId,\n\tmetadata: BlobMetadata,\n});\n\nconst Symbols = bcs.struct('Symbols', {\n\tdata: bcs.vector(bcs.u8()),\n\tsymbol_size: bcs.u16(),\n});\n\nexport const SliverData = bcs.struct('SliverData', {\n\tsymbols: Symbols,\n\tindex: bcs.u16(),\n});\n\nexport const Sliver = bcs.enum('Sliver', {\n\tPrimary: SliverData,\n\tSecondary: SliverData,\n});\n\nexport const SliverPair = bcs.struct('SliverPair', {\n\tprimary: SliverData,\n\tsecondary: SliverData,\n});\n\nexport enum IntentType {\n\tPROOF_OF_POSSESSION_MSG = 0,\n\tBLOB_CERT_MSG = 1,\n\tINVALID_BLOB_ID_MSG = 2,\n\tSYNC_SHARD_MSG = 3,\n}\n\nexport const Intent = bcs\n\t.struct('Intent', {\n\t\ttype: bcs.u8().transform({\n\t\t\tinput: (type: IntentType) => type,\n\t\t\toutput: (type: number) => type as IntentType,\n\t\t}),\n\t\tversion: bcs.u8(),\n\t\tappId: bcs.u8(),\n\t})\n\t.transform({\n\t\tinput: (intent: IntentType) => ({\n\t\t\ttype: intent,\n\t\t\tversion: 0,\n\t\t\tappId: 3,\n\t\t}),\n\t\toutput: (intent) => intent.type,\n\t});\n\nexport function ProtocolMessage<T extends BcsType<any>>(messageContents: T) {\n\treturn bcs.struct(`ProtocolMessage<${messageContents.name}>`, {\n\t\tintent: Intent,\n\t\tepoch: bcs.u32(),\n\t\tmessageContents,\n\t});\n}\n\nexport const BlobPersistenceType = bcs.enum('BlobPersistenceType', {\n\tPermanent: null,\n\tDeletable: bcs.struct('Deletable', {\n\t\tobjectId: bcs.Address,\n\t}),\n});\nexport const StorageConfirmationBody = bcs.struct('StorageConfirmationBody', {\n\tblobId: BlobId,\n\tblobType: BlobPersistenceType,\n});\n\nexport const StorageConfirmation = ProtocolMessage(StorageConfirmationBody);\n\nexport function Field<T0 extends BcsType<any>, T1 extends BcsType<any>>(\n\t...typeParameters: [T0, T1]\n) {\n\treturn bcs.struct('Field', {\n\t\tid: bcs.Address,\n\t\tname: typeParameters[0],\n\t\tvalue: typeParameters[1],\n\t});\n}\n\nexport const QuiltPatchTags = bcs.map(bcs.string(), bcs.string()).transform({\n\t// tags is a BTreeMap, so we need to sort entries before serializing\n\tinput: (tags: Record<string, string> | Map<string, string>) =>\n\t\tnew Map(\n\t\t\t[...(tags instanceof Map ? tags : Object.entries(tags))].sort(([a], [b]) =>\n\t\t\t\t// TODO: sorting for map keys should be moved into @mysten/bcs\n\t\t\t\tcompareBcsBytes(bcs.string().serialize(a).toBytes(), bcs.string().serialize(b).toBytes()),\n\t\t\t),\n\t\t),\n\toutput: (tags: Map<string, string>) => Object.fromEntries(tags),\n});\n\nexport const QuiltPatchV1 = bcs.struct('QuiltPatchV1', {\n\tendIndex: bcs.u16(),\n\tidentifier: bcs.string(),\n\ttags: QuiltPatchTags,\n});\n\nfunction compareBcsBytes(a: Uint8Array, b: Uint8Array) {\n\t// sort by length first, because bcs bytes prefix length\n\tif (a.length !== b.length) {\n\t\treturn a.length - b.length;\n\t}\n\n\tfor (let i = 0; i < a.length; i++) {\n\t\tif (a[i] !== b[i]) {\n\t\t\treturn a[i] - b[i];\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nexport const QuiltIndexV1 = bcs.struct('QuiltIndexV1', {\n\tpatches: bcs.vector(QuiltPatchV1),\n});\n\nexport const QuiltPatchId = bcs.struct('QuiltPatchId', {\n\tquiltId: BlobId,\n\tpatchId: bcs.struct('InternalQuiltPatchId', {\n\t\tversion: bcs.u8(),\n\t\tstartIndex: bcs.u16(),\n\t\tendIndex: bcs.u16(),\n\t}),\n});\n\nexport const QuiltPatchBlobHeader = bcs.struct('QuiltPatchBlobHeader', {\n\tversion: bcs.u8(),\n\tlength: bcs.u32(),\n\tmask: bcs.u8(),\n});\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport class StorageNodeError extends Error {}\n\nexport class StorageNodeAPIError<\n\tTStatus extends number | undefined = number | undefined,\n\tTError extends object | undefined = object | undefined,\n> extends StorageNodeError {\n\t/** HTTP status for the response that caused the error. */\n\treadonly status: TStatus;\n\n\t/** JSON body of the response that caused the error. */\n\treadonly error: TError;\n\n\tconstructor(status: TStatus, error: TError, message: string | undefined) {\n\t\tsuper(StorageNodeAPIError.#makeMessage(status, error, message));\n\t\tthis.status = status;\n\t\tthis.error = error;\n\t}\n\n\tstatic #makeMessage(status: number | undefined, error: unknown, message: string | undefined) {\n\t\tfunction hasErrorMessage(error: any): error is { error: { message: string } } {\n\t\t\treturn typeof error?.error?.message === 'string';\n\t\t}\n\n\t\tconst inferredMessage = hasErrorMessage(error) ? error.error.message : message;\n\t\tconst finalMessage = inferredMessage ? inferredMessage : JSON.stringify(error);\n\n\t\tif (status && finalMessage) {\n\t\t\treturn `${status} ${finalMessage}`;\n\t\t} else if (finalMessage) {\n\t\t\treturn finalMessage;\n\t\t} else if (status) {\n\t\t\treturn `${status} status code (no body)`;\n\t\t}\n\t\treturn '(no status code or body)';\n\t}\n\n\tstatic generate(\n\t\tstatus: number | undefined,\n\t\terrorResponse: object | undefined,\n\t\tmessage: string | undefined,\n\t): StorageNodeAPIError {\n\t\tif (!status) {\n\t\t\treturn new ConnectionError({ message });\n\t\t}\n\n\t\tif (status === 400) {\n\t\t\treturn BadRequestError.generate(status, errorResponse, message);\n\t\t}\n\n\t\tif (status === 401) {\n\t\t\treturn new AuthenticationError(status, errorResponse, message);\n\t\t}\n\n\t\tif (status === 403) {\n\t\t\treturn new PermissionDeniedError(status, errorResponse, message);\n\t\t}\n\n\t\tif (status === 404) {\n\t\t\treturn new NotFoundError(status, errorResponse, message);\n\t\t}\n\n\t\tif (status === 409) {\n\t\t\treturn new ConflictError(status, errorResponse, message);\n\t\t}\n\n\t\tif (status === 422) {\n\t\t\treturn new UnprocessableEntityError(status, errorResponse, message);\n\t\t}\n\n\t\tif (status === 429) {\n\t\t\treturn new RateLimitError(status, errorResponse, message);\n\t\t}\n\n\t\tif (status === 451) {\n\t\t\treturn new LegallyUnavailableError(status, errorResponse, message);\n\t\t}\n\n\t\tif (status >= 500) {\n\t\t\treturn new InternalServerError(status, errorResponse, message);\n\t\t}\n\n\t\treturn new StorageNodeAPIError(status, errorResponse, message);\n\t}\n}\n\nexport class UserAbortError extends StorageNodeAPIError<undefined, undefined> {\n\tconstructor({ message }: { message?: string } = {}) {\n\t\tsuper(undefined, undefined, message || 'Request was aborted.');\n\t}\n}\n\nexport class ConnectionError extends StorageNodeAPIError<undefined, undefined> {\n\tconstructor({ message }: { message?: string | undefined }) {\n\t\tsuper(undefined, undefined, message || 'Connection error.');\n\t}\n}\n\nexport class ConnectionTimeoutError extends StorageNodeAPIError<undefined, undefined> {\n\tconstructor({ message }: { message?: string } = {}) {\n\t\tsuper(undefined, undefined, message ?? 'Request timed out.');\n\t}\n}\n\nexport class BadRequestError extends StorageNodeAPIError<400> {\n\tstatic generate(\n\t\tstatus: 400,\n\t\terrorResponse: object | undefined,\n\t\tmessage: string | undefined,\n\t): StorageNodeAPIError {\n\t\tif (errorResponse && typeof errorResponse === 'object' && 'error' in errorResponse) {\n\t\t\tconst error = errorResponse.error as {\n\t\t\t\tdetails?: [\n\t\t\t\t\t{\n\t\t\t\t\t\treason?: string;\n\t\t\t\t\t},\n\t\t\t\t];\n\t\t\t};\n\t\t\tif (error.details?.[0]?.reason === 'NOT_REGISTERED') {\n\t\t\t\treturn new BlobNotRegisteredError(errorResponse, message);\n\t\t\t}\n\t\t}\n\n\t\treturn new BadRequestError(status, errorResponse, message);\n\t}\n}\n\nexport class BlobNotRegisteredError extends StorageNodeAPIError<400> {\n\tconstructor(error: object | undefined, message: string | undefined) {\n\t\tsuper(400, error, message);\n\t}\n}\n\nexport class AuthenticationError extends StorageNodeAPIError<401> {}\n\nexport class PermissionDeniedError extends StorageNodeAPIError<403> {}\n\nexport class NotFoundError extends StorageNodeAPIError<404> {}\n\nexport class ConflictError extends StorageNodeAPIError<409> {}\n\nexport class UnprocessableEntityError extends StorageNodeAPIError<422> {}\n\nexport class RateLimitError extends StorageNodeAPIError<429> {}\n\nexport class LegallyUnavailableError extends StorageNodeAPIError<451> {}\n\nexport class InternalServerError extends StorageNodeAPIError<number> {}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport type HeadersLike = Record<string, string | string[] | undefined> | RequestInit['headers'];\n\nexport function mergeHeaders(...headers: (HeadersLike | undefined)[]): Headers {\n\tconst mergedHeaders = new Headers();\n\n\tfor (const header of headers) {\n\t\tif (!header || typeof header !== 'object') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (const [key, value] of Object.entries(header)) {\n\t\t\tif (value === null) {\n\t\t\t\tmergedHeaders.delete(key);\n\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\tfor (const v of value) {\n\t\t\t\t\tmergedHeaders.append(key, v as string);\n\t\t\t\t}\n\t\t\t} else if (value !== undefined) {\n\t\t\t\tmergedHeaders.set(key, value);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn mergedHeaders;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { BlobMetadata, BlobMetadataWithId, SliverData } from '../utils/bcs.js';\nimport {\n\tConnectionTimeoutError,\n\tStorageNodeAPIError,\n\tStorageNodeError,\n\tUserAbortError,\n} from './error.js';\nimport type {\n\tGetBlobMetadataRequestInput,\n\tGetBlobMetadataResponse,\n\tGetBlobStatusRequestInput,\n\tGetBlobStatusResponse,\n\tGetDeletableBlobConfirmationRequestInput,\n\tGetDeletableBlobConfirmationResponse,\n\tGetPermanentBlobConfirmationRequestInput,\n\tGetPermanentBlobConfirmationResponse,\n\tGetSliverRequestInput,\n\tGetSliverResponse,\n\tRawGetBlobStatusResponse,\n\tStoreBlobMetadataRequestInput,\n\tStoreBlobMetadataResponse,\n\tStoreSliverRequestInput,\n\tStoreSliverResponse,\n} from './types.js';\nimport { mergeHeaders } from './utils.js';\n\nexport type Fetch = (url: RequestInfo, init?: RequestInit) => Promise<Response>;\n\nexport type StorageNodeClientOptions = {\n\t/**\n\t * An optional custom fetch function.\n\t *\n\t * If not provided, defaults to the global `fetch` function (`globalThis.fetch`).\n\t *\n\t * @default globalThis.fetch\n\t */\n\tfetch?: Fetch;\n\n\t/**\n\t * An optional timeout for requests.\n\t * @default 30_000ms (30 seconds)\n\t */\n\ttimeout?: number;\n\n\t/**\n\t * Callback for individual network errors.\n\t */\n\tonError?: (error: Error) => void;\n};\n\nexport type RequestOptions = {\n\tnodeUrl: string;\n\ttimeout?: number;\n\theaders?: ReturnType<typeof mergeHeaders>;\n} & Omit<RequestInit, 'headers'>;\n\nexport class StorageNodeClient {\n\t#fetch: Fetch;\n\t#timeout: number;\n\t#onError?: (error: Error) => void;\n\tconstructor({ fetch: overriddenFetch, timeout, onError }: StorageNodeClientOptions = {}) {\n\t\tthis.#fetch = overriddenFetch ?? globalThis.fetch;\n\t\tthis.#timeout = timeout ?? 30_000;\n\t\tthis.#onError = onError;\n\t}\n\n\t/**\n\t * Gets the metadata associated with a Walrus blob.\n\t */\n\tasync getBlobMetadata(\n\t\t{ blobId }: GetBlobMetadataRequestInput,\n\t\toptions: RequestOptions,\n\t): Promise<GetBlobMetadataResponse> {\n\t\tconst response = await this.#request(`/v1/blobs/${blobId}/metadata`, {\n\t\t\t...options,\n\t\t\theaders: mergeHeaders({ Accept: 'application/octet-stream' }, options.headers),\n\t\t});\n\n\t\tconst bcsBytes = await response.arrayBuffer();\n\t\treturn BlobMetadataWithId.parse(new Uint8Array(bcsBytes));\n\t}\n\n\t/**\n\t * Gets the status associated with a Walrus blob.\n\t */\n\tasync getBlobStatus(\n\t\t{ blobId }: GetBlobStatusRequestInput,\n\t\toptions: RequestOptions,\n\t): Promise<GetBlobStatusResponse> {\n\t\tconst response = await this.#request(`/v1/blobs/${blobId}/status`, options);\n\n\t\tconst json: RawGetBlobStatusResponse = await response.json();\n\t\tconst blobStatus = json.success.data;\n\n\t\tif (blobStatus === 'nonexistent') {\n\t\t\treturn { type: 'nonexistent' };\n\t\t}\n\n\t\tif ('invalid' in blobStatus) {\n\t\t\treturn {\n\t\t\t\ttype: 'invalid',\n\t\t\t\t...blobStatus.invalid,\n\t\t\t};\n\t\t}\n\n\t\tif ('permanent' in blobStatus) {\n\t\t\treturn {\n\t\t\t\ttype: 'permanent',\n\t\t\t\t...blobStatus.permanent,\n\t\t\t};\n\t\t}\n\n\t\tif ('deletable' in blobStatus) {\n\t\t\treturn {\n\t\t\t\ttype: 'deletable',\n\t\t\t\t...blobStatus.deletable,\n\t\t\t};\n\t\t}\n\n\t\tthrow new StorageNodeError(`Unknown blob status received: ${blobStatus}`);\n\t}\n\n\t/**\n\t * Stores the metadata associated with a registered Walrus blob at this storage\n\t * node. This is a pre-requisite for storing the encoded slivers of the blob. The\n\t * ID of the blob must first be registered on Sui, after which storing the metadata\n\t * becomes possible.\n\t *\n\t * This endpoint may return an error if the node has not yet received the\n\t * registration event from the chain.\n\t */\n\tasync storeBlobMetadata(\n\t\t{ blobId, metadata }: StoreBlobMetadataRequestInput,\n\t\toptions: RequestOptions,\n\t): Promise<StoreBlobMetadataResponse> {\n\t\tconst isBcsInput = typeof metadata === 'object' && 'V1' in metadata;\n\t\tconst body = isBcsInput ? BlobMetadata.serialize(metadata).toBytes() : metadata;\n\n\t\tconst response = await this.#request(`/v1/blobs/${blobId}/metadata`, {\n\t\t\t...options,\n\t\t\tmethod: 'PUT',\n\t\t\tbody,\n\t\t\theaders: mergeHeaders({ 'Content-Type': 'application/octet-stream' }, options.headers),\n\t\t});\n\n\t\tconst json: StoreBlobMetadataResponse = await response.json();\n\t\treturn json;\n\t}\n\n\t/**\n\t * Gets the primary or secondary sliver identified by the specified blob ID and\n\t * index. The index should represent a sliver that is assigned to be stored at one\n\t * of the shards managed by this storage node during this epoch.\n\t */\n\tasync getSliver(\n\t\t{ blobId, sliverPairIndex, sliverType }: GetSliverRequestInput,\n\t\toptions: RequestOptions,\n\t): Promise<GetSliverResponse> {\n\t\tconst response = await this.#request(\n\t\t\t`/v1/blobs/${blobId}/slivers/${sliverPairIndex}/${sliverType}`,\n\t\t\t{\n\t\t\t\t...options,\n\t\t\t\theaders: mergeHeaders({ Accept: 'application/octet-stream' }, options.headers),\n\t\t\t},\n\t\t);\n\n\t\tconst bcsBytes = await response.arrayBuffer();\n\t\treturn SliverData.parse(new Uint8Array(bcsBytes));\n\t}\n\n\t/**\n\t * Stores a primary or secondary blob sliver at the storage node.\n\t */\n\tasync storeSliver(\n\t\t{ blobId, sliverPairIndex, sliverType, sliver }: StoreSliverRequestInput,\n\t\toptions: RequestOptions,\n\t): Promise<StoreSliverResponse> {\n\t\tconst isBcsInput = typeof sliver === 'object' && 'symbols' in sliver;\n\t\tconst body = isBcsInput ? SliverData.serialize(sliver).toBytes() : sliver;\n\n\t\tconst response = await this.#request(\n\t\t\t`/v1/blobs/${blobId}/slivers/${sliverPairIndex}/${sliverType}`,\n\t\t\t{\n\t\t\t\t...options,\n\t\t\t\tmethod: 'PUT',\n\t\t\t\tbody,\n\t\t\t\theaders: mergeHeaders({ 'Content-Type': 'application/octet-stream' }, options.headers),\n\t\t\t},\n\t\t);\n\n\t\tconst json: StoreSliverResponse = await response.json();\n\t\treturn json;\n\t}\n\n\t/**\n\t * Gets a signed storage confirmation from this storage node, indicating that all shards\n\t * assigned to this storage node for the current epoch have stored their respective slivers.\n\t */\n\tasync getDeletableBlobConfirmation(\n\t\t{ blobId, objectId }: GetDeletableBlobConfirmationRequestInput,\n\t\toptions: RequestOptions,\n\t): Promise<GetDeletableBlobConfirmationResponse> {\n\t\tconst response = await this.#request(\n\t\t\t`/v1/blobs/${blobId}/confirmation/deletable/${objectId}`,\n\t\t\toptions,\n\t\t);\n\n\t\tconst json: GetDeletableBlobConfirmationResponse = await response.json();\n\t\treturn json;\n\t}\n\n\t/**\n\t * Gets a signed storage confirmation from this storage node, indicating that all shards\n\t * assigned to this storage node for the current epoch have stored their respective slivers.\n\t */\n\tasync getPermanentBlobConfirmation(\n\t\t{ blobId }: GetPermanentBlobConfirmationRequestInput,\n\t\toptions: RequestOptions,\n\t): Promise<GetPermanentBlobConfirmationResponse> {\n\t\tconst response = await this.#request(`/v1/blobs/${blobId}/confirmation/permanent`, options);\n\n\t\tconst json: GetPermanentBlobConfirmationResponse = await response.json();\n\t\treturn json;\n\t}\n\n\tasync #request(path: string, options: RequestOptions) {\n\t\tconst { nodeUrl, signal, timeout, ...init } = options;\n\n\t\tif (signal?.aborted) {\n\t\t\tthrow new UserAbortError();\n\t\t}\n\n\t\tconst timeoutSignal = AbortSignal.timeout(timeout ?? this.#timeout);\n\n\t\tlet response: Response | undefined;\n\n\t\ttry {\n\t\t\tresponse = await (0, this.#fetch)(`${nodeUrl}${path}`, {\n\t\t\t\t...init,\n\t\t\t\tsignal: signal ? AbortSignal.any([timeoutSignal, signal]) : timeoutSignal,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tif (signal?.aborted) {\n\t\t\t\tthrow new UserAbortError();\n\t\t\t}\n\n\t\t\tif (error instanceof Error && error.name === 'AbortError') {\n\t\t\t\tconst error = new ConnectionTimeoutError();\n\t\t\t\tthis.#onError?.(error);\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tthis.#onError?.(error as Error);\n\n\t\t\tthrow error;\n\t\t}\n\n\t\tif (!response.ok) {\n\t\t\tconst errorText = await response.text().catch((reason) => reason);\n\t\t\tconst errorJSON = safeParseJSON(errorText);\n\t\t\tconst errorMessage = errorJSON ? undefined : errorText;\n\t\t\tconst error = StorageNodeAPIError.generate(response.status, errorJSON, errorMessage);\n\t\t\tthis.#onError?.(error);\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn response;\n\t}\n}\n\nfunction safeParseJSON(value: string) {\n\ttry {\n\t\treturn JSON.parse(value);\n\t} catch {\n\t\treturn undefined;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64, toBase64 } from '@mysten/bcs';\nimport type { InferBcsType } from '@mysten/bcs';\nimport type { SuiMoveNormalizedType } from '@mysten/sui/client';\n\nimport type { Committee } from '../contracts/walrus/committee.js';\nimport type { EncodingType } from '../types.js';\nimport { BlobId } from './bcs.js';\n\nconst DIGEST_LEN = 32;\nconst BLOB_ID_LEN = 32;\n\nexport const REQUIRED_ALIGNMENT_BY_ENCODING_TYPE = {\n\tRS2: 2,\n\tRedStuff: 2,\n};\n\nexport const MAX_SYMBOL_SIZE_BY_ENCODING_TYPE = {\n\tRS2: 2 ** 16 - 1,\n\tRedStuff: 2 ** 16 - 1,\n};\n\n// TODO: this name is kinda bad\nexport function encodedBlobLength(\n\tunencodedLength: number,\n\tnShards: number,\n\tencodingType: EncodingType = 'RS2',\n): number {\n\tconst sliverSize = encodedSliverSize(unencodedLength, nShards, encodingType);\n\tconst metadata = nShards * DIGEST_LEN * 2 + BLOB_ID_LEN;\n\treturn nShards * metadata + sliverSize;\n}\n\nexport function encodedSliverSize(\n\tunencodedLength: number,\n\tnShards: number,\n\tencodingType: EncodingType = 'RS2',\n): number {\n\tconst { primarySymbols, secondarySymbols } = getSourceSymbols(nShards, encodingType);\n\n\tlet symbolSize =\n\t\tMath.floor((Math.max(unencodedLength, 1) - 1) / (primarySymbols * secondarySymbols)) + 1;\n\n\tif (encodingType === 'RS2' && symbolSize % 2 === 1) {\n\t\tsymbolSize = symbolSize + 1;\n\t}\n\n\tconst singleShardSize = (primarySymbols + secondarySymbols) * symbolSize;\n\n\treturn singleShardSize * nShards;\n}\n\nexport function getSourceSymbols(nShards: number, encodingType: EncodingType = 'RS2') {\n\tconst safetyLimit = decodingSafetyLimit(nShards, encodingType);\n\tconst maxFaulty = getMaxFaultyNodes(nShards);\n\tconst minCorrect = nShards - maxFaulty;\n\n\treturn {\n\t\tprimarySymbols: minCorrect - maxFaulty - safetyLimit,\n\t\tsecondarySymbols: minCorrect - safetyLimit,\n\t};\n}\n\nexport function isQuorum(size: number, nShards: number): boolean {\n\tconst maxFaulty = getMaxFaultyNodes(nShards);\n\treturn size > 2 * maxFaulty;\n}\n\nexport function isAboveValidity(size: number, nShards: number): boolean {\n\tconst maxFaulty = getMaxFaultyNodes(nShards);\n\treturn size > maxFaulty;\n}\n\nexport function getMaxFaultyNodes(nShards: number): number {\n\treturn Math.floor((nShards - 1) / 3);\n}\n\nfunction decodingSafetyLimit(nShards: number, encodingType: EncodingType): number {\n\tswitch (encodingType) {\n\t\tcase 'RedStuff':\n\t\t\treturn Math.min(5, Math.floor(getMaxFaultyNodes(nShards) / 5));\n\t\tcase 'RS2':\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tthrow new Error(`Encountered unknown encoding type of ${encodingType}`);\n\t}\n}\n\nconst BYTES_PER_UNIT_SIZE = 1024 * 1024;\n\nexport function storageUnitsFromSize(size: number): number {\n\treturn Math.ceil(size / BYTES_PER_UNIT_SIZE);\n}\n\nfunction rotationOffset(bytes: Uint8Array, modulus: number): number {\n\treturn bytes.reduce((acc, byte) => (acc * 256 + byte) % modulus, 0);\n}\n\nexport function toShardIndex(sliverPairIndex: number, blobId: string, numShards: number): number {\n\tconst offset = rotationOffset(BlobId.serialize(blobId).toBytes(), numShards);\n\treturn (sliverPairIndex + offset) % numShards;\n}\n\nexport function sliverPairIndexFromSecondarySliverIndex(\n\tsliverIndex: number,\n\tnumShards: number,\n): number {\n\treturn numShards - sliverIndex - 1;\n}\n\nexport function shardIndexFromSecondarySliverIndex(\n\tsliverIndex: number,\n\tblobId: string,\n\tnumShards: number,\n): number {\n\tconst sliverPairIndex = sliverPairIndexFromSecondarySliverIndex(sliverIndex, numShards);\n\treturn toShardIndex(sliverPairIndex, blobId, numShards);\n}\n\nexport function toPairIndex(shardIndex: number, blobId: string, numShards: number): number {\n\tconst offset = rotationOffset(BlobId.serialize(blobId).toBytes(), numShards);\n\treturn (numShards + shardIndex - offset) % numShards;\n}\n\nexport function signersToBitmap(signers: number[], committeeSize: number): Uint8Array {\n\tconst bitmapSize = Math.ceil(committeeSize / 8);\n\tconst bitmap = new Uint8Array(bitmapSize);\n\n\tfor (const signer of signers) {\n\t\tconst byteIndex = Math.floor(signer / 8);\n\t\tconst bitIndex = signer % 8;\n\t\tbitmap[byteIndex] |= 1 << bitIndex;\n\t}\n\n\treturn bitmap;\n}\n\nexport function getShardIndicesByNodeId(committee: InferBcsType<typeof Committee>) {\n\tconst shardIndicesByNodeId = new Map<string, number[]>();\n\n\tfor (const node of committee[0].contents) {\n\t\tif (!shardIndicesByNodeId.has(node.key)) {\n\t\t\tshardIndicesByNodeId.set(node.key, []);\n\t\t}\n\t\tshardIndicesByNodeId.get(node.key)!.push(...node.value);\n\t}\n\n\treturn shardIndicesByNodeId;\n}\n\nexport function nodesByShardIndex(committee: InferBcsType<typeof Committee>) {\n\tconst nodesByShardIndex = new Map<number, string>();\n\n\tfor (const node of committee[0].contents) {\n\t\tfor (const shardIndex of node.value) {\n\t\t\tnodesByShardIndex.set(shardIndex, node.key);\n\t\t}\n\t}\n\n\treturn nodesByShardIndex;\n}\n\nexport function toTypeString(type: SuiMoveNormalizedType): string {\n\tif (typeof type === 'string') {\n\t\tswitch (type) {\n\t\t\tcase 'Address':\n\t\t\t\treturn 'address';\n\t\t\tcase 'Bool':\n\t\t\t\treturn 'bool';\n\t\t\tcase 'U8':\n\t\t\t\treturn 'u8';\n\t\t\tcase 'U16':\n\t\t\t\treturn 'u16';\n\t\t\tcase 'U32':\n\t\t\t\treturn 'u32';\n\t\t\tcase 'U64':\n\t\t\t\treturn 'u64';\n\t\t\tcase 'U128':\n\t\t\t\treturn 'u128';\n\t\t\tcase 'U256':\n\t\t\t\treturn 'u256';\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unexpected type ${type}`);\n\t\t}\n\t}\n\n\tif ('Vector' in type) {\n\t\treturn `vector<${toTypeString(type.Vector)}>`;\n\t}\n\n\tif ('Struct' in type) {\n\t\tif (type.Struct.typeArguments.length > 0) {\n\t\t\treturn `${type.Struct.address}::${type.Struct.module}::${type.Struct.name}<${type.Struct.typeArguments.map(toTypeString).join(',')}>`;\n\t\t} else {\n\t\t\treturn `${type.Struct.address}::${type.Struct.module}::${type.Struct.name}`;\n\t\t}\n\t}\n\n\tif ('TypeParameter' in type) {\n\t\tthrow new Error(`Type parameters can't be converted to type strings`);\n\t}\n\n\tif ('Reference' in type) {\n\t\treturn toTypeString(type.Reference);\n\t}\n\n\tif ('MutableReference' in type) {\n\t\treturn toTypeString(type.MutableReference);\n\t}\n\n\tthrow new Error(`Unexpected type ${JSON.stringify(type)}`);\n}\n\nexport function urlSafeBase64(bytes: Uint8Array): string {\n\treturn toBase64(bytes).replace(/=*$/, '').replaceAll('+', '-').replaceAll('/', '_');\n}\n\nexport function fromUrlSafeBase64(base64: string): Uint8Array {\n\treturn fromBase64(base64.replaceAll('-', '+').replaceAll('_', '/'));\n}\n\nexport function getSizes(blobSize: number, numShards: number) {\n\tconst encodedBlobSize = encodedSliverSize(blobSize, numShards);\n\tconst { primarySymbols, secondarySymbols } = getSourceSymbols(numShards);\n\tconst totalSymbols = (primarySymbols + secondarySymbols) * numShards;\n\n\tif (encodedBlobSize % totalSymbols !== 0) {\n\t\tthrow new Error('encoded blob size should be divisible by total symbols');\n\t}\n\n\tconst symbolSize = encodedBlobSize / totalSymbols;\n\n\tif (encodedBlobSize % totalSymbols !== 0) {\n\t\tthrow new Error('blob length should be divisible by total symbols');\n\t}\n\n\tconst rowSize = symbolSize * secondarySymbols;\n\tconst columnSize = symbolSize * primarySymbols;\n\n\treturn {\n\t\tsymbolSize,\n\t\trowSize,\n\t\tcolumnSize,\n\t\tblobSize,\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType } from '@mysten/bcs';\nimport { pureBcsSchemaFromTypeName } from '@mysten/sui/bcs';\nimport type { PureTypeName, ShapeFromPureTypeName } from '@mysten/sui/bcs';\nimport type { SuiObjectData } from '@mysten/sui/client';\nimport type {\n\tExperimental_BaseClient,\n\tExperimental_SuiClientTypes,\n} from '@mysten/sui/experimental';\nimport { deriveDynamicFieldID } from '@mysten/sui/utils';\nimport DataLoader from 'dataloader';\nimport { Field } from './bcs.js';\n\nexport class SuiObjectDataLoader extends DataLoader<\n\tstring,\n\tExperimental_SuiClientTypes.ObjectResponse\n> {\n\t#dynamicFieldCache = new Map<string, Map<string, Experimental_SuiClientTypes.ObjectResponse>>();\n\tconstructor(suiClient: Experimental_BaseClient) {\n\t\tsuper(async (ids: readonly string[]) => {\n\t\t\tconst { objects } = await suiClient.core.getObjects({\n\t\t\t\tobjectIds: ids as string[],\n\t\t\t});\n\n\t\t\treturn objects;\n\t\t});\n\t}\n\n\toverride async load<T = SuiObjectData>(id: string, schema?: BcsType<T, any>): Promise<T> {\n\t\tconst data = await super.load(id);\n\n\t\tif (schema) {\n\t\t\treturn schema.parse(await data.content);\n\t\t}\n\n\t\treturn data as T;\n\t}\n\n\toverride async loadMany<T = SuiObjectData>(\n\t\tids: string[],\n\t\tschema?: BcsType<T, any>,\n\t): Promise<(T | Error)[]> {\n\t\tconst data = await super.loadMany(ids);\n\n\t\tif (!schema) {\n\t\t\treturn data as (T | Error)[];\n\t\t}\n\n\t\treturn Promise.all(\n\t\t\tdata.map(async (d) => {\n\t\t\t\tif (d instanceof Error) {\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\n\t\t\t\treturn schema.parse(await d.content);\n\t\t\t}),\n\t\t);\n\t}\n\n\tasync loadManyOrThrow<T>(ids: string[], schema: BcsType<T, any>): Promise<T[]> {\n\t\tconst data = await this.loadMany(ids, schema);\n\n\t\tfor (const d of data) {\n\t\t\tif (d instanceof Error) {\n\t\t\t\tthrow d;\n\t\t\t}\n\t\t}\n\n\t\treturn data as T[];\n\t}\n\n\toverride clearAll() {\n\t\tthis.#dynamicFieldCache.clear();\n\t\treturn super.clearAll();\n\t}\n\n\toverride clear(key: string) {\n\t\tthis.#dynamicFieldCache.delete(key);\n\t\treturn super.clear(key);\n\t}\n\n\tasync loadFieldObject<K extends PureTypeName, T>(\n\t\tparent: string,\n\t\tname: {\n\t\t\ttype: K;\n\t\t\tvalue: ShapeFromPureTypeName<K>;\n\t\t},\n\t\ttype: BcsType<T, any>,\n\t): Promise<T> {\n\t\tconst schema = pureBcsSchemaFromTypeName<K>(name.type as never);\n\t\tconst id = deriveDynamicFieldID(parent, 'u64', schema.serialize(name.value).toBytes());\n\n\t\treturn (await this.load(id, Field(schema, type))).value;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\ntype WeightedItem<T> = {\n\tvalue: T;\n\tweight: number;\n};\n\nexport function weightedShuffle<T>(arr: WeightedItem<T>[]): T[] {\n\treturn arr\n\t\t.map(({ value, weight }) => ({\n\t\t\tvalue,\n\t\t\tweight: Math.pow(Math.random(), 1 / weight),\n\t\t}))\n\t\t.sort((a, b) => b.weight - a.weight)\n\t\t.map((item) => item.value);\n}\n\nexport function shuffle<T>(arr: T[]): T[] {\n\tconst result = [...arr];\n\n\tfor (let i = result.length - 1; i > 0; i -= 1) {\n\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t[result[i], result[j]] = [result[j], result[i]];\n\t}\n\n\treturn result;\n}\n", "let wasm;\r\n\r\nlet WASM_VECTOR_LEN = 0;\r\n\r\nlet cachedUint8ArrayMemory0 = null;\r\n\r\nfunction getUint8ArrayMemory0() {\r\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\r\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\r\n    }\r\n    return cachedUint8ArrayMemory0;\r\n}\r\n\r\nconst cachedTextEncoder = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () => { throw Error('TextEncoder not available') } } );\r\n\r\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\r\n    ? function (arg, view) {\r\n    return cachedTextEncoder.encodeInto(arg, view);\r\n}\r\n    : function (arg, view) {\r\n    const buf = cachedTextEncoder.encode(arg);\r\n    view.set(buf);\r\n    return {\r\n        read: arg.length,\r\n        written: buf.length\r\n    };\r\n});\r\n\r\nfunction passStringToWasm0(arg, malloc, realloc) {\r\n\r\n    if (realloc === undefined) {\r\n        const buf = cachedTextEncoder.encode(arg);\r\n        const ptr = malloc(buf.length, 1) >>> 0;\r\n        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);\r\n        WASM_VECTOR_LEN = buf.length;\r\n        return ptr;\r\n    }\r\n\r\n    let len = arg.length;\r\n    let ptr = malloc(len, 1) >>> 0;\r\n\r\n    const mem = getUint8ArrayMemory0();\r\n\r\n    let offset = 0;\r\n\r\n    for (; offset < len; offset++) {\r\n        const code = arg.charCodeAt(offset);\r\n        if (code > 0x7F) break;\r\n        mem[ptr + offset] = code;\r\n    }\r\n\r\n    if (offset !== len) {\r\n        if (offset !== 0) {\r\n            arg = arg.slice(offset);\r\n        }\r\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\r\n        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);\r\n        const ret = encodeString(arg, view);\r\n\r\n        offset += ret.written;\r\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\r\n    }\r\n\r\n    WASM_VECTOR_LEN = offset;\r\n    return ptr;\r\n}\r\n\r\nlet cachedDataViewMemory0 = null;\r\n\r\nfunction getDataViewMemory0() {\r\n    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {\r\n        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\r\n    }\r\n    return cachedDataViewMemory0;\r\n}\r\n\r\nfunction addToExternrefTable0(obj) {\r\n    const idx = wasm.__externref_table_alloc();\r\n    wasm.__wbindgen_export_4.set(idx, obj);\r\n    return idx;\r\n}\r\n\r\nfunction handleError(f, args) {\r\n    try {\r\n        return f.apply(this, args);\r\n    } catch (e) {\r\n        const idx = addToExternrefTable0(e);\r\n        wasm.__wbindgen_exn_store(idx);\r\n    }\r\n}\r\n\r\nfunction debugString(val) {\r\n    // primitive types\r\n    const type = typeof val;\r\n    if (type == 'number' || type == 'boolean' || val == null) {\r\n        return  `${val}`;\r\n    }\r\n    if (type == 'string') {\r\n        return `\"${val}\"`;\r\n    }\r\n    if (type == 'symbol') {\r\n        const description = val.description;\r\n        if (description == null) {\r\n            return 'Symbol';\r\n        } else {\r\n            return `Symbol(${description})`;\r\n        }\r\n    }\r\n    if (type == 'function') {\r\n        const name = val.name;\r\n        if (typeof name == 'string' && name.length > 0) {\r\n            return `Function(${name})`;\r\n        } else {\r\n            return 'Function';\r\n        }\r\n    }\r\n    // objects\r\n    if (Array.isArray(val)) {\r\n        const length = val.length;\r\n        let debug = '[';\r\n        if (length > 0) {\r\n            debug += debugString(val[0]);\r\n        }\r\n        for(let i = 1; i < length; i++) {\r\n            debug += ', ' + debugString(val[i]);\r\n        }\r\n        debug += ']';\r\n        return debug;\r\n    }\r\n    // Test for built-in\r\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\r\n    let className;\r\n    if (builtInMatches && builtInMatches.length > 1) {\r\n        className = builtInMatches[1];\r\n    } else {\r\n        // Failed to match the standard '[object ClassName]'\r\n        return toString.call(val);\r\n    }\r\n    if (className == 'Object') {\r\n        // we're a user defined class or Object\r\n        // JSON.stringify avoids problems with cycles, and is generally much\r\n        // easier than looping through ownProperties of `val`.\r\n        try {\r\n            return 'Object(' + JSON.stringify(val) + ')';\r\n        } catch (_) {\r\n            return 'Object';\r\n        }\r\n    }\r\n    // errors\r\n    if (val instanceof Error) {\r\n        return `${val.name}: ${val.message}\\n${val.stack}`;\r\n    }\r\n    // TODO we could test for more things here, like `Set`s and `Map`s.\r\n    return className;\r\n}\r\n\r\nconst cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );\r\n\r\nif (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); };\r\n\r\nfunction getStringFromWasm0(ptr, len) {\r\n    ptr = ptr >>> 0;\r\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\r\n}\r\n\r\nfunction isLikeNone(x) {\r\n    return x === undefined || x === null;\r\n}\r\n\r\nfunction passArray8ToWasm0(arg, malloc) {\r\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\r\n    getUint8ArrayMemory0().set(arg, ptr / 1);\r\n    WASM_VECTOR_LEN = arg.length;\r\n    return ptr;\r\n}\r\n\r\nfunction takeFromExternrefTable0(idx) {\r\n    const value = wasm.__wbindgen_export_4.get(idx);\r\n    wasm.__externref_table_dealloc(idx);\r\n    return value;\r\n}\r\n/**\r\n * @param {Uint8Array} signature\r\n * @param {Uint8Array} public_key\r\n * @param {Uint8Array} msg\r\n * @returns {boolean}\r\n */\r\nexport function bls12381_min_pk_verify(signature, public_key, msg) {\r\n    const ptr0 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);\r\n    const len0 = WASM_VECTOR_LEN;\r\n    const ptr1 = passArray8ToWasm0(public_key, wasm.__wbindgen_malloc);\r\n    const len1 = WASM_VECTOR_LEN;\r\n    const ptr2 = passArray8ToWasm0(msg, wasm.__wbindgen_malloc);\r\n    const len2 = WASM_VECTOR_LEN;\r\n    const ret = wasm.bls12381_min_pk_verify(ptr0, len0, ptr1, len1, ptr2, len2);\r\n    if (ret[2]) {\r\n        throw takeFromExternrefTable0(ret[1]);\r\n    }\r\n    return ret[0] !== 0;\r\n}\r\n\r\nfunction getArrayU8FromWasm0(ptr, len) {\r\n    ptr = ptr >>> 0;\r\n    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);\r\n}\r\n/**\r\n * Aggregate a list of signatures.\r\n * The signatures must be of the type Vec<Vec<u8>> with each signature being a 96 bytes long serialized signature.\r\n * @param {any} signatures\r\n * @returns {Uint8Array}\r\n */\r\nexport function bls12381_min_pk_aggregate(signatures) {\r\n    const ret = wasm.bls12381_min_pk_aggregate(signatures);\r\n    if (ret[3]) {\r\n        throw takeFromExternrefTable0(ret[2]);\r\n    }\r\n    var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\r\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\r\n    return v1;\r\n}\r\n\r\n/**\r\n * Verify an aggregate signature.\r\n * @param {any} public_keys\r\n * @param {Uint8Array} msg\r\n * @param {Uint8Array} signature\r\n * @returns {boolean}\r\n */\r\nexport function bls12381_min_pk_verify_aggregate(public_keys, msg, signature) {\r\n    const ptr0 = passArray8ToWasm0(msg, wasm.__wbindgen_malloc);\r\n    const len0 = WASM_VECTOR_LEN;\r\n    const ptr1 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);\r\n    const len1 = WASM_VECTOR_LEN;\r\n    const ret = wasm.bls12381_min_pk_verify_aggregate(public_keys, ptr0, len0, ptr1, len1);\r\n    if (ret[2]) {\r\n        throw takeFromExternrefTable0(ret[1]);\r\n    }\r\n    return ret[0] !== 0;\r\n}\r\n\r\nconst BlobEncoderFinalization = (typeof FinalizationRegistry === 'undefined')\r\n    ? { register: () => {}, unregister: () => {} }\r\n    : new FinalizationRegistry(ptr => wasm.__wbg_blobencoder_free(ptr >>> 0, 1));\r\n\r\nexport class BlobEncoder {\r\n\r\n    __destroy_into_raw() {\r\n        const ptr = this.__wbg_ptr;\r\n        this.__wbg_ptr = 0;\r\n        BlobEncoderFinalization.unregister(this);\r\n        return ptr;\r\n    }\r\n\r\n    free() {\r\n        const ptr = this.__destroy_into_raw();\r\n        wasm.__wbg_blobencoder_free(ptr, 0);\r\n    }\r\n    /**\r\n     * @param {number} n_shards\r\n     */\r\n    constructor(n_shards) {\r\n        const ret = wasm.blobencoder_new(n_shards);\r\n        if (ret[2]) {\r\n            throw takeFromExternrefTable0(ret[1]);\r\n        }\r\n        this.__wbg_ptr = ret[0] >>> 0;\r\n        BlobEncoderFinalization.register(this, this.__wbg_ptr, this);\r\n        return this;\r\n    }\r\n    /**\r\n     * WASM wrapper for [walrus_core::encoding::blob_encoding::BlobEncoder::encode_with_metadata].\r\n     * Returns a tuple with a vector of [walrus_core::encoding::slivers::SliverPair]´s and a [walrus_core::metadata::VerifiedBlobMetadataWithId]`.\r\n     * @param {Uint8Array} data\r\n     * @returns {any}\r\n     */\r\n    encode_with_metadata(data) {\r\n        const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\r\n        const len0 = WASM_VECTOR_LEN;\r\n        const ret = wasm.blobencoder_encode_with_metadata(this.__wbg_ptr, ptr0, len0);\r\n        if (ret[2]) {\r\n            throw takeFromExternrefTable0(ret[1]);\r\n        }\r\n        return takeFromExternrefTable0(ret[0]);\r\n    }\r\n    /**\r\n     * WASM wrapper for [walrus_core::encoding::blob_encoding::BlobEncoder::compute_metadata].\r\n     * Returns [walrus_core::metadata::VerifiedBlobMetadataWithId].\r\n     * @param {Uint8Array} data\r\n     * @returns {any}\r\n     */\r\n    compute_metadata(data) {\r\n        const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\r\n        const len0 = WASM_VECTOR_LEN;\r\n        const ret = wasm.blobencoder_compute_metadata(this.__wbg_ptr, ptr0, len0);\r\n        if (ret[2]) {\r\n            throw takeFromExternrefTable0(ret[1]);\r\n        }\r\n        return takeFromExternrefTable0(ret[0]);\r\n    }\r\n    /**\r\n     * WASM wrapper for [walrus_core::encoding::blob_encoding::BlobEncoder::decode].\r\n     * The input `slivers` is expected to be a `Vec<SliverData<Primary>>`.\r\n     * Returns `Vec<u8>`.\r\n     * @param {any} blob_id\r\n     * @param {bigint} blob_size\r\n     * @param {any} slivers\r\n     * @returns {any}\r\n     */\r\n    decode(blob_id, blob_size, slivers) {\r\n        const ret = wasm.blobencoder_decode(this.__wbg_ptr, blob_id, blob_size, slivers);\r\n        if (ret[2]) {\r\n            throw takeFromExternrefTable0(ret[1]);\r\n        }\r\n        return takeFromExternrefTable0(ret[0]);\r\n    }\r\n}\r\n\r\nasync function __wbg_load(module, imports) {\r\n    if (typeof Response === 'function' && module instanceof Response) {\r\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\r\n            try {\r\n                return await WebAssembly.instantiateStreaming(module, imports);\r\n\r\n            } catch (e) {\r\n                if (module.headers.get('Content-Type') != 'application/wasm') {\r\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\r\n\r\n                } else {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n\r\n        const bytes = await module.arrayBuffer();\r\n        return await WebAssembly.instantiate(bytes, imports);\r\n\r\n    } else {\r\n        const instance = await WebAssembly.instantiate(module, imports);\r\n\r\n        if (instance instanceof WebAssembly.Instance) {\r\n            return { instance, module };\r\n\r\n        } else {\r\n            return instance;\r\n        }\r\n    }\r\n}\r\n\r\nfunction __wbg_get_imports() {\r\n    const imports = {};\r\n    imports.wbg = {};\r\n    imports.wbg.__wbg_String_fed4d24b68977888 = function(arg0, arg1) {\r\n        const ret = String(arg1);\r\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\r\n        const len1 = WASM_VECTOR_LEN;\r\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\r\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\r\n    };\r\n    imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {\r\n        const ret = arg0.buffer;\r\n        return ret;\r\n    };\r\n    imports.wbg.__wbg_call_672a4d21634d4a24 = function() { return handleError(function (arg0, arg1) {\r\n        const ret = arg0.call(arg1);\r\n        return ret;\r\n    }, arguments) };\r\n    imports.wbg.__wbg_done_769e5ede4b31c67b = function(arg0) {\r\n        const ret = arg0.done;\r\n        return ret;\r\n    };\r\n    imports.wbg.__wbg_get_67b2ba62fc30de12 = function() { return handleError(function (arg0, arg1) {\r\n        const ret = Reflect.get(arg0, arg1);\r\n        return ret;\r\n    }, arguments) };\r\n    imports.wbg.__wbg_get_b9b93047fe3cf45b = function(arg0, arg1) {\r\n        const ret = arg0[arg1 >>> 0];\r\n        return ret;\r\n    };\r\n    imports.wbg.__wbg_getwithrefkey_bb8f74a92cb2e784 = function(arg0, arg1) {\r\n        const ret = arg0[arg1];\r\n        return ret;\r\n    };\r\n    imports.wbg.__wbg_instanceof_ArrayBuffer_e14585432e3737fc = function(arg0) {\r\n        let result;\r\n        try {\r\n            result = arg0 instanceof ArrayBuffer;\r\n        } catch (_) {\r\n            result = false;\r\n        }\r\n        const ret = result;\r\n        return ret;\r\n    };\r\n    imports.wbg.__wbg_instanceof_Uint8Array_17156bcf118086a9 = function(arg0) {\r\n        let result;\r\n        try {\r\n            result = arg0 instanceof Uint8Array;\r\n        } catch (_) {\r\n            result = false;\r\n        }\r\n        const ret = result;\r\n        return ret;\r\n    };\r\n    imports.wbg.__wbg_isArray_a1eab7e0d067391b = function(arg0) {\r\n        const ret = Array.isArray(arg0);\r\n        return ret;\r\n    };\r\n    imports.wbg.__wbg_isSafeInteger_343e2beeeece1bb0 = function(arg0) {\r\n        const ret = Number.isSafeInteger(arg0);\r\n        return ret;\r\n    };\r\n    imports.wbg.__wbg_iterator_9a24c88df860dc65 = function() {\r\n        const ret = Symbol.iterator;\r\n        return ret;\r\n    };\r\n    imports.wbg.__wbg_length_a446193dc22c12f8 = function(arg0) {\r\n        const ret = arg0.length;\r\n        return ret;\r\n    };\r\n    imports.wbg.__wbg_length_e2d2a49132c1b256 = function(arg0) {\r\n        const ret = arg0.length;\r\n        return ret;\r\n    };\r\n    imports.wbg.__wbg_new_405e22f390576ce2 = function() {\r\n        const ret = new Object();\r\n        return ret;\r\n    };\r\n    imports.wbg.__wbg_new_78feb108b6472713 = function() {\r\n        const ret = new Array();\r\n        return ret;\r\n    };\r\n    imports.wbg.__wbg_new_a12002a7f91c75be = function(arg0) {\r\n        const ret = new Uint8Array(arg0);\r\n        return ret;\r\n    };\r\n    imports.wbg.__wbg_next_25feadfc0913fea9 = function(arg0) {\r\n        const ret = arg0.next;\r\n        return ret;\r\n    };\r\n    imports.wbg.__wbg_next_6574e1a8a62d1055 = function() { return handleError(function (arg0) {\r\n        const ret = arg0.next();\r\n        return ret;\r\n    }, arguments) };\r\n    imports.wbg.__wbg_set_37837023f3d740e8 = function(arg0, arg1, arg2) {\r\n        arg0[arg1 >>> 0] = arg2;\r\n    };\r\n    imports.wbg.__wbg_set_3fda3bac07393de4 = function(arg0, arg1, arg2) {\r\n        arg0[arg1] = arg2;\r\n    };\r\n    imports.wbg.__wbg_set_65595bdd868b3009 = function(arg0, arg1, arg2) {\r\n        arg0.set(arg1, arg2 >>> 0);\r\n    };\r\n    imports.wbg.__wbg_value_cd1ffa7b1ab794f1 = function(arg0) {\r\n        const ret = arg0.value;\r\n        return ret;\r\n    };\r\n    imports.wbg.__wbindgen_bigint_from_u64 = function(arg0) {\r\n        const ret = BigInt.asUintN(64, arg0);\r\n        return ret;\r\n    };\r\n    imports.wbg.__wbindgen_boolean_get = function(arg0) {\r\n        const v = arg0;\r\n        const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\r\n        return ret;\r\n    };\r\n    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {\r\n        const ret = debugString(arg1);\r\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\r\n        const len1 = WASM_VECTOR_LEN;\r\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\r\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\r\n    };\r\n    imports.wbg.__wbindgen_error_new = function(arg0, arg1) {\r\n        const ret = new Error(getStringFromWasm0(arg0, arg1));\r\n        return ret;\r\n    };\r\n    imports.wbg.__wbindgen_in = function(arg0, arg1) {\r\n        const ret = arg0 in arg1;\r\n        return ret;\r\n    };\r\n    imports.wbg.__wbindgen_init_externref_table = function() {\r\n        const table = wasm.__wbindgen_export_4;\r\n        const offset = table.grow(4);\r\n        table.set(0, undefined);\r\n        table.set(offset + 0, undefined);\r\n        table.set(offset + 1, null);\r\n        table.set(offset + 2, true);\r\n        table.set(offset + 3, false);\r\n        ;\r\n    };\r\n    imports.wbg.__wbindgen_is_function = function(arg0) {\r\n        const ret = typeof(arg0) === 'function';\r\n        return ret;\r\n    };\r\n    imports.wbg.__wbindgen_is_object = function(arg0) {\r\n        const val = arg0;\r\n        const ret = typeof(val) === 'object' && val !== null;\r\n        return ret;\r\n    };\r\n    imports.wbg.__wbindgen_is_undefined = function(arg0) {\r\n        const ret = arg0 === undefined;\r\n        return ret;\r\n    };\r\n    imports.wbg.__wbindgen_jsval_loose_eq = function(arg0, arg1) {\r\n        const ret = arg0 == arg1;\r\n        return ret;\r\n    };\r\n    imports.wbg.__wbindgen_memory = function() {\r\n        const ret = wasm.memory;\r\n        return ret;\r\n    };\r\n    imports.wbg.__wbindgen_number_get = function(arg0, arg1) {\r\n        const obj = arg1;\r\n        const ret = typeof(obj) === 'number' ? obj : undefined;\r\n        getDataViewMemory0().setFloat64(arg0 + 8 * 1, isLikeNone(ret) ? 0 : ret, true);\r\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);\r\n    };\r\n    imports.wbg.__wbindgen_number_new = function(arg0) {\r\n        const ret = arg0;\r\n        return ret;\r\n    };\r\n    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {\r\n        const obj = arg1;\r\n        const ret = typeof(obj) === 'string' ? obj : undefined;\r\n        var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\r\n        var len1 = WASM_VECTOR_LEN;\r\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\r\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\r\n    };\r\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\r\n        const ret = getStringFromWasm0(arg0, arg1);\r\n        return ret;\r\n    };\r\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\r\n        throw new Error(getStringFromWasm0(arg0, arg1));\r\n    };\r\n\r\n    return imports;\r\n}\r\n\r\nfunction __wbg_init_memory(imports, memory) {\r\n\r\n}\r\n\r\nfunction __wbg_finalize_init(instance, module) {\r\n    wasm = instance.exports;\r\n    __wbg_init.__wbindgen_wasm_module = module;\r\n    cachedDataViewMemory0 = null;\r\n    cachedUint8ArrayMemory0 = null;\r\n\r\n\r\n    wasm.__wbindgen_start();\r\n    return wasm;\r\n}\r\n\r\nfunction initSync(module) {\r\n    if (wasm !== undefined) return wasm;\r\n\r\n\r\n    if (typeof module !== 'undefined') {\r\n        if (Object.getPrototypeOf(module) === Object.prototype) {\r\n            ({module} = module)\r\n        } else {\r\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')\r\n        }\r\n    }\r\n\r\n    const imports = __wbg_get_imports();\r\n\r\n    __wbg_init_memory(imports);\r\n\r\n    if (!(module instanceof WebAssembly.Module)) {\r\n        module = new WebAssembly.Module(module);\r\n    }\r\n\r\n    const instance = new WebAssembly.Instance(module, imports);\r\n\r\n    return __wbg_finalize_init(instance, module);\r\n}\r\n\r\nasync function __wbg_init(module_or_path) {\r\n    if (wasm !== undefined) return wasm;\r\n\r\n\r\n    if (typeof module_or_path !== 'undefined') {\r\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\r\n            ({module_or_path} = module_or_path)\r\n        } else {\r\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead')\r\n        }\r\n    }\r\n\r\n    if (typeof module_or_path === 'undefined') {\r\n        module_or_path = new URL('walrus_wasm_bg.wasm', import.meta.url);\r\n    }\r\n    const imports = __wbg_get_imports();\r\n\r\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\r\n        module_or_path = fetch(module_or_path);\r\n    }\r\n\r\n    __wbg_init_memory(imports);\r\n\r\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\r\n\r\n    return __wbg_finalize_init(instance, module);\r\n}\r\n\r\nexport { initSync };\r\nexport default __wbg_init;\r\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64 } from '@mysten/bcs';\nimport init, {\n\tBlobEncoder,\n\tbls12381_min_pk_aggregate,\n\tbls12381_min_pk_verify,\n} from '@mysten/walrus-wasm';\n\nimport type { StorageConfirmation } from './storage-node/types.js';\nimport type { EncodingType, ProtocolMessageCertificate } from './types.js';\nimport type { BlobMetadata, BlobMetadataWithId, SliverData, SliverPair } from './utils/bcs.js';\nimport { BlobId, blobIdFromBytes } from './utils/bcs.js';\n\nexport interface EncodedBlob {\n\tsliverPairs: (typeof SliverPair.$inferInput)[];\n\tblobId: string;\n\tmetadata: typeof BlobMetadata.$inferInput;\n\trootHash: Uint8Array;\n}\n\nexport async function getWasmBindings(url?: string) {\n\tawait init({ module_or_path: url });\n\n\tfunction encodeBlob(\n\t\tnShards: number,\n\t\tbytes: Uint8Array,\n\t\tencodingType: EncodingType = 'RS2',\n\t): EncodedBlob {\n\t\tconst encoder = new BlobEncoder(nShards);\n\n\t\tif (encodingType !== 'RS2') {\n\t\t\tthrow new Error(`Unsupported encoding type: ${encodingType}`);\n\t\t}\n\n\t\tconst [sliverPairs, metadata, rootHash] = encoder.encode_with_metadata(bytes);\n\n\t\treturn {\n\t\t\tsliverPairs,\n\t\t\tblobId: blobIdFromBytes(new Uint8Array(metadata.blob_id)),\n\t\t\tmetadata: metadata.metadata,\n\t\t\trootHash: new Uint8Array(rootHash.Digest),\n\t\t};\n\t}\n\n\tfunction combineSignatures(\n\t\tconfirmations: StorageConfirmation[],\n\t\tsignerIndices: number[],\n\t): ProtocolMessageCertificate {\n\t\tconst signature = bls12381_min_pk_aggregate(\n\t\t\tconfirmations.map((confirmation) => fromBase64(confirmation.signature)),\n\t\t);\n\n\t\treturn {\n\t\t\tsigners: signerIndices,\n\t\t\tserializedMessage: fromBase64(confirmations[0].serializedMessage),\n\t\t\tsignature,\n\t\t};\n\t}\n\n\tfunction decodePrimarySlivers(\n\t\tblobId: string,\n\t\tnShards: number,\n\t\tsize: number | bigint | string,\n\t\tslivers: (typeof SliverData.$inferInput)[],\n\t\tencodingType: EncodingType = 'RS2',\n\t): Uint8Array {\n\t\tconst encoder = new BlobEncoder(nShards);\n\n\t\tif (encodingType !== 'RS2') {\n\t\t\tthrow new Error(`Unsupported encoding type: ${encodingType}`);\n\t\t}\n\n\t\tconst [bytes] = encoder.decode(\n\t\t\tBlobId.serialize(blobId).toBytes(),\n\t\t\tBigInt(size),\n\t\t\tslivers.map((sliver) => ({\n\t\t\t\t...sliver,\n\t\t\t\t_sliver_type: undefined,\n\t\t\t})),\n\t\t);\n\n\t\treturn new Uint8Array(bytes);\n\t}\n\n\tfunction getVerifySignature() {\n\t\treturn (confirmation: StorageConfirmation, publicKey: Uint8Array) =>\n\t\t\tbls12381_min_pk_verify(\n\t\t\t\tfromBase64(confirmation.signature),\n\t\t\t\tpublicKey,\n\t\t\t\tfromBase64(confirmation.serializedMessage),\n\t\t\t);\n\t}\n\n\tfunction computeMetadata(\n\t\tnShards: number,\n\t\tbytes: Uint8Array,\n\t\tencodingType: EncodingType = 'RS2',\n\t): typeof BlobMetadataWithId.$inferInput & { blobId: string; rootHash: Uint8Array } {\n\t\tconst encoder = new BlobEncoder(nShards);\n\t\tconst [metadata, rootHash] = encoder.compute_metadata(bytes);\n\n\t\tif (encodingType !== 'RS2') {\n\t\t\tthrow new Error(`Unsupported encoding type: ${encodingType}`);\n\t\t}\n\n\t\treturn {\n\t\t\t...metadata,\n\t\t\tblobId: blobIdFromBytes(new Uint8Array(metadata.blob_id)),\n\t\t\trootHash: new Uint8Array(rootHash.Digest),\n\t\t};\n\t}\n\n\treturn {\n\t\tencodeBlob,\n\t\tcombineSignatures,\n\t\tdecodePrimarySlivers,\n\t\tgetVerifySignature,\n\t\tcomputeMetadata,\n\t};\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ConnectionTimeoutError, StorageNodeAPIError } from '../storage-node/error.js';\nimport { UserAbortError } from '../storage-node/error.js';\nimport type { mergeHeaders } from '../storage-node/utils.js';\nimport type {\n\tEncodingType,\n\tUploadRelayTipConfig,\n\tProtocolMessageCertificate,\n\tWalrusClientRequestOptions,\n} from '../types.js';\nimport { fromUrlSafeBase64, urlSafeBase64 } from '../utils/index.js';\n\nexport type Fetch = (url: RequestInfo, init?: RequestInit) => Promise<Response>;\n\nexport type UploadRelayClientOptions = {\n\thost: string;\n\t/**\n\t * An optional custom fetch function.\n\t *\n\t * If not provided, defaults to the global `fetch` function (`globalThis.fetch`).\n\t *\n\t * @default globalThis.fetch\n\t */\n\tfetch?: Fetch;\n\n\t/**\n\t * An optional timeout for requests.\n\t * @default 30_000ms (30 seconds)\n\t */\n\ttimeout?: number;\n\n\t/**\n\t * Callback for individual network errors.\n\t */\n\tonError?: (error: Error) => void;\n};\n\nexport type RequestOptions = {\n\tpath: string;\n\ttimeout?: number;\n\theaders?: ReturnType<typeof mergeHeaders>;\n} & Omit<RequestInit, 'headers'>;\n\nexport type WriteBlobToUploadRelayOptions = {\n\tblobId: string;\n\tnonce: Uint8Array;\n\ttxDigest: string;\n\tblob: Uint8Array;\n\tblobObjectId: string;\n\tdeletable: boolean;\n\trequiresTip: boolean;\n\tencodingType?: EncodingType;\n} & WalrusClientRequestOptions;\n\nexport class UploadRelayClient {\n\thost: string;\n\t#fetch: Fetch;\n\t#timeout: number;\n\t#onError?: (error: Error) => void;\n\tconstructor({ host, fetch: overriddenFetch, timeout, onError }: UploadRelayClientOptions) {\n\t\tthis.host = host;\n\t\tthis.#fetch = overriddenFetch ?? globalThis.fetch;\n\t\tthis.#timeout = timeout ?? 30_000;\n\t\tthis.#onError = onError;\n\t}\n\n\tasync tipConfig(): Promise<UploadRelayTipConfig | null> {\n\t\tconst response = await this.#request({\n\t\t\tmethod: 'GET',\n\t\t\tpath: '/v1/tip-config',\n\t\t});\n\n\t\tconst data = (await response.json()) as\n\t\t\t| {\n\t\t\t\t\tsend_tip: {\n\t\t\t\t\t\taddress: string;\n\t\t\t\t\t\tkind:\n\t\t\t\t\t\t\t| {\n\t\t\t\t\t\t\t\t\tconst: number;\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t| {\n\t\t\t\t\t\t\t\t\tlinear: {\n\t\t\t\t\t\t\t\t\t\tbase: number;\n\t\t\t\t\t\t\t\t\t\tencoded_size_mul_per_kib: number;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t  };\n\t\t\t\t\t};\n\t\t\t  }\n\t\t\t| 'no_tip';\n\n\t\tif (typeof data === 'string') {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ('const' in data.send_tip.kind) {\n\t\t\treturn {\n\t\t\t\taddress: data.send_tip.address,\n\t\t\t\tkind: {\n\t\t\t\t\tconst: data.send_tip.kind.const,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\taddress: data.send_tip.address,\n\t\t\tkind: {\n\t\t\t\tlinear: {\n\t\t\t\t\tbase: data.send_tip.kind.linear.base,\n\t\t\t\t\tperEncodedKib: data.send_tip.kind.linear.encoded_size_mul_per_kib,\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t}\n\n\tasync writeBlob({\n\t\tblobId,\n\t\tnonce,\n\t\ttxDigest,\n\t\tblob,\n\t\tdeletable,\n\t\tblobObjectId,\n\t\trequiresTip,\n\t\tencodingType,\n\t\t...options\n\t}: WriteBlobToUploadRelayOptions): Promise<{\n\t\tblobId: string;\n\t\tcertificate: ProtocolMessageCertificate;\n\t}> {\n\t\tconst query = new URLSearchParams({\n\t\t\tblob_id: blobId,\n\t\t});\n\n\t\tif (requiresTip) {\n\t\t\tquery.set('nonce', urlSafeBase64(nonce));\n\t\t\tquery.set('tx_id', txDigest);\n\t\t}\n\n\t\tif (deletable) {\n\t\t\tquery.set('deletable_blob_object', blobObjectId);\n\t\t}\n\n\t\tif (encodingType) {\n\t\t\tquery.set('encoding_type', encodingType);\n\t\t}\n\n\t\tconst response = await this.#request({\n\t\t\tmethod: 'POST',\n\t\t\tpath: `/v1/blob-upload-relay?${query.toString()}`,\n\t\t\tbody: blob,\n\t\t\t...options,\n\t\t});\n\n\t\tconst data: {\n\t\t\tblob_id: number[];\n\t\t\tconfirmation_certificate: {\n\t\t\t\tsigners: number[];\n\t\t\t\tserialized_message: number[];\n\t\t\t\tsignature: string;\n\t\t\t};\n\t\t} = await response.json();\n\n\t\treturn {\n\t\t\tblobId,\n\t\t\tcertificate: {\n\t\t\t\tsigners: data.confirmation_certificate.signers,\n\t\t\t\tserializedMessage: new Uint8Array(data.confirmation_certificate.serialized_message),\n\t\t\t\tsignature: fromUrlSafeBase64(data.confirmation_certificate.signature),\n\t\t\t},\n\t\t};\n\t}\n\n\tasync #request(options: RequestOptions) {\n\t\tconst { signal, timeout, ...init } = options;\n\n\t\tif (signal?.aborted) {\n\t\t\tthrow new UserAbortError();\n\t\t}\n\n\t\tconst timeoutSignal = AbortSignal.timeout(timeout ?? this.#timeout);\n\n\t\tlet response: Response | undefined;\n\n\t\ttry {\n\t\t\tresponse = await (0, this.#fetch)(`${this.host}${options.path}`, {\n\t\t\t\t...init,\n\t\t\t\tsignal: signal ? AbortSignal.any([timeoutSignal, signal]) : timeoutSignal,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tif (signal?.aborted) {\n\t\t\t\tthrow new UserAbortError();\n\t\t\t}\n\n\t\t\tif (error instanceof Error && error.name === 'AbortError') {\n\t\t\t\tconst error = new ConnectionTimeoutError();\n\t\t\t\tthis.#onError?.(error);\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tthis.#onError?.(error as Error);\n\n\t\t\tthrow error;\n\t\t}\n\n\t\tif (!response.ok) {\n\t\t\tconst errorText = await response.text().catch((reason) => reason);\n\t\t\tconst errorJSON = safeParseJSON(errorText);\n\t\t\tconst errorMessage = errorJSON ? undefined : errorText;\n\t\t\tconst error = StorageNodeAPIError.generate(response.status, errorJSON, errorMessage);\n\t\t\tthis.#onError?.(error);\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn response;\n\t}\n}\n\nfunction safeParseJSON(value: string) {\n\ttry {\n\t\treturn JSON.parse(value);\n\t} catch {\n\t\treturn undefined;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@mysten/bcs';\nimport type { EncodingType } from '../types.js';\nimport type { QuiltPatchV1 } from './bcs.js';\nimport { QuiltIndexV1, QuiltPatchBlobHeader, QuiltPatchId, QuiltPatchTags } from './bcs.js';\nimport {\n\tfromUrlSafeBase64,\n\tgetSourceSymbols,\n\tMAX_SYMBOL_SIZE_BY_ENCODING_TYPE,\n\tREQUIRED_ALIGNMENT_BY_ENCODING_TYPE,\n\turlSafeBase64,\n} from './index.js';\n\nexport const QUILT_INDEX_SIZE_BYTES_LENGTH = 4;\nexport const QUILT_VERSION_BYTES_LENGTH = 1;\nexport const QUILT_INDEX_PREFIX_SIZE = QUILT_VERSION_BYTES_LENGTH + QUILT_INDEX_SIZE_BYTES_LENGTH;\nexport const QUILT_PATCH_BLOB_HEADER_SIZE = 1 + 4 + 1; // bcs length of QuiltPatchBlobHeader\n\nexport const BLOB_IDENTIFIER_SIZE_BYTES_LENGTH = 2;\nexport const TAGS_SIZE_BYTES_LENGTH = 2;\nexport const MAX_BLOB_IDENTIFIER_BYTES_LENGTH = (1 << (8 * BLOB_IDENTIFIER_SIZE_BYTES_LENGTH)) - 1;\nexport const MAX_NUM_SLIVERS_FOR_QUILT_INDEX = 10;\n\nexport const HAS_TAGS_FLAG = 1 << 0;\n\n/**\n * Finds the minimum symbol size needed to store blobs in a fixed number of columns.\n * Each blob must be stored in consecutive columns exclusively.\n *\n * A binary search is used to find the minimum symbol size:\n * 1. Compute the upper and lower bounds for the symbol size.\n * 2. Check if the all the blobs can be fit into the quilt with the current symbol size.\n * 3. Adjust the bounds based on the result and repeat until the symbol size is found.\n *\n * @param blobsSizes - Slice of blob lengths, including the index size as the first element.\n *   Note that the len of the blob_size should be between 1 and n_columns.\n * @param nColumns - Number of columns available.\n * @param nRows - Number of rows available.\n * @param maxNumColumnsForQuiltIndex - The maximum number of columns that can be used to\n *   store the quilt index.\n * @param encodingType - The encoding type to use.\n *\n * @returns The minimum symbol size needed.\n **/\nexport function computeSymbolSize(\n\tblobsSizes: number[],\n\tnColumns: number,\n\tnRows: number,\n\tmaxNumColumnsForQuiltIndex: number,\n\tencodingType: EncodingType = 'RS2',\n): number {\n\tif (blobsSizes.length > nColumns) {\n\t\tthrow new Error('Too many blobs, the number of blobs must be less than the number of columns');\n\t}\n\n\tif (blobsSizes.length === 0) {\n\t\tthrow new Error('No blobs provided');\n\t}\n\n\tlet minVal = Math.max(\n\t\tblobsSizes.reduce((acc, size) => acc + size, 0) / (nColumns * nRows),\n\t\tblobsSizes[0] / (nRows * maxNumColumnsForQuiltIndex),\n\t\tMath.ceil(QUILT_INDEX_PREFIX_SIZE / nRows),\n\t);\n\n\tlet maxVal = Math.ceil((Math.max(...blobsSizes) / (nColumns / blobsSizes.length)) * nRows);\n\n\twhile (minVal < maxVal) {\n\t\tconst mid = (minVal + maxVal) / 2;\n\t\tif (canBlobsFitIntoMatrix(blobsSizes, nColumns, mid * nRows)) {\n\t\t\tmaxVal = mid;\n\t\t} else {\n\t\t\tminVal = mid + 1;\n\t\t}\n\t}\n\n\tconst symbolSize =\n\t\tMath.ceil(minVal / REQUIRED_ALIGNMENT_BY_ENCODING_TYPE[encodingType]) *\n\t\tREQUIRED_ALIGNMENT_BY_ENCODING_TYPE[encodingType];\n\n\tif (!canBlobsFitIntoMatrix(blobsSizes, nColumns, symbolSize * nRows)) {\n\t\tthrow new Error('Quilt oversize');\n\t}\n\n\tif (symbolSize > MAX_SYMBOL_SIZE_BY_ENCODING_TYPE[encodingType]) {\n\t\tthrow new Error(\n\t\t\t`Quilt oversize: the resulting symbol size ${symbolSize} is larger than the maximum symbol size ${MAX_SYMBOL_SIZE_BY_ENCODING_TYPE[encodingType]}; remove some blobs`,\n\t\t);\n\t}\n\n\treturn symbolSize;\n}\n\nfunction canBlobsFitIntoMatrix(\n\tblobsSizes: number[],\n\tnColumns: number,\n\tcolumnSize: number,\n): boolean {\n\treturn blobsSizes.reduce((acc, size) => acc + Math.ceil(size / columnSize), 0) <= nColumns;\n}\n\nexport function parseQuiltPatchId(id: string) {\n\treturn QuiltPatchId.parse(fromUrlSafeBase64(id));\n}\n\nexport function encodeQuiltPatchId(id: typeof QuiltPatchId.$inferInput) {\n\treturn urlSafeBase64(QuiltPatchId.serialize(id).toBytes());\n}\n\nexport function parseWalrusId(id: string) {\n\tconst bytes = fromUrlSafeBase64(id);\n\n\tif (bytes.length === 32) {\n\t\treturn {\n\t\t\tkind: 'blob' as const,\n\t\t\tid,\n\t\t};\n\t}\n\n\treturn {\n\t\tkind: 'quiltPatch' as const,\n\t\tid: parseQuiltPatchId(id),\n\t};\n}\n\nexport interface EncodeQuiltOptions {\n\tblobs: {\n\t\tcontents: Uint8Array;\n\t\tidentifier: string;\n\t\ttags?: Record<string, string>;\n\t}[];\n\tnumShards: number;\n\tencodingType?: EncodingType;\n}\n\nexport function encodeQuilt({ blobs, numShards, encodingType }: EncodeQuiltOptions) {\n\tconst { primarySymbols: nRows, secondarySymbols: nCols } = getSourceSymbols(\n\t\tnumShards,\n\t\tencodingType,\n\t);\n\n\tconst sortedBlobs = blobs.sort((a, b) => (a.identifier < b.identifier ? -1 : 1));\n\tconst identifiers = new Set<string>();\n\tconst index = {\n\t\tpatches: [] as (typeof QuiltPatchV1.$inferInput & { startIndex: number })[],\n\t};\n\tconst tags = sortedBlobs.map((blob) =>\n\t\tblob.tags && Object.keys(blob.tags).length > 0\n\t\t\t? QuiltPatchTags.serialize(blob.tags).toBytes()\n\t\t\t: null,\n\t);\n\n\tfor (const blob of sortedBlobs) {\n\t\tif (identifiers.has(blob.identifier)) {\n\t\t\tthrow new Error(`Duplicate blob identifier: ${blob.identifier}`);\n\t\t}\n\t\tidentifiers.add(blob.identifier);\n\t\tindex.patches.push({\n\t\t\tstartIndex: 0,\n\t\t\tendIndex: 0,\n\t\t\tidentifier: blob.identifier,\n\t\t\ttags: blob.tags ?? {},\n\t\t});\n\t}\n\n\tconst indexSize = QUILT_INDEX_PREFIX_SIZE + QuiltIndexV1.serialize(index).toBytes().length;\n\tconst blobMetadata = sortedBlobs.map((blob, i) => {\n\t\tconst identifierBytes = bcs.string().serialize(blob.identifier).toBytes();\n\t\tlet metadataSize =\n\t\t\tQUILT_PATCH_BLOB_HEADER_SIZE + BLOB_IDENTIFIER_SIZE_BYTES_LENGTH + identifierBytes.length;\n\n\t\tlet mask = 0;\n\t\tlet offset = 0;\n\n\t\tif (tags[i]) {\n\t\t\tmetadataSize += TAGS_SIZE_BYTES_LENGTH + tags[i].length;\n\t\t\tmask |= HAS_TAGS_FLAG << 0;\n\t\t}\n\n\t\tconst metadata = new Uint8Array(metadataSize);\n\t\tconst metadataView = new DataView(metadata.buffer);\n\n\t\tconst header = QuiltPatchBlobHeader.serialize({\n\t\t\tversion: 1,\n\t\t\tlength: metadataSize - QUILT_PATCH_BLOB_HEADER_SIZE + blob.contents.length,\n\t\t\tmask,\n\t\t}).toBytes();\n\n\t\tmetadata.set(header, offset);\n\t\toffset += header.length;\n\n\t\tmetadataView.setUint16(offset, identifierBytes.length, true);\n\t\toffset += BLOB_IDENTIFIER_SIZE_BYTES_LENGTH;\n\t\tmetadata.set(identifierBytes, offset);\n\t\toffset += identifierBytes.length;\n\n\t\tif (tags[i]) {\n\t\t\tmetadataView.setUint16(offset, tags[i].length, true);\n\t\t\toffset += TAGS_SIZE_BYTES_LENGTH;\n\t\t\tmetadata.set(tags[i], offset);\n\t\t\toffset += tags[i].length;\n\t\t}\n\n\t\treturn metadata;\n\t});\n\n\tconst blobSizes = [\n\t\tindexSize,\n\t\t...sortedBlobs.map((blob, i) => {\n\t\t\tif (blob.identifier.length > MAX_BLOB_IDENTIFIER_BYTES_LENGTH) {\n\t\t\t\tthrow new Error(`Blob identifier too long: ${blob.identifier}`);\n\t\t\t}\n\n\t\t\treturn blobMetadata[i].length + blob.contents.length;\n\t\t}),\n\t];\n\n\tconst symbolSize = computeSymbolSize(\n\t\tblobSizes,\n\t\tnCols,\n\t\tnRows,\n\t\tMAX_NUM_SLIVERS_FOR_QUILT_INDEX,\n\t\tencodingType,\n\t);\n\n\tconst rowSize = symbolSize * nCols;\n\tconst columnSize = symbolSize * nRows;\n\tconst indexColumnsNeeded = Math.ceil(indexSize / columnSize);\n\n\tif (indexColumnsNeeded > MAX_NUM_SLIVERS_FOR_QUILT_INDEX) {\n\t\tthrow new Error('Index too large');\n\t}\n\n\tconst quilt = new Uint8Array(rowSize * nRows);\n\tlet currentColumn = indexColumnsNeeded;\n\n\tfor (let i = 0; i < sortedBlobs.length; i++) {\n\t\tconst blob = sortedBlobs[i];\n\t\tindex.patches[i].startIndex = currentColumn;\n\t\tcurrentColumn += writeBlobToQuilt(\n\t\t\tquilt,\n\t\t\tblob.contents,\n\t\t\trowSize,\n\t\t\tcolumnSize,\n\t\t\tsymbolSize,\n\t\t\tcurrentColumn,\n\t\t\tblobMetadata[i],\n\t\t);\n\t\tindex.patches[i].endIndex = currentColumn;\n\t}\n\n\tconst indexBytes = QuiltIndexV1.serialize(index).toBytes();\n\tconst quiltIndex = new Uint8Array(QUILT_INDEX_PREFIX_SIZE + indexBytes.length);\n\tquiltIndex.set([1], 0); // version\n\tquiltIndex.set(new Uint32Array([indexBytes.length]), 1);\n\tquiltIndex.set(indexBytes, QUILT_INDEX_PREFIX_SIZE);\n\n\twriteBlobToQuilt(quilt, quiltIndex, rowSize, columnSize, symbolSize, 0);\n\n\treturn { quilt, index };\n}\n\nfunction writeBlobToQuilt(\n\tquilt: Uint8Array,\n\tblob: Uint8Array,\n\trowSize: number,\n\tcolumnSize: number,\n\tsymbolSize: number,\n\tstartColumn: number,\n\tprefix?: Uint8Array,\n) {\n\tconst nRows = columnSize / symbolSize;\n\tlet bytesWritten = 0;\n\n\tif (rowSize % symbolSize !== 0) {\n\t\tthrow new Error('Row size must be divisible by symbol size');\n\t}\n\n\tif (columnSize % symbolSize !== 0) {\n\t\tthrow new Error('Column size must be divisible by symbol size');\n\t}\n\n\tif (prefix) {\n\t\twriteBytes(prefix);\n\t}\n\n\twriteBytes(blob);\n\n\treturn Math.ceil(bytesWritten / columnSize);\n\n\tfunction writeBytes(bytes: Uint8Array) {\n\t\tconst offset = bytesWritten;\n\t\tconst symbolsToSkip = Math.floor(offset / symbolSize);\n\t\tlet remainingOffset = offset % symbolSize;\n\t\tlet currentCol = startColumn + Math.floor(symbolsToSkip / nRows);\n\t\tlet currentRow = symbolsToSkip % nRows;\n\n\t\tlet index = 0;\n\t\twhile (index < bytes.length) {\n\t\t\tconst baseIndex = currentRow * rowSize + currentCol * symbolSize;\n\t\t\tconst startIndex = baseIndex + remainingOffset;\n\t\t\tconst len = Math.min(symbolSize - remainingOffset, bytes.length - index);\n\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tquilt[startIndex + i] = bytes[index + i];\n\t\t\t}\n\t\t\tindex += len;\n\t\t\tremainingOffset = 0;\n\t\t\tcurrentRow = (currentRow + 1) % nRows;\n\t\t\tif (currentRow === 0) {\n\t\t\t\tcurrentCol++;\n\t\t\t}\n\t\t}\n\n\t\tbytesWritten += bytes.length;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { FileReader } from '../file.js';\nimport type { QuiltReader } from './quilt.js';\n\nexport interface QuiltBlobHeader {\n\tidentifier: string;\n\ttags: Record<string, string> | null;\n\tblobSize: number;\n\tcontentOffset: number;\n\tcolumnSize: number;\n}\n\nexport class QuiltFileReader implements FileReader {\n\t#quilt: QuiltReader;\n\t#sliverIndex: number;\n\t#identifier: string | null;\n\t#tags?: Record<string, string>;\n\n\tconstructor({\n\t\tquilt,\n\t\tsliverIndex,\n\t\tidentifier,\n\t\ttags,\n\t}: {\n\t\tquilt: QuiltReader;\n\t\tsliverIndex: number;\n\t\tidentifier?: string;\n\t\ttags?: Record<string, string>;\n\t}) {\n\t\tthis.#quilt = quilt;\n\t\tthis.#sliverIndex = sliverIndex;\n\t\tthis.#identifier = identifier ?? null;\n\t\tthis.#tags = tags;\n\t}\n\n\tasync getBytes(): Promise<Uint8Array> {\n\t\tconst { blobContents, identifier, tags } = await this.#quilt.readBlob(this.#sliverIndex);\n\t\tthis.#identifier = identifier;\n\t\tthis.#tags = tags ?? {};\n\t\treturn blobContents;\n\t}\n\n\tasync getIdentifier() {\n\t\tif (this.#identifier !== null) {\n\t\t\treturn this.#identifier;\n\t\t}\n\n\t\tconst header = await this.#quilt.getBlobHeader(this.#sliverIndex);\n\n\t\tthis.#identifier = header.identifier;\n\t\treturn this.#identifier;\n\t}\n\n\tasync getTags() {\n\t\tif (this.#tags !== undefined) {\n\t\t\treturn this.#tags;\n\t\t}\n\n\t\tconst header = await this.#quilt.getBlobHeader(this.#sliverIndex);\n\t\tthis.#tags = header.tags ?? {};\n\t\treturn this.#tags;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ClientCache } from '@mysten/sui/experimental';\nimport type { BlobReader } from './blob.js';\nimport { QuiltPatchBlobHeader, QuiltPatchId } from '../../utils/bcs.js';\nimport {\n\tHAS_TAGS_FLAG,\n\tparseQuiltPatchId,\n\tQUILT_PATCH_BLOB_HEADER_SIZE,\n} from '../../utils/quilts.js';\nimport { bcs } from '@mysten/bcs';\nimport { QuiltPatchTags } from '../../utils/bcs.js';\nimport { QuiltIndexV1 } from '../../utils/bcs.js';\nimport { urlSafeBase64 } from '../../utils/index.js';\nimport { QuiltFileReader } from './quilt-file.js';\n\nexport interface QuiltReaderOptions {\n\tblob: BlobReader;\n}\n\nexport class QuiltReader {\n\t#blob: BlobReader;\n\t#cache = new ClientCache();\n\n\tconstructor({ blob }: QuiltReaderOptions) {\n\t\tthis.#blob = blob;\n\t}\n\n\tasync #readBytesFromSlivers(sliver: number, length: number, offset = 0, columnSize?: number) {\n\t\tif (!length) {\n\t\t\treturn new Uint8Array(0);\n\t\t}\n\n\t\t// start loading the first sliver, but don't wait for it (may improve columnSize lookup)\n\t\tthis.#blob.getSecondarySliver({ sliverIndex: sliver }).catch(() => {});\n\n\t\tcolumnSize = columnSize ?? (await this.#blob.getColumnSize());\n\t\tconst columnOffset = Math.floor(offset / columnSize);\n\t\tlet remainingOffset = offset % columnSize;\n\t\tconst bytes = new Uint8Array(length);\n\n\t\tlet bytesRead = 0;\n\n\t\tconst nSlivers = Math.ceil(length / columnSize);\n\t\tconst slivers = new Array(nSlivers)\n\t\t\t.fill(0)\n\t\t\t.map((_, i) => this.#blob.getSecondarySliver({ sliverIndex: sliver + columnOffset + i }));\n\n\t\t// ignore errors from slivers that are not consumed below\n\t\tslivers.forEach((p) => p.catch(() => {}));\n\n\t\tfor (const sliverPromise of slivers) {\n\t\t\tconst sliver = await sliverPromise;\n\t\t\tlet chunk = remainingOffset > 0 ? sliver.subarray(remainingOffset) : sliver;\n\t\t\tremainingOffset -= chunk.length;\n\t\t\tif (chunk.length > length - bytesRead) {\n\t\t\t\tchunk = chunk.subarray(0, length - bytesRead);\n\t\t\t}\n\n\t\t\tbytes.set(chunk, bytesRead);\n\t\t\tbytesRead += chunk.length;\n\n\t\t\tif (bytesRead >= length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn bytes;\n\t}\n\n\tasync #readBytesFromBlob(startColumn: number, length: number, offset = 0) {\n\t\tconst result = new Uint8Array(length);\n\n\t\tif (!length) {\n\t\t\treturn result;\n\t\t}\n\t\tconst blob = await this.#blob.getBytes();\n\n\t\tconst [rowSize, symbolSize] = await Promise.all([\n\t\t\tthis.#blob.getRowSize(),\n\t\t\tthis.#blob.getSymbolSize(),\n\t\t]);\n\n\t\tconst nRows = blob.length / rowSize;\n\t\tconst symbolsToSkip = Math.floor(offset / symbolSize);\n\t\tlet remainingOffset = offset % symbolSize;\n\t\tlet currentCol = startColumn + Math.floor(symbolsToSkip / nRows);\n\t\tlet currentRow = symbolsToSkip % nRows;\n\n\t\tlet bytesRead = 0;\n\n\t\twhile (bytesRead < length) {\n\t\t\tconst baseIndex = currentRow * rowSize + currentCol * symbolSize;\n\t\t\tconst startIndex = baseIndex + remainingOffset;\n\t\t\tconst endIndex = Math.min(\n\t\t\t\tbaseIndex + symbolSize,\n\t\t\t\tstartIndex + length - bytesRead,\n\t\t\t\tblob.length,\n\t\t\t);\n\n\t\t\tif (startIndex >= blob.length) {\n\t\t\t\tthrow new Error('Index out of bounds');\n\t\t\t}\n\n\t\t\tconst size = endIndex - startIndex;\n\n\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\tresult[bytesRead + i] = blob[startIndex + i];\n\t\t\t}\n\n\t\t\tbytesRead += size;\n\n\t\t\tremainingOffset = 0;\n\n\t\t\tcurrentRow = (currentRow + 1) % nRows;\n\t\t\tif (currentRow === 0) {\n\t\t\t\tcurrentCol += 1;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tasync #readBytes(sliver: number, length: number, offset = 0, columnSize?: number) {\n\t\tif (this.#blob.hasStartedLoadingFullBlob) {\n\t\t\treturn this.#readBytesFromBlob(sliver, length, offset);\n\t\t}\n\n\t\ttry {\n\t\t\tconst bytes = await this.#readBytesFromSlivers(sliver, length, offset, columnSize);\n\n\t\t\treturn bytes;\n\t\t} catch (_error) {\n\t\t\t// fallback to reading the full blob\n\t\t\treturn this.#readBytesFromBlob(sliver, length, offset);\n\t\t}\n\t}\n\n\tasync getBlobHeader(sliverIndex: number) {\n\t\treturn this.#cache.read(['getBlobHeader', sliverIndex.toString()], async () => {\n\t\t\tconst blobHeader = QuiltPatchBlobHeader.parse(\n\t\t\t\tawait this.#readBytes(sliverIndex, QUILT_PATCH_BLOB_HEADER_SIZE),\n\t\t\t);\n\n\t\t\tlet offset = QUILT_PATCH_BLOB_HEADER_SIZE;\n\t\t\tlet blobSize = blobHeader.length;\n\n\t\t\tconst identifierLength = new DataView(\n\t\t\t\t(await this.#readBytes(sliverIndex, 2, offset)).buffer,\n\t\t\t).getUint16(0, true);\n\t\t\tblobSize -= 2 + identifierLength;\n\t\t\toffset += 2;\n\n\t\t\tconst identifier = bcs\n\t\t\t\t.string()\n\t\t\t\t.parse(await this.#readBytes(sliverIndex, identifierLength, offset));\n\n\t\t\toffset += identifierLength;\n\n\t\t\tlet tags: Record<string, string> | null = null;\n\t\t\tif (blobHeader.mask & HAS_TAGS_FLAG) {\n\t\t\t\tconst tagsSize = new DataView(\n\t\t\t\t\t(await this.#readBytes(sliverIndex, 2, offset)).buffer,\n\t\t\t\t).getUint16(0, true);\n\t\t\t\toffset += 2;\n\n\t\t\t\ttags = QuiltPatchTags.parse(await this.#readBytes(sliverIndex, tagsSize, offset));\n\t\t\t\tblobSize -= tagsSize + 2;\n\t\t\t\toffset += tagsSize;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tidentifier,\n\t\t\t\ttags,\n\t\t\t\tblobSize,\n\t\t\t\tcontentOffset: offset,\n\t\t\t};\n\t\t});\n\t}\n\n\tasync readBlob(sliverIndex: number) {\n\t\tconst { identifier, tags, blobSize, contentOffset } = await this.getBlobHeader(sliverIndex);\n\n\t\tconst blobContents = await this.#readBytes(sliverIndex, blobSize, contentOffset);\n\n\t\treturn {\n\t\t\tidentifier,\n\t\t\ttags,\n\t\t\tblobContents,\n\t\t};\n\t}\n\n\treaderForPatchId(id: string) {\n\t\tconst { quiltId, patchId } = parseQuiltPatchId(id);\n\n\t\tif (quiltId !== this.#blob.blobId) {\n\t\t\tthrow new Error(\n\t\t\t\t`The requested patch ${patchId} is not part of the quilt ${this.#blob.blobId}`,\n\t\t\t);\n\t\t}\n\n\t\treturn new QuiltFileReader({ quilt: this, sliverIndex: patchId.startIndex });\n\t}\n\n\tasync readIndex() {\n\t\tconst header = new DataView((await this.#readBytes(0, 5)).buffer);\n\n\t\tconst version = header.getUint8(0);\n\n\t\tif (version !== 1) {\n\t\t\tthrow new Error(`Unsupported quilt version ${version}`);\n\t\t}\n\n\t\tconst indexSize = header.getUint32(1, true);\n\t\tconst indexBytes = await this.#readBytes(0, indexSize, 5);\n\t\tconst columnSize = await this.#blob.getColumnSize();\n\t\tconst indexSlivers = Math.ceil(indexSize / columnSize);\n\t\tconst index = QuiltIndexV1.parse(indexBytes);\n\n\t\treturn index.patches.map((patch, i) => {\n\t\t\tconst startIndex = i === 0 ? indexSlivers : index.patches[i - 1].endIndex;\n\t\t\tconst reader = new QuiltFileReader({\n\t\t\t\tquilt: this,\n\t\t\t\tsliverIndex: startIndex,\n\t\t\t\tidentifier: patch.identifier,\n\t\t\t\ttags: patch.tags,\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tidentifier: patch.identifier,\n\t\t\t\tpatchId: urlSafeBase64(\n\t\t\t\t\tQuiltPatchId.serialize({\n\t\t\t\t\t\tquiltId: this.#blob.blobId,\n\t\t\t\t\t\tpatchId: {\n\t\t\t\t\t\t\tversion: 1,\n\t\t\t\t\t\t\tstartIndex,\n\t\t\t\t\t\t\tendIndex: patch.endIndex,\n\t\t\t\t\t\t},\n\t\t\t\t\t}).toBytes(),\n\t\t\t\t),\n\t\t\t\ttags: patch.tags,\n\t\t\t\treader,\n\t\t\t};\n\t\t});\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { ClientCache } from '@mysten/sui/experimental';\nimport type { FileReader } from '../file.js';\nimport type { WalrusClient } from '../../client.js';\nimport { getSizes, getSourceSymbols } from '../../utils/index.js';\nimport { QuiltReader } from './quilt.js';\n\nexport interface BlobReaderOptions {\n\tclient: WalrusClient;\n\tblobId: string;\n\tnumShards: number;\n}\n\nexport class BlobReader implements FileReader {\n\tblobId: string;\n\n\t#cache = new ClientCache();\n\n\t#client: WalrusClient;\n\t#secondarySlivers = new Map<number, Uint8Array | Promise<Uint8Array>>();\n\thasStartedLoadingFullBlob = false;\n\t#numShards: number;\n\n\tconstructor({ client, blobId, numShards }: BlobReaderOptions) {\n\t\tthis.#client = client;\n\t\tthis.blobId = blobId;\n\t\tthis.#numShards = numShards;\n\t}\n\n\tasync getIdentifier() {\n\t\treturn null;\n\t}\n\n\tasync getTags() {\n\t\treturn {};\n\t}\n\n\tgetQuiltReader() {\n\t\treturn new QuiltReader({ blob: this });\n\t}\n\n\tasync getBytes() {\n\t\treturn this.#cache.read(['getBytes'], async () => {\n\t\t\tthis.hasStartedLoadingFullBlob = true;\n\t\t\ttry {\n\t\t\t\tconst blob = await this.#client.readBlob({ blobId: this.blobId });\n\t\t\t\treturn blob;\n\t\t\t} catch (error) {\n\t\t\t\tthis.hasStartedLoadingFullBlob = false;\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t});\n\t}\n\n\tgetMetadata() {\n\t\treturn this.#cache.read(['getMetadata'], () =>\n\t\t\tthis.#client.getBlobMetadata({ blobId: this.blobId }),\n\t\t);\n\t}\n\n\tasync getColumnSize() {\n\t\treturn this.#cache.read(['getColumnSize'], async () => {\n\t\t\tconst loadingSlivers = [...this.#secondarySlivers.values()];\n\n\t\t\tif (loadingSlivers.length > 0) {\n\t\t\t\tconst sliver = await Promise.any(loadingSlivers).catch(() => null);\n\n\t\t\t\tif (sliver) {\n\t\t\t\t\treturn sliver.length;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.hasStartedLoadingFullBlob) {\n\t\t\t\tconst blob = await this.getBytes();\n\t\t\t\tconst { columnSize } = getSizes(blob.length, this.#numShards);\n\t\t\t\treturn columnSize;\n\t\t\t}\n\n\t\t\tconst metadata = await this.getMetadata();\n\t\t\tconst { columnSize } = getSizes(\n\t\t\t\tNumber(metadata.metadata.V1.unencoded_length),\n\t\t\t\tthis.#numShards,\n\t\t\t);\n\n\t\t\treturn columnSize;\n\t\t});\n\t}\n\n\tasync getSymbolSize() {\n\t\tconst columnSize = await this.getColumnSize();\n\t\tconst { primarySymbols } = getSourceSymbols(this.#numShards);\n\n\t\tif (columnSize % primarySymbols !== 0) {\n\t\t\tthrow new Error('column size should be divisible by primary symbols');\n\t\t}\n\n\t\treturn columnSize / primarySymbols;\n\t}\n\n\tasync getRowSize() {\n\t\tconst symbolSize = await this.getSymbolSize();\n\t\tconst { secondarySymbols } = getSourceSymbols(this.#numShards);\n\t\treturn symbolSize * secondarySymbols;\n\t}\n\n\tasync getSecondarySliver({ sliverIndex, signal }: { sliverIndex: number; signal?: AbortSignal }) {\n\t\tif (this.#secondarySlivers.has(sliverIndex)) {\n\t\t\treturn this.#secondarySlivers.get(sliverIndex)!;\n\t\t}\n\n\t\tconst sliverPromise = this.#client\n\t\t\t.getSecondarySliver({\n\t\t\t\tblobId: this.blobId,\n\t\t\t\tindex: sliverIndex,\n\t\t\t\tsignal,\n\t\t\t})\n\t\t\t.then((sliver) => new Uint8Array(sliver.symbols.data));\n\n\t\tthis.#secondarySlivers.set(sliverIndex, sliverPromise);\n\n\t\ttry {\n\t\t\tconst sliver = await sliverPromise;\n\t\t\tthis.#secondarySlivers.set(sliverIndex, sliver);\n\t\t\treturn sliver;\n\t\t} catch (error) {\n\t\t\tthis.#secondarySlivers.delete(sliverIndex);\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { FileReader } from '../file.js';\n\nexport class LocalReader implements FileReader {\n\t#contents: Uint8Array | Blob;\n\t#identifier: string | null;\n\t#tags: Record<string, string>;\n\n\tconstructor({\n\t\tcontents,\n\t\tidentifier,\n\t\ttags,\n\t}: {\n\t\tcontents: Uint8Array | Blob;\n\t\tidentifier?: string;\n\t\ttags?: Record<string, string>;\n\t}) {\n\t\tthis.#contents = contents;\n\t\tthis.#identifier = identifier ?? null;\n\t\tthis.#tags = tags ?? {};\n\t}\n\n\tasync getBytes() {\n\t\tif ('arrayBuffer' in this.#contents) {\n\t\t\treturn new Uint8Array(await this.#contents.arrayBuffer());\n\t\t}\n\n\t\treturn this.#contents;\n\t}\n\n\tasync getIdentifier() {\n\t\treturn this.#identifier;\n\t}\n\n\tasync getTags() {\n\t\treturn this.#tags;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { LocalReader } from './readers/local.js';\n\nexport interface FileReader {\n\tgetIdentifier(): Promise<string | null>;\n\tgetTags(): Promise<Record<string, string>>;\n\tgetBytes(): Promise<Uint8Array>;\n}\n\nexport class WalrusFile {\n\t#reader: FileReader;\n\n\tstatic from(options: {\n\t\tcontents: Uint8Array | Blob;\n\t\tidentifier: string;\n\t\ttags?: Record<string, string>;\n\t}) {\n\t\treturn new WalrusFile({\n\t\t\treader: new LocalReader(options),\n\t\t});\n\t}\n\n\tconstructor({ reader }: { reader: FileReader }) {\n\t\tthis.#reader = reader;\n\t}\n\n\tgetIdentifier() {\n\t\treturn this.#reader.getIdentifier();\n\t}\n\tgetTags() {\n\t\treturn this.#reader.getTags();\n\t}\n\n\tbytes() {\n\t\treturn this.#reader.getBytes();\n\t}\n\n\tasync text() {\n\t\tconst bytes = await this.bytes();\n\n\t\treturn new TextDecoder().decode(bytes);\n\t}\n\n\tasync json() {\n\t\treturn JSON.parse(await this.text());\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { WalrusClient } from '../client.js';\nimport type { BlobReader } from './readers/blob.js';\nimport { WalrusFile } from './file.js';\nimport { ClientCache } from '@mysten/sui/experimental';\n\nexport class WalrusBlob {\n\t#reader: BlobReader;\n\t#client: WalrusClient;\n\t#cache = new ClientCache();\n\n\tconstructor({ reader, client }: { reader: BlobReader; client: WalrusClient }) {\n\t\tthis.#reader = reader;\n\t\tthis.#client = client;\n\t}\n\n\t// Get the blob as a file (i.e. do not use Quilt encoding)\n\tasFile() {\n\t\treturn new WalrusFile({ reader: this.#reader });\n\t}\n\n\tasync blobId(): Promise<string | null> {\n\t\treturn this.#reader.blobId;\n\t}\n\n\t// Gets quilt-based files associated with this blob.\n\tasync files(\n\t\tfilters: {\n\t\t\tids?: string[];\n\t\t\ttags?: { [tagName: string]: string }[];\n\t\t\tidentifiers?: string[];\n\t\t} = {},\n\t) {\n\t\tconst quiltReader = await this.#reader.getQuiltReader();\n\t\tconst index = await quiltReader.readIndex();\n\n\t\tconst files = [];\n\n\t\tfor (const patch of index) {\n\t\t\tif (filters.ids && !filters.ids.includes(patch.patchId)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (filters.identifiers && !filters.identifiers.includes(patch.identifier)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tfilters.tags &&\n\t\t\t\t!filters.tags.some((tags) =>\n\t\t\t\t\tObject.entries(tags).every(([tagName, tagValue]) => patch.tags[tagName] === tagValue),\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfiles.push(new WalrusFile({ reader: quiltReader.readerForPatchId(patch.patchId) }));\n\t\t}\n\n\t\treturn files;\n\t}\n\n\tasync #blobStatus() {\n\t\treturn this.#cache.read(['blobStatus', this.#reader.blobId], () =>\n\t\t\tthis.#client.getVerifiedBlobStatus({ blobId: this.#reader.blobId }),\n\t\t);\n\t}\n\n\tasync exists() {\n\t\tconst status = await this.#blobStatus();\n\t\treturn status.type === 'permanent' || status.type === 'deletable';\n\t}\n\n\tasync storedUntil() {\n\t\tconst status = await this.#blobStatus();\n\n\t\tif (status.type === 'permanent') {\n\t\t\treturn status.endEpoch;\n\t\t}\n\n\t\treturn null;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport async function retry<T>(\n\tfn: () => Promise<T>,\n\toptions: {\n\t\tcondition?: (error: Error) => boolean;\n\t\tcount?: number;\n\t\tdelay?: number;\n\t\tjitter?: number;\n\t},\n): Promise<T> {\n\tlet remaining = options.count ?? 3;\n\n\twhile (remaining > 0) {\n\t\ttry {\n\t\t\tremaining -= 1;\n\t\t\treturn await fn();\n\t\t} catch (error) {\n\t\t\tif (remaining <= 0 || (options.condition && !options.condition(error as Error))) {\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tif (options.delay) {\n\t\t\t\tawait new Promise((resolve) =>\n\t\t\t\t\tsetTimeout(\n\t\t\t\t\t\tresolve,\n\t\t\t\t\t\t(options.delay ?? 1000) + (options.jitter ? Math.random() * options.jitter : 0),\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Should never be reached\n\tthrow new Error('Retry count exceeded');\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { InferBcsType } from '@mysten/bcs';\nimport { bcs } from '@mysten/bcs';\nimport { SuiClient } from '@mysten/sui/client';\nimport type { Signer } from '@mysten/sui/cryptography';\nimport type { ClientCache, ClientWithExtensions } from '@mysten/sui/experimental';\nimport type { TransactionObjectArgument, TransactionResult } from '@mysten/sui/transactions';\nimport { coinWithBalance, Transaction } from '@mysten/sui/transactions';\nimport { normalizeStructTag, parseStructTag } from '@mysten/sui/utils';\n\nimport {\n\tMAINNET_WALRUS_PACKAGE_CONFIG,\n\tstatusLifecycleRank,\n\tTESTNET_WALRUS_PACKAGE_CONFIG,\n} from './constants.js';\nimport {\n\taddMetadata,\n\tBlob,\n\tinsertOrUpdateMetadataPair,\n\tremoveMetadataPair,\n} from './contracts/walrus/blob.js';\nimport type { Committee } from './contracts/walrus/committee.js';\nimport * as metadata from './contracts/walrus/metadata.js';\nimport { StakingInnerV1 } from './contracts/walrus/staking_inner.js';\nimport { StakingPool } from './contracts/walrus/staking_pool.js';\nimport { Staking } from './contracts/walrus/staking.js';\nimport { Storage } from './contracts/walrus/storage_resource.js';\nimport { SystemStateInnerV1 } from './contracts/walrus/system_state_inner.js';\nimport {\n\tcertifyBlob,\n\tdeleteBlob,\n\textendBlob,\n\tregisterBlob,\n\treserveSpace,\n\tSystem,\n} from './contracts/walrus/system.js';\nimport {\n\tBehindCurrentEpochError,\n\tBlobBlockedError,\n\tBlobNotCertifiedError,\n\tInconsistentBlobError,\n\tNoBlobMetadataReceivedError,\n\tNoBlobStatusReceivedError,\n\tNotEnoughBlobConfirmationsError,\n\tNotEnoughSliversReceivedError,\n\tNoVerifiedBlobStatusReceivedError,\n\tRetryableWalrusClientError,\n\tWalrusClientError,\n} from './error.js';\nimport { StorageNodeClient } from './storage-node/client.js';\nimport {\n\tBlobNotRegisteredError,\n\tLegallyUnavailableError,\n\tNotFoundError,\n\tUserAbortError,\n} from './storage-node/error.js';\nimport type { BlobMetadataWithId, BlobStatus, GetSliverResponse } from './storage-node/types.js';\nimport type {\n\tCertifyBlobOptions,\n\tCommitteeInfo,\n\tComputeBlobMetadataOptions,\n\tDeleteBlobOptions,\n\tEncodingType,\n\tExtendBlobOptions,\n\tUploadRelayConfig,\n\tGetBlobMetadataOptions,\n\tGetCertificationEpochOptions,\n\tGetSecondarySliverOptions,\n\tGetSliversOptions,\n\tGetStorageConfirmationOptions,\n\tGetVerifiedBlobStatusOptions,\n\tProtocolMessageCertificate,\n\tReadBlobOptions,\n\tRegisterBlobOptions,\n\tSliversForNode,\n\tStorageNode,\n\tStorageWithSizeOptions,\n\tWalrusClientConfig,\n\tWalrusClientExtensionOptions,\n\tWalrusPackageConfig,\n\tWriteBlobAttributesOptions,\n\tWriteBlobOptions,\n\tWriteBlobToUploadRelayOptions,\n\tWriteEncodedBlobOptions,\n\tWriteEncodedBlobToNodesOptions,\n\tWriteMetadataOptions,\n\tWriteQuiltOptions,\n\tWriteSliverOptions,\n\tWriteSliversToNodeOptions,\n\tWriteFilesOptions,\n\tWriteFilesFlowOptions,\n\tWriteFilesFlow,\n\tWriteFilesFlowRegisterOptions,\n\tWriteFilesFlowUploadOptions,\n\tWriteBlobFlow,\n\tWriteBlobFlowOptions,\n\tWriteBlobFlowRegisterOptions,\n\tWriteBlobFlowUploadOptions,\n} from './types.js';\nimport { blobIdToInt, IntentType, SliverData, StorageConfirmation } from './utils/bcs.js';\nimport {\n\tencodedBlobLength,\n\tgetShardIndicesByNodeId,\n\tgetSourceSymbols,\n\tisAboveValidity,\n\tisQuorum,\n\tsignersToBitmap,\n\tsliverPairIndexFromSecondarySliverIndex,\n\tstorageUnitsFromSize,\n\ttoPairIndex,\n\ttoShardIndex,\n\ttoTypeString,\n} from './utils/index.js';\nimport { SuiObjectDataLoader } from './utils/object-loader.js';\nimport { shuffle, weightedShuffle } from './utils/randomness.js';\nimport { getWasmBindings } from './wasm.js';\nimport { chunk } from '@mysten/utils';\nimport { UploadRelayClient } from './upload-relay/client.js';\nimport { encodeQuilt, encodeQuiltPatchId, parseWalrusId } from './utils/quilts.js';\nimport { BlobReader } from './files/readers/blob.js';\nimport { WalrusBlob } from './files/blob.js';\nimport { WalrusFile } from './files/file.js';\nimport { QuiltFileReader } from './files/readers/quilt-file.js';\nimport { QuiltReader } from './files/readers/quilt.js';\nimport { retry } from './utils/retry.js';\n\nexport class WalrusClient {\n\t#storageNodeClient: StorageNodeClient;\n\t#wasmUrl: string | undefined;\n\n\t#packageConfig: WalrusPackageConfig;\n\t#suiClient: ClientWithExtensions<{\n\t\tjsonRpc: SuiClient;\n\t}>;\n\t#objectLoader: SuiObjectDataLoader;\n\n\t#blobMetadataConcurrencyLimit = 10;\n\t#readCommittee?: CommitteeInfo | Promise<CommitteeInfo> | null;\n\n\t#cache: ClientCache;\n\n\t#uploadRelayConfig: UploadRelayConfig | null = null;\n\t#uploadRelayClient: UploadRelayClient | null = null;\n\n\tconstructor(config: WalrusClientConfig) {\n\t\tif (config.network && !config.packageConfig) {\n\t\t\tconst network = config.network;\n\t\t\tswitch (network) {\n\t\t\t\tcase 'testnet':\n\t\t\t\t\tthis.#packageConfig = TESTNET_WALRUS_PACKAGE_CONFIG;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'mainnet':\n\t\t\t\t\tthis.#packageConfig = MAINNET_WALRUS_PACKAGE_CONFIG;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new WalrusClientError(`Unsupported network: ${network}`);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.#packageConfig = config.packageConfig!;\n\t\t}\n\n\t\tthis.#wasmUrl = config.wasmUrl;\n\t\tthis.#uploadRelayConfig = config.uploadRelay ?? null;\n\t\tif (this.#uploadRelayConfig) {\n\t\t\tthis.#uploadRelayClient = new UploadRelayClient(this.#uploadRelayConfig);\n\t\t}\n\n\t\tthis.#suiClient =\n\t\t\tconfig.suiClient ??\n\t\t\tnew SuiClient({\n\t\t\t\turl: config.suiRpcUrl,\n\t\t\t});\n\n\t\tthis.#storageNodeClient = new StorageNodeClient(config.storageNodeClientOptions);\n\t\tthis.#objectLoader = new SuiObjectDataLoader(this.#suiClient);\n\t\tthis.#cache = this.#suiClient.cache.scope('@mysten/walrus');\n\t}\n\n\tstatic experimental_asClientExtension({\n\t\tpackageConfig,\n\t\tnetwork,\n\t\t...options\n\t}: WalrusClientExtensionOptions = {}) {\n\t\treturn {\n\t\t\tname: 'walrus' as const,\n\t\t\tregister: (\n\t\t\t\tclient: ClientWithExtensions<{\n\t\t\t\t\tjsonRpc: SuiClient;\n\t\t\t\t}>,\n\t\t\t) => {\n\t\t\t\tconst walrusNetwork = network || client.network;\n\n\t\t\t\tif (walrusNetwork !== 'mainnet' && walrusNetwork !== 'testnet') {\n\t\t\t\t\tthrow new WalrusClientError('Walrus client only supports mainnet and testnet');\n\t\t\t\t}\n\n\t\t\t\treturn new WalrusClient(\n\t\t\t\t\tpackageConfig\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tpackageConfig,\n\t\t\t\t\t\t\t\tsuiClient: client,\n\t\t\t\t\t\t\t\t...options,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tnetwork: walrusNetwork as 'mainnet' | 'testnet',\n\t\t\t\t\t\t\t\tsuiClient: client,\n\t\t\t\t\t\t\t\t...options,\n\t\t\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t},\n\t\t};\n\t}\n\t/** The Move type for a WAL coin */\n\t#walType() {\n\t\treturn this.#cache.read(['walType'], async () => {\n\t\t\tconst stakedWal = await this.#suiClient.jsonRpc.getNormalizedMoveStruct({\n\t\t\t\tpackage: await this.#getPackageId(),\n\t\t\t\tmodule: 'staked_wal',\n\t\t\t\tstruct: 'StakedWal',\n\t\t\t});\n\n\t\t\tconst balanceType = stakedWal.fields.find((field) => field.name === 'principal')?.type;\n\n\t\t\tif (!balanceType) {\n\t\t\t\tthrow new WalrusClientError('WAL type not found');\n\t\t\t}\n\n\t\t\tconst parsed = parseStructTag(toTypeString(balanceType));\n\t\t\tconst coinType = parsed.typeParams[0];\n\n\t\t\tif (!coinType) {\n\t\t\t\tthrow new WalrusClientError('WAL type not found');\n\t\t\t}\n\n\t\t\treturn normalizeStructTag(coinType);\n\t\t});\n\t}\n\n\t#getPackageId() {\n\t\treturn this.#cache.read(['getPackageId'], async () => {\n\t\t\tconst system = await this.#objectLoader.load(this.#packageConfig.systemObjectId);\n\t\t\treturn parseStructTag(system.type!).address;\n\t\t});\n\t}\n\n\t/** The Move type for a Blob object */\n\tgetBlobType() {\n\t\treturn this.#cache.read(['getBlobType'], async () => {\n\t\t\treturn `${await this.#getPackageId()}::blob::Blob`;\n\t\t});\n\t}\n\n\t#getWalrusPackageId() {\n\t\treturn this.#cache.read(['getSystemPackageId'], async () => {\n\t\t\tconst { package_id } = await this.systemObject();\n\t\t\treturn package_id;\n\t\t});\n\t}\n\n\t#wasmBindings() {\n\t\treturn this.#cache.read(['wasmBindings'], async () => {\n\t\t\treturn getWasmBindings(this.#wasmUrl);\n\t\t});\n\t}\n\n\t/** The cached system object for the walrus package */\n\tsystemObject() {\n\t\treturn this.#objectLoader.load(this.#packageConfig.systemObjectId, System);\n\t}\n\n\t/** The cached staking pool object for the walrus package */\n\tstakingObject() {\n\t\treturn this.#objectLoader.load(this.#packageConfig.stakingPoolId, Staking);\n\t}\n\n\t/** The system state for the current version of walrus contract  */\n\tasync systemState() {\n\t\tconst systemState = await this.#objectLoader.loadFieldObject(\n\t\t\tthis.#packageConfig.systemObjectId,\n\t\t\t{ type: 'u64', value: (await this.systemObject()).version },\n\t\t\tSystemStateInnerV1,\n\t\t);\n\n\t\treturn systemState;\n\t}\n\n\t/** The staking state for the current version of walrus contract */\n\tasync stakingState() {\n\t\treturn this.#objectLoader.loadFieldObject(\n\t\t\tthis.#packageConfig.stakingPoolId,\n\t\t\t{\n\t\t\t\ttype: 'u64',\n\t\t\t\tvalue: (await this.stakingObject()).version,\n\t\t\t},\n\t\t\tStakingInnerV1,\n\t\t);\n\t}\n\n\t/** Read a blob from the storage nodes */\n\treadBlob = this.#retryOnPossibleEpochChange(this.#internalReadBlob);\n\n\tasync #internalReadBlob({ blobId, signal }: ReadBlobOptions) {\n\t\tconst systemState = await this.systemState();\n\t\tconst numShards = systemState.committee.n_shards;\n\n\t\tconst blobMetadata = await this.getBlobMetadata({ blobId, signal });\n\n\t\tconst slivers = await this.getSlivers({ blobId, signal });\n\n\t\tconst bindings = await this.#wasmBindings();\n\n\t\tconst blobBytes = bindings.decodePrimarySlivers(\n\t\t\tblobId,\n\t\t\tnumShards,\n\t\t\tblobMetadata.metadata.V1.unencoded_length,\n\t\t\tslivers,\n\t\t);\n\n\t\tconst reconstructedBlobMetadata = bindings.computeMetadata(\n\t\t\tsystemState.committee.n_shards,\n\t\t\tblobBytes,\n\t\t);\n\n\t\tif (reconstructedBlobMetadata.blobId !== blobId) {\n\t\t\tthrow new InconsistentBlobError('The specified blob was encoded incorrectly.');\n\t\t}\n\n\t\treturn blobBytes;\n\t}\n\n\tasync computeBlobMetadata({ bytes, numShards }: ComputeBlobMetadataOptions) {\n\t\tlet shardCount: number | undefined;\n\t\tif (typeof numShards === 'number') {\n\t\t\tshardCount = numShards;\n\t\t} else {\n\t\t\tconst systemState = await this.systemState();\n\t\t\tshardCount = systemState.committee.n_shards;\n\t\t}\n\n\t\tconst bindings = await this.#wasmBindings();\n\t\tconst { blobId, metadata, rootHash } = bindings.computeMetadata(shardCount, bytes);\n\t\tlet sha256Hash: Promise<Uint8Array> | undefined;\n\t\tconst nonce = crypto.getRandomValues(new Uint8Array(32));\n\n\t\treturn {\n\t\t\trootHash,\n\t\t\tblobId,\n\t\t\tmetadata: {\n\t\t\t\tencodingType: metadata.V1.encoding_type,\n\t\t\t\thashes: Array.from(metadata.V1.hashes).map((hashes) => ({\n\t\t\t\t\tprimaryHash: hashes.primary_hash,\n\t\t\t\t\tsecondaryHash: hashes.secondary_hash,\n\t\t\t\t})),\n\t\t\t\tunencodedLength: metadata.V1.unencoded_length,\n\t\t\t},\n\t\t\tnonce,\n\t\t\tblobDigest: () => {\n\t\t\t\tif (!sha256Hash) {\n\t\t\t\t\tsha256Hash = crypto.subtle.digest('SHA-256', bytes).then((hash) => new Uint8Array(hash));\n\t\t\t\t}\n\n\t\t\t\treturn sha256Hash;\n\t\t\t},\n\t\t};\n\t}\n\n\tasync getBlobMetadata({ blobId, signal }: GetBlobMetadataOptions) {\n\t\tconst committee = await this.#getReadCommittee({ blobId, signal });\n\t\tconst randomizedNodes = shuffle(committee.nodes);\n\n\t\tconst stakingState = await this.stakingState();\n\t\tconst numShards = stakingState.n_shards;\n\n\t\tlet numNotFoundWeight = 0;\n\t\tlet numBlockedWeight = 0;\n\t\tlet totalErrorCount = 0;\n\t\tconst controller = new AbortController();\n\n\t\tconst metadataExecutors = randomizedNodes.map((node) => async () => {\n\t\t\ttry {\n\t\t\t\treturn await this.#storageNodeClient.getBlobMetadata(\n\t\t\t\t\t{ blobId },\n\t\t\t\t\t{\n\t\t\t\t\t\tnodeUrl: node.networkUrl,\n\t\t\t\t\t\tsignal: signal ? AbortSignal.any([controller.signal, signal]) : controller.signal,\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof NotFoundError) {\n\t\t\t\t\tnumNotFoundWeight += node.shardIndices.length;\n\t\t\t\t} else if (error instanceof LegallyUnavailableError) {\n\t\t\t\t\tnumBlockedWeight += node.shardIndices.length;\n\t\t\t\t}\n\n\t\t\t\ttotalErrorCount += 1;\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t});\n\n\t\ttry {\n\t\t\tconst attemptGetMetadata = metadataExecutors.shift()!;\n\t\t\treturn await attemptGetMetadata();\n\t\t} catch (error) {\n\t\t\tconst chunkSize = Math.floor(metadataExecutors.length / this.#blobMetadataConcurrencyLimit);\n\t\t\tconst chunkedExecutors = chunk(metadataExecutors, chunkSize);\n\n\t\t\treturn await new Promise<BlobMetadataWithId>((resolve, reject) => {\n\t\t\t\tchunkedExecutors.forEach(async (executors) => {\n\t\t\t\t\tfor (const executor of executors) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst result = await executor();\n\t\t\t\t\t\t\tcontroller.abort('Blob metadata successfully retrieved.');\n\t\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\tif (error instanceof UserAbortError) {\n\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t} else if (isQuorum(numBlockedWeight + numNotFoundWeight, numShards)) {\n\t\t\t\t\t\t\t\tconst abortError =\n\t\t\t\t\t\t\t\t\tnumNotFoundWeight > numBlockedWeight\n\t\t\t\t\t\t\t\t\t\t? new BlobNotCertifiedError(`The specified blob ${blobId} is not certified.`)\n\t\t\t\t\t\t\t\t\t\t: new BlobBlockedError(`The specified blob ${blobId} is blocked.`);\n\n\t\t\t\t\t\t\t\tcontroller.abort(abortError);\n\t\t\t\t\t\t\t\treject(abortError);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (totalErrorCount === metadataExecutors.length) {\n\t\t\t\t\t\t\t\treject(\n\t\t\t\t\t\t\t\t\tnew NoBlobMetadataReceivedError(\n\t\t\t\t\t\t\t\t\t\t'No valid blob metadata could be retrieved from any storage node.',\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n\n\tgetSecondarySliver = this.#retryOnPossibleEpochChange(this.internalGetSecondarySliver);\n\n\tasync internalGetSecondarySliver({ blobId, index, signal }: GetSecondarySliverOptions) {\n\t\tconst committee = await this.#getActiveCommittee();\n\t\tconst stakingState = await this.stakingState();\n\t\tconst numShards = stakingState.n_shards;\n\t\tconst sliverPairIndex = sliverPairIndexFromSecondarySliverIndex(index, numShards);\n\t\tconst shardIndex = toShardIndex(sliverPairIndex, blobId, numShards);\n\t\tconst node = await this.#getNodeByShardIndex(committee, shardIndex);\n\n\t\tif (!node) {\n\t\t\tthrow new Error(`No node found for shard index ${shardIndex}`);\n\t\t}\n\n\t\tconst sliver = await this.#storageNodeClient.getSliver(\n\t\t\t{ blobId, sliverPairIndex, sliverType: 'secondary' },\n\t\t\t{\n\t\t\t\tnodeUrl: node.networkUrl,\n\t\t\t\tsignal,\n\t\t\t},\n\t\t);\n\n\t\treturn sliver;\n\t}\n\n\tasync getSlivers({ blobId, signal }: GetSliversOptions) {\n\t\tconst committee = await this.#getReadCommittee({ blobId, signal });\n\t\tconst randomizedNodes = weightedShuffle(\n\t\t\tcommittee.nodes.map((node) => ({\n\t\t\t\tvalue: node,\n\t\t\t\tweight: node.shardIndices.length,\n\t\t\t})),\n\t\t);\n\n\t\tconst stakingState = await this.stakingState();\n\t\tconst numShards = stakingState.n_shards;\n\t\tconst { primarySymbols: minSymbols } = getSourceSymbols(numShards);\n\n\t\tconst sliverPairIndices = randomizedNodes.flatMap((node) =>\n\t\t\tnode.shardIndices.map((shardIndex) => ({\n\t\t\t\turl: node.networkUrl,\n\t\t\t\tsliverPairIndex: toPairIndex(shardIndex, blobId, numShards),\n\t\t\t})),\n\t\t);\n\n\t\tconst controller = new AbortController();\n\t\tconst chunkedSliverPairIndices = chunk(sliverPairIndices, minSymbols);\n\t\tconst slivers: GetSliverResponse[] = [];\n\t\tconst failedNodes = new Set<string>();\n\t\tlet numNotFoundWeight = 0;\n\t\tlet numBlockedWeight = 0;\n\t\tlet totalErrorCount = 0;\n\n\t\treturn new Promise<GetSliverResponse[]>((resolve, reject) => {\n\t\t\tchunkedSliverPairIndices[0].forEach(async (_, colIndex) => {\n\t\t\t\tfor (let rowIndex = 0; rowIndex < chunkedSliverPairIndices.length; rowIndex += 1) {\n\t\t\t\t\tconst value = chunkedSliverPairIndices.at(rowIndex)?.at(colIndex);\n\t\t\t\t\tif (!value) break;\n\n\t\t\t\t\tconst { url, sliverPairIndex } = value;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (failedNodes.has(url)) {\n\t\t\t\t\t\t\tthrow new Error(`Skipping node at ${url} due to previous failure.`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst sliver = await this.#storageNodeClient.getSliver(\n\t\t\t\t\t\t\t{ blobId, sliverPairIndex, sliverType: 'primary' },\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnodeUrl: url,\n\t\t\t\t\t\t\t\tsignal: signal ? AbortSignal.any([controller.signal, signal]) : controller.signal,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (slivers.length === minSymbols) {\n\t\t\t\t\t\t\tcontroller.abort('Enough slivers successfully retrieved.');\n\t\t\t\t\t\t\tresolve(slivers);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tslivers.push(sliver);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tif (error instanceof NotFoundError) {\n\t\t\t\t\t\t\tnumNotFoundWeight += 1;\n\t\t\t\t\t\t} else if (error instanceof LegallyUnavailableError) {\n\t\t\t\t\t\t\tnumBlockedWeight += 1;\n\t\t\t\t\t\t} else if (error instanceof UserAbortError) {\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isQuorum(numBlockedWeight + numNotFoundWeight, numShards)) {\n\t\t\t\t\t\t\tconst abortError =\n\t\t\t\t\t\t\t\tnumNotFoundWeight > numBlockedWeight\n\t\t\t\t\t\t\t\t\t? new BlobNotCertifiedError(`The specified blob ${blobId} is not certified.`)\n\t\t\t\t\t\t\t\t\t: new BlobBlockedError(`The specified blob ${blobId} is blocked.`);\n\n\t\t\t\t\t\t\tcontroller.abort(abortError);\n\t\t\t\t\t\t\treject(abortError);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfailedNodes.add(url);\n\t\t\t\t\t\ttotalErrorCount += 1;\n\n\t\t\t\t\t\tconst remainingTasks = sliverPairIndices.length - (slivers.length + totalErrorCount);\n\t\t\t\t\t\tconst tooManyFailures = slivers.length + remainingTasks < minSymbols;\n\n\t\t\t\t\t\tif (tooManyFailures) {\n\t\t\t\t\t\t\tconst abortError = new NotEnoughSliversReceivedError(\n\t\t\t\t\t\t\t\t`Unable to retrieve enough slivers to decode blob ${blobId}.`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontroller.abort(abortError);\n\t\t\t\t\t\t\treject(abortError);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Gets the blob status from multiple storage nodes and returns the latest status that can be verified.\n\t */\n\tasync getVerifiedBlobStatus({ blobId, signal }: GetVerifiedBlobStatusOptions) {\n\t\t// Read from the latest committee because, during epoch change, it is the committee\n\t\t// that will have the most up-to-date information on old and newly certified blobs:\n\t\tconst committee = await this.#getActiveCommittee();\n\t\tconst stakingState = await this.stakingState();\n\t\tconst numShards = stakingState.n_shards;\n\t\tconst controller = new AbortController();\n\n\t\tconst statuses = await new Promise<{ status: BlobStatus; weight: number }[]>(\n\t\t\t(resolve, reject) => {\n\t\t\t\tconst results: { status: BlobStatus; weight: number }[] = [];\n\t\t\t\tlet successWeight = 0;\n\t\t\t\tlet numNotFoundWeight = 0;\n\t\t\t\tlet settledCount = 0;\n\n\t\t\t\tcommittee.nodes.forEach(async (node) => {\n\t\t\t\t\tconst weight = node.shardIndices.length;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst status = await this.#storageNodeClient.getBlobStatus(\n\t\t\t\t\t\t\t{ blobId },\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnodeUrl: node.networkUrl,\n\t\t\t\t\t\t\t\tsignal: signal ? AbortSignal.any([controller.signal, signal]) : controller.signal,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (isQuorum(successWeight, numShards)) {\n\t\t\t\t\t\t\tcontroller.abort('Quorum of blob statuses retrieved successfully.');\n\t\t\t\t\t\t\tresolve(results);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsuccessWeight += weight;\n\t\t\t\t\t\t\tresults.push({ status, weight });\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tif (error instanceof NotFoundError) {\n\t\t\t\t\t\t\tnumNotFoundWeight += weight;\n\t\t\t\t\t\t} else if (error instanceof UserAbortError) {\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isQuorum(numNotFoundWeight, numShards)) {\n\t\t\t\t\t\t\tconst abortError = new BlobNotCertifiedError('The blob does not exist.');\n\t\t\t\t\t\t\tcontroller.abort(abortError);\n\t\t\t\t\t\t\treject(abortError);\n\t\t\t\t\t\t}\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tsettledCount += 1;\n\t\t\t\t\t\tif (settledCount === committee.nodes.length) {\n\t\t\t\t\t\t\treject(\n\t\t\t\t\t\t\t\tnew NoBlobStatusReceivedError(\n\t\t\t\t\t\t\t\t\t'Not enough statuses were retrieved to achieve quorum.',\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t);\n\n\t\tconst aggregatedStatuses = statuses.reduce((accumulator, value) => {\n\t\t\tconst { status, weight } = value;\n\t\t\tconst key = JSON.stringify(status);\n\n\t\t\tconst existing = accumulator.get(key);\n\t\t\tif (existing) {\n\t\t\t\texisting.totalWeight += weight;\n\t\t\t} else {\n\t\t\t\taccumulator.set(key, { status, totalWeight: weight });\n\t\t\t}\n\n\t\t\treturn accumulator;\n\t\t}, new Map<string, { status: BlobStatus; totalWeight: number }>());\n\n\t\tconst uniqueStatuses = [...aggregatedStatuses.values()];\n\t\tconst sortedStatuses = uniqueStatuses.toSorted(\n\t\t\t(a, b) => statusLifecycleRank[b.status.type] - statusLifecycleRank[a.status.type],\n\t\t);\n\n\t\tfor (const value of sortedStatuses) {\n\t\t\t// TODO: We can check the chain via the `event` field as a fallback here.\n\t\t\tif (isAboveValidity(value.totalWeight, numShards)) {\n\t\t\t\treturn value.status;\n\t\t\t}\n\t\t}\n\n\t\tthrow new NoVerifiedBlobStatusReceivedError(\n\t\t\t`The blob status could not be verified for blob ${blobId},`,\n\t\t);\n\t}\n\n\tasync #getCertificationEpoch({ blobId, signal }: GetCertificationEpochOptions) {\n\t\tconst stakingState = await this.stakingState();\n\t\tconst currentEpoch = stakingState.epoch;\n\n\t\tif (stakingState.epoch_state.$kind === 'EpochChangeSync') {\n\t\t\tconst status = await this.getVerifiedBlobStatus({ blobId, signal });\n\t\t\tif (status.type === 'nonexistent' || status.type === 'invalid') {\n\t\t\t\tthrow new BlobNotCertifiedError(`The specified blob ${blobId} is ${status.type}.`);\n\t\t\t}\n\n\t\t\tif (typeof status.initialCertifiedEpoch !== 'number') {\n\t\t\t\tthrow new BlobNotCertifiedError(`The specified blob ${blobId} is not certified.`);\n\t\t\t}\n\n\t\t\tif (status.initialCertifiedEpoch > currentEpoch) {\n\t\t\t\tthrow new BehindCurrentEpochError(\n\t\t\t\t\t`The client is at epoch ${currentEpoch} while the specified blob was certified at epoch ${status.initialCertifiedEpoch}.`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn status.initialCertifiedEpoch;\n\t\t}\n\n\t\treturn currentEpoch;\n\t}\n\n\t/**\n\t * Retrieves the node committee responsible for serving reads.\n\t *\n\t * During an epoch change, reads should be served by the previous committee if the blob was\n\t * certified in an earlier epoch. This ensures that we read from nodes with the most accurate\n\t * information as nodes from the current committee might still be receiving transferred shards\n\t * from the previous committee.\n\t */\n\tasync #getReadCommittee(options: ReadBlobOptions) {\n\t\tif (!this.#readCommittee) {\n\t\t\tthis.#readCommittee = this.#forceGetReadCommittee(options);\n\t\t}\n\t\treturn this.#readCommittee;\n\t}\n\n\tasync #forceGetReadCommittee({ blobId, signal }: ReadBlobOptions) {\n\t\tconst stakingState = await this.stakingState();\n\t\tconst isTransitioning = stakingState.epoch_state.$kind === 'EpochChangeSync';\n\t\tconst certificationEpoch = await this.#getCertificationEpoch({ blobId, signal });\n\n\t\tif (isTransitioning && certificationEpoch < stakingState.epoch) {\n\t\t\treturn await this.#getCommittee(stakingState.previous_committee);\n\t\t}\n\t\treturn await this.#getActiveCommittee();\n\t}\n\n\t/**\n\t * Calculate the cost of storing a blob for a given a size and number of epochs.\n\t */\n\tasync storageCost(size: number, epochs: number) {\n\t\tconst systemState = await this.systemState();\n\t\tconst encodedSize = encodedBlobLength(size, systemState.committee.n_shards);\n\t\tconst storageUnits = storageUnitsFromSize(encodedSize);\n\t\tconst storageCost =\n\t\t\tBigInt(storageUnits) * BigInt(systemState.storage_price_per_unit_size) * BigInt(epochs);\n\t\tBigInt(epochs);\n\n\t\tconst writeCost = BigInt(storageUnits) * BigInt(systemState.write_price_per_unit_size);\n\n\t\treturn { storageCost, writeCost, totalCost: storageCost + writeCost };\n\t}\n\n\t/**\n\t * A utility for creating a storage object in a transaction.\n\t *\n\t * @usage\n\t * ```ts\n\t * tx.transferObjects([client.createStorage({ size: 1000, epochs: 3 })], owner);\n\t * ```\n\t */\n\tcreateStorage({ size, epochs, walCoin }: StorageWithSizeOptions) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst systemObject = await this.systemObject();\n\t\t\tconst systemState = await this.systemState();\n\t\t\tconst encodedSize = encodedBlobLength(size, systemState.committee.n_shards);\n\t\t\tconst [{ storageCost }, walrusPackageId] = await Promise.all([\n\t\t\t\tthis.storageCost(size, epochs),\n\t\t\t\tthis.#getWalrusPackageId(),\n\t\t\t]);\n\n\t\t\treturn tx.add(\n\t\t\t\tthis.#withWal(storageCost, walCoin ?? null, (coin, tx) => {\n\t\t\t\t\treturn tx.add(\n\t\t\t\t\t\treserveSpace({\n\t\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\t\tself: systemObject.id.id,\n\t\t\t\t\t\t\t\tstorageAmount: encodedSize,\n\t\t\t\t\t\t\t\tepochsAhead: epochs,\n\t\t\t\t\t\t\t\tpayment: coin,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}),\n\t\t\t);\n\t\t};\n\t}\n\n\t#withWal<T extends TransactionResult | void>(\n\t\tamount: bigint,\n\t\tsource: TransactionObjectArgument | null,\n\t\tfn: (coin: TransactionObjectArgument, tx: Transaction) => T | Promise<T>,\n\t) {\n\t\treturn async (tx: Transaction): Promise<T> => {\n\t\t\tconst walType = await this.#walType();\n\t\t\tconst coin = source\n\t\t\t\t? tx.splitCoins(source, [amount])[0]\n\t\t\t\t: tx.add(\n\t\t\t\t\t\tcoinWithBalance({\n\t\t\t\t\t\t\tbalance: amount,\n\t\t\t\t\t\t\ttype: walType,\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\n\t\t\tconst result = await fn(coin, tx);\n\n\t\t\ttx.moveCall({\n\t\t\t\ttarget: '0x2::coin::destroy_zero',\n\t\t\t\ttypeArguments: [walType],\n\t\t\t\targuments: [coin],\n\t\t\t});\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\t/**\n\t * Create a transaction that creates a storage object\n\t *\n\t * @usage\n\t * ```ts\n\t * const tx = client.createStorageTransaction({ size: 1000, epochs: 3, owner: signer.toSuiAddress() });\n\t * ```\n\t */\n\tcreateStorageTransaction({\n\t\ttransaction = new Transaction(),\n\t\tsize,\n\t\tepochs,\n\t\towner,\n\t}: StorageWithSizeOptions & {\n\t\ttransaction?: Transaction;\n\t\t/** Address the storage resource should be transferred to */\n\t\towner: string;\n\t}) {\n\t\ttransaction.transferObjects([this.createStorage({ size, epochs })], owner);\n\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Execute a transaction that creates a storage object\n\t *\n\t * @usage\n\t * ```ts\n\t * const { digest, storage } = await client.executeCreateStorageTransaction({ size: 1000, epochs: 3, signer });\n\t * ```\n\t */\n\tasync executeCreateStorageTransaction({\n\t\tsigner,\n\t\t...options\n\t}: StorageWithSizeOptions & { transaction?: Transaction; signer: Signer }) {\n\t\tconst transaction = this.createStorageTransaction({\n\t\t\t...options,\n\t\t\towner: options.transaction?.getData().sender ?? signer.toSuiAddress(),\n\t\t});\n\t\tconst blobType = await this.getBlobType();\n\n\t\tconst { digest, effects } = await this.#executeTransaction(\n\t\t\ttransaction,\n\t\t\tsigner,\n\t\t\t'create storage',\n\t\t);\n\n\t\tconst createdObjectIds = effects?.changedObjects\n\t\t\t.filter((object) => object.idOperation === 'Created')\n\t\t\t.map((object) => object.id);\n\n\t\tconst createdObjects = await this.#suiClient.core.getObjects({\n\t\t\tobjectIds: createdObjectIds,\n\t\t});\n\n\t\tconst suiBlobObject = createdObjects.objects.find(\n\t\t\t(object) => !(object instanceof Error) && object.type === blobType,\n\t\t);\n\n\t\tif (suiBlobObject instanceof Error || !suiBlobObject) {\n\t\t\tthrow new WalrusClientError(\n\t\t\t\t`Storage object not found in transaction effects for transaction (${digest})`,\n\t\t\t);\n\t\t}\n\n\t\treturn {\n\t\t\tdigest,\n\t\t\tstorage: Storage.parse(await suiBlobObject.content),\n\t\t};\n\t}\n\n\t/**\n\t * Register a blob in a transaction\n\t *\n\t * @usage\n\t * ```ts\n\t * tx.transferObjects([client.registerBlob({ size: 1000, epochs: 3, blobId, rootHash, deletable: true })], owner);\n\t * ```\n\t */\n\tregisterBlob({\n\t\tsize,\n\t\tepochs,\n\t\tblobId,\n\t\trootHash,\n\t\tdeletable,\n\t\twalCoin,\n\t\tattributes,\n\t}: RegisterBlobOptions) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst { writeCost } = await this.storageCost(size, epochs);\n\t\t\tconst walrusPackageId = await this.#getWalrusPackageId();\n\n\t\t\treturn tx.add(\n\t\t\t\tthis.#withWal(writeCost, walCoin ?? null, async (writeCoin, tx) => {\n\t\t\t\t\tconst blob = tx.add(\n\t\t\t\t\t\tregisterBlob({\n\t\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\t\tself: tx.object(this.#packageConfig.systemObjectId),\n\t\t\t\t\t\t\t\tstorage: this.createStorage({ size, epochs, walCoin }),\n\t\t\t\t\t\t\t\tblobId: blobIdToInt(blobId),\n\t\t\t\t\t\t\t\trootHash: BigInt(bcs.u256().parse(rootHash)),\n\t\t\t\t\t\t\t\tsize,\n\t\t\t\t\t\t\t\tencodingType: 1,\n\t\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t\t\twritePayment: writeCoin,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\n\t\t\t\t\tif (attributes) {\n\t\t\t\t\t\ttx.add(\n\t\t\t\t\t\t\tthis.#writeBlobAttributesForRef({\n\t\t\t\t\t\t\t\tattributes,\n\t\t\t\t\t\t\t\texistingAttributes: null,\n\t\t\t\t\t\t\t\tblob,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn blob;\n\t\t\t\t}),\n\t\t\t);\n\t\t};\n\t}\n\n\taddAuthPayload({\n\t\tsize,\n\t\tblobDigest,\n\t\tnonce,\n\t}: {\n\t\tsize: number;\n\t\tblobDigest: Uint8Array | (() => Promise<Uint8Array>);\n\t\tnonce: Uint8Array;\n\t}) {\n\t\treturn async (transaction: Transaction) => {\n\t\t\tconst nonceDigest = await crypto.subtle.digest('SHA-256', nonce);\n\t\t\tconst lengthBytes = bcs.u64().serialize(size).toBytes();\n\t\t\tconst digest = typeof blobDigest === 'function' ? await blobDigest() : blobDigest;\n\t\t\tconst authPayload = new Uint8Array(\n\t\t\t\tnonceDigest.byteLength + digest.byteLength + lengthBytes.byteLength,\n\t\t\t);\n\n\t\t\tauthPayload.set(digest, 0);\n\t\t\tauthPayload.set(new Uint8Array(nonceDigest), digest.byteLength);\n\t\t\tauthPayload.set(lengthBytes, nonceDigest.byteLength + digest.byteLength);\n\t\t\ttransaction.pure(authPayload);\n\t\t};\n\t}\n\n\t#loadTipConfig() {\n\t\treturn this.#cache.read(['upload-relay-tip-config'], async () => {\n\t\t\tif (!this.#uploadRelayConfig?.sendTip || !this.#uploadRelayClient) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ('kind' in this.#uploadRelayConfig.sendTip) {\n\t\t\t\treturn this.#uploadRelayConfig.sendTip;\n\t\t\t}\n\n\t\t\tconst tipConfig = await this.#uploadRelayClient.tipConfig();\n\n\t\t\tif (!tipConfig) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t...tipConfig,\n\t\t\t\tmax: this.#uploadRelayConfig.sendTip.max,\n\t\t\t};\n\t\t});\n\t}\n\n\tasync calculateUploadRelayTip(options: { size: number }) {\n\t\tconst systemState = await this.systemState();\n\t\tconst encodedSize = encodedBlobLength(options.size, systemState.committee.n_shards);\n\t\tconst tipConfig = await this.#loadTipConfig();\n\n\t\tif (!tipConfig) {\n\t\t\treturn 0n;\n\t\t}\n\n\t\tconst { max, kind } = tipConfig;\n\n\t\tconst amount =\n\t\t\t'const' in kind\n\t\t\t\t? kind.const\n\t\t\t\t: BigInt(kind.linear.base) +\n\t\t\t\t\tBigInt(kind.linear.perEncodedKib) * ((BigInt(encodedSize) + 1023n) / 1024n); // Compute the ceiling of the division.\n\n\t\tif (max != null && amount > max) {\n\t\t\tthrow new WalrusClientError(\n\t\t\t\t`Tip amount (${amount}) exceeds the maximum allowed tip (${max})`,\n\t\t\t);\n\t\t}\n\n\t\treturn amount;\n\t}\n\n\tsendUploadRelayTip({\n\t\tsize,\n\t\tblobDigest,\n\t\tnonce,\n\t}: {\n\t\tsize: number;\n\t\tblobDigest: Uint8Array | (() => Promise<Uint8Array>);\n\t\tnonce: Uint8Array;\n\t}) {\n\t\treturn async (transaction: Transaction) => {\n\t\t\tconst tipConfig = await this.#loadTipConfig();\n\n\t\t\tif (tipConfig) {\n\t\t\t\ttransaction.add(this.addAuthPayload({ size, blobDigest, nonce }));\n\t\t\t\tconst amount = await this.calculateUploadRelayTip({ size });\n\t\t\t\tconst { address } = tipConfig;\n\t\t\t\ttransaction.transferObjects(\n\t\t\t\t\t[\n\t\t\t\t\t\tcoinWithBalance({\n\t\t\t\t\t\t\tbalance: amount,\n\t\t\t\t\t\t}),\n\t\t\t\t\t],\n\t\t\t\t\taddress,\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Create a transaction that registers a blob\n\t *\n\t * @usage\n\t * ```ts\n\t * const tx = client.registerBlobTransaction({ size: 1000, epochs: 3, blobId, rootHash, deletable: true });\n\t * ```\n\t */\n\tregisterBlobTransaction({\n\t\ttransaction = new Transaction(),\n\t\t...options\n\t}: RegisterBlobOptions & {\n\t\ttransaction?: Transaction;\n\t\t/** Address the blob should be transferred to */\n\t\towner: string;\n\t}) {\n\t\tconst registration = transaction.add(this.registerBlob(options));\n\n\t\ttransaction.transferObjects([registration], options.owner);\n\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Execute a transaction that registers a blob\n\t *\n\t * @usage\n\t * ```ts\n\t * const { digest, blob } = await client.executeRegisterBlobTransaction({ size: 1000, epochs: 3, signer });\n\t * ```\n\t */\n\tasync executeRegisterBlobTransaction({\n\t\tsigner,\n\t\t...options\n\t}: RegisterBlobOptions & {\n\t\ttransaction?: Transaction;\n\t\tsigner: Signer;\n\t\t/** Address the blob should be transferred to */\n\t\towner?: string;\n\t}): Promise<{\n\t\tblob: (typeof Blob)['$inferType'];\n\t\tdigest: string;\n\t}> {\n\t\tconst transaction = this.registerBlobTransaction({\n\t\t\t...options,\n\t\t\towner: options.owner ?? options.transaction?.getData().sender ?? signer.toSuiAddress(),\n\t\t});\n\t\tconst blobType = await this.getBlobType();\n\t\tconst { digest, effects } = await this.#executeTransaction(\n\t\t\ttransaction,\n\t\t\tsigner,\n\t\t\t'register blob',\n\t\t);\n\n\t\tconst createdObjectIds = effects?.changedObjects\n\t\t\t.filter((object) => object.idOperation === 'Created')\n\t\t\t.map((object) => object.id);\n\n\t\tconst createdObjects = await this.#suiClient.core.getObjects({\n\t\t\tobjectIds: createdObjectIds,\n\t\t});\n\n\t\tconst suiBlobObject = createdObjects.objects.find(\n\t\t\t(object) => !(object instanceof Error) && object.type === blobType,\n\t\t);\n\n\t\tif (suiBlobObject instanceof Error || !suiBlobObject) {\n\t\t\tthrow new WalrusClientError(\n\t\t\t\t`Blob object not found in transaction effects for transaction (${digest})`,\n\t\t\t);\n\t\t}\n\n\t\treturn {\n\t\t\tdigest,\n\t\t\tblob: Blob.parse(await suiBlobObject.content),\n\t\t};\n\t}\n\n\tasync #getCreatedBlob(digest: string) {\n\t\tconst blobType = await this.getBlobType();\n\t\tconst {\n\t\t\ttransaction: { effects },\n\t\t} = await this.#suiClient.core.waitForTransaction({\n\t\t\tdigest,\n\t\t});\n\n\t\tconst createdObjectIds = effects?.changedObjects\n\t\t\t.filter((object) => object.idOperation === 'Created')\n\t\t\t.map((object) => object.id);\n\n\t\tconst createdObjects = await this.#suiClient.core.getObjects({\n\t\t\tobjectIds: createdObjectIds,\n\t\t});\n\n\t\tconst suiBlobObject = createdObjects.objects.find(\n\t\t\t(object) => !(object instanceof Error) && object.type === blobType,\n\t\t);\n\n\t\tif (suiBlobObject instanceof Error || !suiBlobObject) {\n\t\t\tthrow new WalrusClientError(\n\t\t\t\t`Blob object not found in transaction effects for transaction (${digest})`,\n\t\t\t);\n\t\t}\n\n\t\treturn Blob.parse(await suiBlobObject.content);\n\t}\n\n\tasync certificateFromConfirmations({\n\t\tconfirmations,\n\t\tblobId,\n\t\tdeletable,\n\t\tblobObjectId,\n\t}: Extract<\n\t\tCertifyBlobOptions,\n\t\t{ confirmations: unknown[] }\n\t>): Promise<ProtocolMessageCertificate> {\n\t\tconst systemState = await this.systemState();\n\t\tconst committee = await this.#getActiveCommittee();\n\n\t\tif (confirmations.length !== systemState.committee.members.length) {\n\t\t\tthrow new WalrusClientError(\n\t\t\t\t'Invalid number of confirmations. Confirmations array must contain an entry for each node',\n\t\t\t);\n\t\t}\n\n\t\tconst confirmationMessage = StorageConfirmation.serialize({\n\t\t\tintent: IntentType.BLOB_CERT_MSG,\n\t\t\tepoch: systemState.committee.epoch,\n\t\t\tmessageContents: {\n\t\t\t\tblobId,\n\t\t\t\tblobType: deletable\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tDeletable: {\n\t\t\t\t\t\t\t\tobjectId: blobObjectId,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tPermanent: null,\n\t\t\t\t\t\t},\n\t\t\t},\n\t\t}).toBase64();\n\n\t\tconst bindings = await this.#wasmBindings();\n\t\tconst verifySignature = bindings.getVerifySignature();\n\n\t\tconst filteredConfirmations = confirmations\n\t\t\t.map((confirmation, index) => {\n\t\t\t\tconst isValid =\n\t\t\t\t\tconfirmation?.serializedMessage === confirmationMessage &&\n\t\t\t\t\tverifySignature(\n\t\t\t\t\t\tconfirmation,\n\t\t\t\t\t\tnew Uint8Array(committee.nodes[index].info.public_key.bytes),\n\t\t\t\t\t);\n\n\t\t\t\treturn isValid\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tindex,\n\t\t\t\t\t\t\t...confirmation,\n\t\t\t\t\t\t}\n\t\t\t\t\t: null;\n\t\t\t})\n\t\t\t.filter((confirmation) => confirmation !== null);\n\n\t\tif (!isQuorum(filteredConfirmations.length, systemState.committee.members.length)) {\n\t\t\tthrow new NotEnoughBlobConfirmationsError(\n\t\t\t\t`Too many invalid confirmations received for blob (${filteredConfirmations.length} of ${systemState.committee.members.length})`,\n\t\t\t);\n\t\t}\n\n\t\treturn bindings.combineSignatures(\n\t\t\tfilteredConfirmations,\n\t\t\tfilteredConfirmations.map(({ index }) => index),\n\t\t);\n\t}\n\n\t/**\n\t * Certify a blob in a transaction\n\t *\n\t * @usage\n\t * ```ts\n\t * tx.add(client.certifyBlob({ blobId, blobObjectId, confirmations }));\n\t * ```\n\t */\n\tcertifyBlob({ blobId, blobObjectId, confirmations, certificate, deletable }: CertifyBlobOptions) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst systemState = await this.systemState();\n\t\t\tconst combinedSignature =\n\t\t\t\tcertificate ??\n\t\t\t\t(await this.certificateFromConfirmations({\n\t\t\t\t\tconfirmations,\n\t\t\t\t\tblobId,\n\t\t\t\t\tdeletable,\n\t\t\t\t\tblobObjectId,\n\t\t\t\t}));\n\n\t\t\tconst walrusPackageId = await this.#getWalrusPackageId();\n\n\t\t\ttx.add(\n\t\t\t\tcertifyBlob({\n\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\targuments: {\n\t\t\t\t\t\tself: this.#packageConfig.systemObjectId,\n\t\t\t\t\t\tblob: blobObjectId,\n\t\t\t\t\t\tsignature: tx.pure.vector('u8', combinedSignature.signature),\n\t\t\t\t\t\tsignersBitmap: tx.pure.vector(\n\t\t\t\t\t\t\t'u8',\n\t\t\t\t\t\t\tsignersToBitmap(combinedSignature.signers, systemState.committee.members.length),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tmessage: tx.pure.vector('u8', combinedSignature.serializedMessage),\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t);\n\t\t};\n\t}\n\n\t/**\n\t * Create a transaction that certifies a blob\n\t *\n\t * @usage\n\t * ```ts\n\t * const tx = client.certifyBlobTransaction({ blobId, blobObjectId, confirmations });\n\t * ```\n\t */\n\tcertifyBlobTransaction({\n\t\ttransaction = new Transaction(),\n\t\t...options\n\t}: CertifyBlobOptions & {\n\t\ttransaction?: Transaction;\n\t}) {\n\t\ttransaction.add(this.certifyBlob(options));\n\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Execute a transaction that certifies a blob\n\t *\n\t * @usage\n\t * ```ts\n\t * const { digest } = await client.executeCertifyBlobTransaction({ blobId, blobObjectId, confirmations, signer });\n\t * ```\n\t */\n\tasync executeCertifyBlobTransaction({\n\t\tsigner,\n\t\t...options\n\t}: CertifyBlobOptions & {\n\t\ttransaction?: Transaction;\n\t\tsigner: Signer;\n\t}) {\n\t\tconst transaction = this.certifyBlobTransaction(options);\n\n\t\tconst { digest } = await this.#executeTransaction(transaction, signer, 'certify blob');\n\n\t\treturn { digest };\n\t}\n\n\t/**\n\t * Delete a blob in a transaction\n\t *\n\t * @usage\n\t * ```ts\n\t * const storage = await client.deleteBlob({ blobObjectId });\n\t * tx.transferObjects([storage], owner);\n\t * ```\n\t */\n\tdeleteBlob({ blobObjectId }: DeleteBlobOptions) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst walrusPackageId = await this.#getWalrusPackageId();\n\t\t\tconst storage = tx.add(\n\t\t\t\tdeleteBlob({\n\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\targuments: {\n\t\t\t\t\t\tself: this.#packageConfig.systemObjectId,\n\t\t\t\t\t\tblob: blobObjectId,\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\treturn storage;\n\t\t};\n\t}\n\n\t/**\n\t * Create a transaction that deletes a blob\n\t *\n\t * @usage\n\t * ```ts\n\t * const tx = client.deleteBlobTransaction({ blobObjectId, owner });\n\t * ```\n\t */\n\tdeleteBlobTransaction({\n\t\towner,\n\t\tblobObjectId,\n\t\ttransaction = new Transaction(),\n\t}: DeleteBlobOptions & {\n\t\ttransaction?: Transaction;\n\t\t/** Address the storage resource should be returned to */\n\t\towner: string;\n\t}) {\n\t\tconst storage = transaction.add(this.deleteBlob({ blobObjectId }));\n\t\ttransaction.transferObjects([storage], owner);\n\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Execute a transaction that deletes a blob\n\t *\n\t * @usage\n\t * ```ts\n\t * const { digest } = await client.executeDeleteBlobTransaction({ blobObjectId, signer });\n\t * ```\n\t */\n\tasync executeDeleteBlobTransaction({\n\t\tsigner,\n\t\ttransaction = new Transaction(),\n\t\tblobObjectId,\n\t}: DeleteBlobOptions & { signer: Signer; transaction?: Transaction }) {\n\t\tconst { digest } = await this.#executeTransaction(\n\t\t\tthis.deleteBlobTransaction({\n\t\t\t\tblobObjectId,\n\t\t\t\ttransaction,\n\t\t\t\towner: transaction.getData().sender ?? signer.toSuiAddress(),\n\t\t\t}),\n\t\t\tsigner,\n\t\t\t'delete blob',\n\t\t);\n\n\t\treturn { digest };\n\t}\n\n\t/**\n\t * Extend a blob in a transaction\n\t *\n\t * @usage\n\t * ```ts\n\t * const tx = client.extendBlobTransaction({ blobObjectId, epochs });\n\t * ```\n\t */\n\textendBlob({ blobObjectId, epochs, endEpoch, walCoin }: ExtendBlobOptions) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst blob = await this.#objectLoader.load(blobObjectId, Blob);\n\t\t\tconst numEpochs = typeof epochs === 'number' ? epochs : endEpoch - blob.storage.end_epoch;\n\n\t\t\tif (numEpochs <= 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst { storageCost } = await this.storageCost(Number(blob.storage.storage_size), numEpochs);\n\t\t\tconst walrusPackageId = await this.#getWalrusPackageId();\n\n\t\t\treturn tx.add(\n\t\t\t\tthis.#withWal(storageCost, walCoin ?? null, async (coin, tx) => {\n\t\t\t\t\ttx.add(\n\t\t\t\t\t\textendBlob({\n\t\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\t\tself: this.#packageConfig.systemObjectId,\n\t\t\t\t\t\t\t\tblob: blobObjectId,\n\t\t\t\t\t\t\t\textendedEpochs: numEpochs,\n\t\t\t\t\t\t\t\tpayment: coin,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}),\n\t\t\t);\n\t\t};\n\t}\n\n\t/**\n\t * Create a transaction that extends a blob\n\t *\n\t * @usage\n\t * ```ts\n\t * const tx = client.extendBlobTransaction({ blobObjectId, epochs });\n\t * ```\n\t */\n\tasync extendBlobTransaction({\n\t\ttransaction = new Transaction(),\n\t\t...options\n\t}: ExtendBlobOptions & { transaction?: Transaction }) {\n\t\ttransaction.add(this.extendBlob(options));\n\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Execute a transaction that extends a blob\n\t *\n\t * @usage\n\t * ```ts\n\t * const { digest } = await client.executeExtendBlobTransaction({ blobObjectId, signer });\n\t * ```\n\t */\n\tasync executeExtendBlobTransaction({\n\t\tsigner,\n\t\t...options\n\t}: ExtendBlobOptions & { signer: Signer; transaction?: Transaction }) {\n\t\tconst { digest } = await this.#executeTransaction(\n\t\t\tawait this.extendBlobTransaction(options),\n\t\t\tsigner,\n\t\t\t'extend blob',\n\t\t);\n\n\t\treturn { digest };\n\t}\n\n\tasync readBlobAttributes({\n\t\tblobObjectId,\n\t}: {\n\t\tblobObjectId: string;\n\t}): Promise<Record<string, string> | null> {\n\t\tconst response = await this.#suiClient.core.getDynamicField({\n\t\t\tparentId: blobObjectId,\n\t\t\tname: {\n\t\t\t\ttype: 'vector<u8>',\n\t\t\t\tbcs: bcs.string().serialize('metadata').toBytes(),\n\t\t\t},\n\t\t});\n\n\t\tconst parsedMetadata = metadata.Metadata.parse(response.dynamicField.value.bcs);\n\n\t\treturn Object.fromEntries(\n\t\t\tparsedMetadata.metadata.contents.map(({ key, value }) => [key, value]),\n\t\t);\n\t}\n\n\t#writeBlobAttributesForRef({\n\t\tattributes,\n\t\texistingAttributes,\n\t\tblob,\n\t}: {\n\t\tattributes: Record<string, string | null>;\n\t\texistingAttributes: Record<string, string> | null;\n\t\tblob: TransactionObjectArgument;\n\t}) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst walrusPackageId = await this.#getWalrusPackageId();\n\n\t\t\tif (!existingAttributes) {\n\t\t\t\ttx.add(\n\t\t\t\t\taddMetadata({\n\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\tself: blob,\n\t\t\t\t\t\t\tmetadata: metadata._new({\n\t\t\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tObject.keys(attributes).forEach((key) => {\n\t\t\t\tconst value = attributes[key];\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\tif (existingAttributes && key in existingAttributes) {\n\t\t\t\t\t\ttx.add(\n\t\t\t\t\t\t\tremoveMetadataPair({\n\t\t\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\t\t\tself: blob,\n\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttx.add(\n\t\t\t\t\t\tinsertOrUpdateMetadataPair({\n\t\t\t\t\t\t\tpackage: walrusPackageId,\n\t\t\t\t\t\t\targuments: {\n\t\t\t\t\t\t\t\tself: blob,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t}\n\n\t/**\n\t * Write attributes to a blob\n\t *\n\t * If attributes already exists, their previous values will be overwritten\n\t * If an attribute is set to `null`, it will be removed from the blob\n\t *\n\t * @usage\n\t * ```ts\n\t * tx.add(client.writeBlobAttributes({ blobObjectId, attributes: { key: 'value', keyToRemove: null } }));\n\t * ```\n\t */\n\twriteBlobAttributes({ blobObject, blobObjectId, attributes }: WriteBlobAttributesOptions) {\n\t\treturn async (tx: Transaction) => {\n\t\t\tconst existingAttributes = blobObjectId\n\t\t\t\t? await this.readBlobAttributes({ blobObjectId })\n\t\t\t\t: null;\n\t\t\tconst blob = blobObject ?? tx.object(blobObjectId);\n\n\t\t\ttx.add(\n\t\t\t\tthis.#writeBlobAttributesForRef({\n\t\t\t\t\tattributes,\n\t\t\t\t\texistingAttributes,\n\t\t\t\t\tblob,\n\t\t\t\t}),\n\t\t\t);\n\t\t};\n\t}\n\n\t/**\n\t * Create a transaction that writes attributes to a blob\n\t *\n\t * If attributes already exists, their previous values will be overwritten\n\t * If an attribute is set to `null`, it will be removed from the blob\n\t *\n\t * @usage\n\t * ```ts\n\t * const tx = client.writeBlobAttributesTransaction({ blobObjectId, attributes: { key: 'value', keyToRemove: null } });\n\t * ```\n\t */\n\tasync writeBlobAttributesTransaction({\n\t\ttransaction = new Transaction(),\n\t\t...options\n\t}: WriteBlobAttributesOptions & { transaction?: Transaction }) {\n\t\ttransaction.add(await this.writeBlobAttributes(options));\n\t\treturn transaction;\n\t}\n\n\t/**\n\t * Execute a transaction that writes attributes to a blob\n\t *\n\t * If attributes already exists, their previous values will be overwritten\n\t * If an attribute is set to `null`, it will be removed from the blob\n\t *\n\t * @usage\n\t * ```ts\n\t * const { digest } = await client.executeWriteBlobAttributesTransaction({ blobObjectId, signer });\n\t * ```\n\t */\n\tasync executeWriteBlobAttributesTransaction({\n\t\tsigner,\n\t\t...options\n\t}: WriteBlobAttributesOptions & { signer: Signer; transaction?: Transaction }) {\n\t\tconst { digest } = await this.#executeTransaction(\n\t\t\tawait this.writeBlobAttributesTransaction(options),\n\t\t\tsigner,\n\t\t\t'write blob attributes',\n\t\t);\n\t\treturn { digest };\n\t}\n\n\t/**\n\t * Write a sliver to a storage node\n\t *\n\t * @usage\n\t * ```ts\n\t * const res = await client.writeSliver({ blobId, sliverPairIndex, sliverType, sliver });\n\t * ```\n\t */\n\tasync writeSliver({ blobId, sliverPairIndex, sliverType, sliver, signal }: WriteSliverOptions) {\n\t\tconst systemState = await this.systemState();\n\t\tconst committee = await this.#getActiveCommittee();\n\n\t\tconst shardIndex = toShardIndex(sliverPairIndex, blobId, systemState.committee.n_shards);\n\t\tconst node = await this.#getNodeByShardIndex(committee, shardIndex);\n\n\t\treturn this.#storageNodeClient.storeSliver(\n\t\t\t{ blobId, sliverPairIndex, sliverType, sliver },\n\t\t\t{ nodeUrl: node.networkUrl, signal },\n\t\t);\n\t}\n\n\t/**\n\t * Write metadata to a storage node\n\t *\n\t * @usage\n\t * ```ts\n\t * const res = await client.writeMetadataToNode({ nodeIndex, blobId, metadata });\n\t * ```\n\t */\n\tasync writeMetadataToNode({ nodeIndex, blobId, metadata, signal }: WriteMetadataOptions) {\n\t\tconst committee = await this.#getActiveCommittee();\n\t\tconst node = committee.nodes[nodeIndex];\n\n\t\treturn retry(\n\t\t\t() =>\n\t\t\t\tthis.#storageNodeClient.storeBlobMetadata(\n\t\t\t\t\t{ blobId, metadata },\n\t\t\t\t\t{ nodeUrl: node.networkUrl, signal },\n\t\t\t\t),\n\t\t\t{\n\t\t\t\tcount: 3,\n\t\t\t\tdelay: 1000,\n\t\t\t\tcondition: (error) => error instanceof BlobNotRegisteredError,\n\t\t\t},\n\t\t);\n\t}\n\n\t/**\n\t * Get a storage confirmation from a storage node\n\t *\n\t * @usage\n\t * ```ts\n\t * const confirmation = await client.getStorageConfirmationFromNode({ nodeIndex, blobId, deletable, objectId });\n\t * ```\n\t */\n\tasync getStorageConfirmationFromNode({\n\t\tnodeIndex,\n\t\tblobId,\n\t\tdeletable,\n\t\tobjectId,\n\t\tsignal,\n\t}: GetStorageConfirmationOptions) {\n\t\tconst committee = await this.#getActiveCommittee();\n\t\tconst node = committee.nodes[nodeIndex];\n\n\t\tconst result = deletable\n\t\t\t? await this.#storageNodeClient.getDeletableBlobConfirmation(\n\t\t\t\t\t{ blobId, objectId },\n\t\t\t\t\t{ nodeUrl: node.networkUrl, signal },\n\t\t\t\t)\n\t\t\t: await this.#storageNodeClient.getPermanentBlobConfirmation(\n\t\t\t\t\t{ blobId },\n\t\t\t\t\t{ nodeUrl: node.networkUrl, signal },\n\t\t\t\t);\n\n\t\treturn result?.success?.data?.signed ?? null;\n\t}\n\n\t/**\n\t * Encode a blob into slivers for each node\n\t *\n\t * @usage\n\t * ```ts\n\t * const { blobId, metadata, sliversByNode, rootHash } = await client.encodeBlob(blob);\n\t * ```\n\t */\n\tasync encodeBlob(blob: Uint8Array) {\n\t\tconst systemState = await this.systemState();\n\t\tconst committee = await this.#getActiveCommittee();\n\n\t\tconst numShards = systemState.committee.n_shards;\n\t\tconst bindings = await this.#wasmBindings();\n\t\tconst { blobId, metadata, sliverPairs, rootHash } = bindings.encodeBlob(numShards, blob);\n\n\t\tconst sliversByNodeMap = new Map<number, SliversForNode>();\n\n\t\twhile (sliverPairs.length > 0) {\n\t\t\t// remove from list so we don't preserve references to the original data\n\t\t\tconst { primary, secondary } = sliverPairs.pop()!;\n\t\t\tconst sliverPairIndex = primary.index;\n\n\t\t\tconst shardIndex = toShardIndex(sliverPairIndex, blobId, numShards);\n\t\t\tconst node = await this.#getNodeByShardIndex(committee, shardIndex);\n\n\t\t\tif (!sliversByNodeMap.has(node.nodeIndex)) {\n\t\t\t\tsliversByNodeMap.set(node.nodeIndex, { primary: [], secondary: [] });\n\t\t\t}\n\n\t\t\tsliversByNodeMap.get(node.nodeIndex)!.primary.push({\n\t\t\t\tsliverIndex: primary.index,\n\t\t\t\tsliverPairIndex,\n\t\t\t\tshardIndex,\n\t\t\t\tsliver: SliverData.serialize(primary).toBytes(),\n\t\t\t});\n\n\t\t\tsliversByNodeMap.get(node.nodeIndex)!.secondary.push({\n\t\t\t\tsliverIndex: secondary.index,\n\t\t\t\tsliverPairIndex,\n\t\t\t\tshardIndex,\n\t\t\t\tsliver: SliverData.serialize(secondary).toBytes(),\n\t\t\t});\n\t\t}\n\n\t\tconst sliversByNode = new Array<SliversForNode>();\n\n\t\tfor (let i = 0; i < systemState.committee.members.length; i++) {\n\t\t\tsliversByNode.push(sliversByNodeMap.get(i) ?? { primary: [], secondary: [] });\n\t\t}\n\n\t\treturn { blobId, metadata, rootHash, sliversByNode };\n\t}\n\n\t/**\n\t * Write slivers to a storage node\n\t *\n\t * @usage\n\t * ```ts\n\t * await client.writeSliversToNode({ blobId, slivers, signal });\n\t * ```\n\t */\n\tasync writeSliversToNode({ blobId, slivers, signal }: WriteSliversToNodeOptions) {\n\t\tconst controller = new AbortController();\n\t\tconst combinedSignal = signal\n\t\t\t? AbortSignal.any([controller.signal, signal])\n\t\t\t: controller.signal;\n\n\t\tconst primarySliverWrites = slivers.primary.map(({ sliverPairIndex, sliver }) => {\n\t\t\treturn this.writeSliver({\n\t\t\t\tblobId,\n\t\t\t\tsliverPairIndex,\n\t\t\t\tsliverType: 'primary',\n\t\t\t\tsliver,\n\t\t\t\tsignal: combinedSignal,\n\t\t\t});\n\t\t});\n\n\t\tconst secondarySliverWrites = slivers.secondary.map(({ sliverPairIndex, sliver }) => {\n\t\t\treturn this.writeSliver({\n\t\t\t\tblobId,\n\t\t\t\tsliverPairIndex,\n\t\t\t\tsliverType: 'secondary',\n\t\t\t\tsliver,\n\t\t\t\tsignal: combinedSignal,\n\t\t\t});\n\t\t});\n\n\t\tawait Promise.all([...primarySliverWrites, ...secondarySliverWrites]).catch((error) => {\n\t\t\tcontroller.abort(error);\n\t\t\tthrow error;\n\t\t});\n\t}\n\n\t/**\n\t * Write a blob to all storage nodes\n\t *\n\t * @usage\n\t * ```ts\n\t * await client.writeEncodedBlobToNodes({ blob, deletable, epochs, signer });\n\t * ```\n\t */\n\tasync writeEncodedBlobToNodes({\n\t\tblobId,\n\t\tmetadata,\n\t\tsliversByNode,\n\t\tsignal,\n\t\t...options\n\t}: WriteEncodedBlobToNodesOptions) {\n\t\tconst systemState = await this.systemState();\n\t\tconst committee = await this.#getActiveCommittee();\n\n\t\tconst controller = new AbortController();\n\t\tlet failures = 0;\n\n\t\tconst confirmations = await Promise.all(\n\t\t\tsliversByNode.map((slivers, nodeIndex) => {\n\t\t\t\treturn this.writeEncodedBlobToNode({\n\t\t\t\t\tblobId,\n\t\t\t\t\tnodeIndex,\n\t\t\t\t\tmetadata,\n\t\t\t\t\tslivers,\n\t\t\t\t\tsignal: signal ? AbortSignal.any([controller.signal, signal]) : controller.signal,\n\t\t\t\t\t...options,\n\t\t\t\t}).catch(() => {\n\t\t\t\t\tfailures += committee.nodes[nodeIndex].shardIndices.length;\n\n\t\t\t\t\tif (isAboveValidity(failures, systemState.committee.n_shards)) {\n\t\t\t\t\t\tconst error = new NotEnoughBlobConfirmationsError(\n\t\t\t\t\t\t\t`Too many failures while writing blob ${blobId} to nodes`,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tcontroller.abort(error);\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t});\n\t\t\t}),\n\t\t);\n\n\t\treturn confirmations;\n\t}\n\n\t/**\n\t * Writes a blob to to an upload relay\n\t *\n\t * @usage\n\t * ```ts\n\t * await client.writeBlobToUploadRelay({ blob, deletable, epochs, signer });\n\t * ```\n\t */\n\tasync writeBlobToUploadRelay(options: WriteBlobToUploadRelayOptions): Promise<{\n\t\tblobId: string;\n\t\tcertificate: ProtocolMessageCertificate;\n\t}> {\n\t\tif (!this.#uploadRelayClient) {\n\t\t\tthrow new WalrusClientError('Upload relay not configured');\n\t\t}\n\n\t\treturn this.#uploadRelayClient.writeBlob({\n\t\t\t...options,\n\t\t\trequiresTip: !!this.#uploadRelayConfig?.sendTip,\n\t\t});\n\t}\n\n\t/**\n\t * Write encoded blob to a storage node\n\t *\n\t * @usage\n\t * ```ts\n\t * const res = await client.writeEncodedBlobToNode({ nodeIndex, blobId, metadata, slivers });\n\t * ```\n\t */\n\tasync writeEncodedBlobToNode({\n\t\tnodeIndex,\n\t\tblobId,\n\t\tmetadata,\n\t\tslivers,\n\t\tsignal,\n\t\t...options\n\t}: WriteEncodedBlobOptions) {\n\t\tawait this.writeMetadataToNode({\n\t\t\tnodeIndex,\n\t\t\tblobId,\n\t\t\tmetadata,\n\t\t\tsignal,\n\t\t});\n\n\t\tawait this.writeSliversToNode({ blobId, slivers, signal, nodeIndex });\n\n\t\treturn this.getStorageConfirmationFromNode({\n\t\t\tnodeIndex,\n\t\t\tblobId,\n\t\t\t...options,\n\t\t});\n\t}\n\n\t/**\n\t * Write a blob to all storage nodes\n\t *\n\t * @usage\n\t * ```ts\n\t * const { blobId, blobObject } = await client.writeBlob({ blob, deletable, epochs, signer });\n\t * ```\n\t */\n\tasync writeBlob({\n\t\tblob,\n\t\tdeletable,\n\t\tepochs,\n\t\tsigner,\n\t\tsignal,\n\t\towner,\n\t\tattributes,\n\t}: WriteBlobOptions) {\n\t\tif (!this.#uploadRelayConfig) {\n\t\t\tconst encoded = await this.encodeBlob(blob);\n\t\t\tconst blobId = encoded.blobId;\n\t\t\tconst { sliversByNode, metadata, rootHash } = encoded;\n\n\t\t\tconst suiBlobObject = await this.executeRegisterBlobTransaction({\n\t\t\t\tsigner,\n\t\t\t\tsize: blob.length,\n\t\t\t\tepochs,\n\t\t\t\tblobId,\n\t\t\t\trootHash,\n\t\t\t\tdeletable,\n\t\t\t\towner: owner ?? signer.toSuiAddress(),\n\t\t\t\tattributes,\n\t\t\t});\n\n\t\t\tconst blobObjectId = suiBlobObject.blob.id.id;\n\n\t\t\tconst confirmations = await this.writeEncodedBlobToNodes({\n\t\t\t\tblobId,\n\t\t\t\tmetadata,\n\t\t\t\tsliversByNode,\n\t\t\t\tdeletable,\n\t\t\t\tobjectId: blobObjectId,\n\t\t\t\tsignal,\n\t\t\t});\n\n\t\t\tawait this.executeCertifyBlobTransaction({\n\t\t\t\tsigner,\n\t\t\t\tblobId,\n\t\t\t\tblobObjectId,\n\t\t\t\tconfirmations,\n\t\t\t\tdeletable,\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tblobId,\n\t\t\t\tblobObject: await this.#objectLoader.load(blobObjectId, Blob),\n\t\t\t};\n\t\t} else {\n\t\t\tconst metadata = await this.computeBlobMetadata({\n\t\t\t\tbytes: blob,\n\t\t\t});\n\t\t\tconst blobId = metadata.blobId;\n\n\t\t\tconst transaction = new Transaction();\n\n\t\t\ttransaction.add(\n\t\t\t\tthis.sendUploadRelayTip({\n\t\t\t\t\tsize: blob.length,\n\t\t\t\t\tblobDigest: metadata.blobDigest,\n\t\t\t\t\tnonce: metadata.nonce,\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\tconst registerResult = await this.executeRegisterBlobTransaction({\n\t\t\t\tsigner,\n\t\t\t\ttransaction,\n\t\t\t\tsize: blob.length,\n\t\t\t\tepochs,\n\t\t\t\tblobId: metadata.blobId,\n\t\t\t\trootHash: metadata.rootHash,\n\t\t\t\tdeletable,\n\t\t\t\towner: owner ?? signer.toSuiAddress(),\n\t\t\t\tattributes,\n\t\t\t});\n\n\t\t\tawait this.#suiClient.core.waitForTransaction({\n\t\t\t\tdigest: registerResult.digest,\n\t\t\t});\n\n\t\t\tconst result = await this.writeBlobToUploadRelay({\n\t\t\t\tblobId,\n\t\t\t\tblob,\n\t\t\t\tnonce: metadata.nonce,\n\t\t\t\ttxDigest: registerResult.digest,\n\t\t\t\tsignal,\n\t\t\t\tdeletable,\n\t\t\t\tblobObjectId: registerResult.blob.id.id,\n\t\t\t\tencodingType: metadata.metadata.encodingType as EncodingType,\n\t\t\t});\n\n\t\t\tconst certificate = result.certificate;\n\t\t\tconst blobObjectId = registerResult.blob.id.id;\n\n\t\t\tawait this.executeCertifyBlobTransaction({\n\t\t\t\tsigner,\n\t\t\t\tblobId,\n\t\t\t\tblobObjectId,\n\t\t\t\tcertificate,\n\t\t\t\tdeletable,\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tblobId,\n\t\t\t\tblobObject: await this.#objectLoader.load(blobObjectId, Blob),\n\t\t\t};\n\t\t}\n\t}\n\n\tasync writeQuilt({ blobs, ...options }: WriteQuiltOptions) {\n\t\tconst encoded = await this.encodeQuilt({ blobs });\n\t\tconst result = await this.writeBlob({\n\t\t\tblob: encoded.quilt,\n\t\t\t...options,\n\t\t});\n\n\t\treturn {\n\t\t\t...result,\n\t\t\tindex: {\n\t\t\t\t...encoded.index,\n\t\t\t\tpatches: encoded.index.patches.map((patch) => ({\n\t\t\t\t\t...patch,\n\t\t\t\t\tpatchId: encodeQuiltPatchId({\n\t\t\t\t\t\tquiltId: result.blobId,\n\t\t\t\t\t\tpatchId: {\n\t\t\t\t\t\t\tversion: 1,\n\t\t\t\t\t\t\tstartIndex: patch.startIndex,\n\t\t\t\t\t\t\tendIndex: patch.endIndex,\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t})),\n\t\t\t},\n\t\t};\n\t}\n\n\tasync encodeQuilt({\n\t\tblobs,\n\t}: {\n\t\tblobs: {\n\t\t\tcontents: Uint8Array;\n\t\t\tidentifier: string;\n\t\t\ttags?: Record<string, string>;\n\t\t}[];\n\t}) {\n\t\tconst systemState = await this.systemState();\n\t\tconst encoded = encodeQuilt({\n\t\t\tblobs,\n\t\t\tnumShards: systemState.committee.n_shards,\n\t\t});\n\n\t\treturn encoded;\n\t}\n\n\tasync #executeTransaction(transaction: Transaction, signer: Signer, action: string) {\n\t\ttransaction.setSenderIfNotSet(signer.toSuiAddress());\n\n\t\tconst { digest, effects } = await signer.signAndExecuteTransaction({\n\t\t\ttransaction,\n\t\t\tclient: this.#suiClient,\n\t\t});\n\n\t\tif (effects?.status.error) {\n\t\t\tthrow new WalrusClientError(`Failed to ${action} (${digest}): ${effects?.status.error}`);\n\t\t}\n\n\t\tawait this.#suiClient.core.waitForTransaction({\n\t\t\tdigest,\n\t\t});\n\n\t\treturn { digest, effects };\n\t}\n\n\tasync #getCommittee(committee: InferBcsType<typeof Committee>) {\n\t\tconst stakingPool = await this.#stakingPool(committee);\n\t\tconst shardIndicesByNodeId = getShardIndicesByNodeId(committee);\n\n\t\tconst byShardIndex = new Map<number, StorageNode>();\n\t\tconst nodes = stakingPool.map(({ node_info }, nodeIndex) => {\n\t\t\tconst shardIndices = shardIndicesByNodeId.get(node_info.node_id) ?? [];\n\t\t\tconst node: StorageNode = {\n\t\t\t\tid: node_info.node_id,\n\t\t\t\tinfo: node_info,\n\t\t\t\tnetworkUrl: `https://${node_info.network_address}`,\n\t\t\t\tshardIndices,\n\t\t\t\tnodeIndex,\n\t\t\t};\n\n\t\t\tfor (const shardIndex of shardIndices) {\n\t\t\t\tbyShardIndex.set(shardIndex, node);\n\t\t\t}\n\n\t\t\treturn node;\n\t\t});\n\n\t\treturn {\n\t\t\tbyShardIndex,\n\t\t\tnodes,\n\t\t};\n\t}\n\n\t#getActiveCommittee() {\n\t\treturn this.#cache.read(['getActiveCommittee'], async () => {\n\t\t\tconst stakingState = await this.stakingState();\n\t\t\treturn this.#getCommittee(stakingState.committee);\n\t\t});\n\t}\n\n\tasync #stakingPool(committee: InferBcsType<typeof Committee>) {\n\t\tconst nodeIds = committee[0].contents.map((node) => node.key);\n\t\treturn this.#objectLoader.loadManyOrThrow(nodeIds, StakingPool);\n\t}\n\n\tasync #getNodeByShardIndex(committeeInfo: CommitteeInfo, index: number) {\n\t\tconst node = committeeInfo.byShardIndex.get(index);\n\t\tif (!node) {\n\t\t\tthrow new WalrusClientError(`Node for shard index ${index} not found`);\n\t\t}\n\t\treturn node;\n\t}\n\n\t/**\n\t * Reset cached data in the client\n\t *\n\t * @usage\n\t * ```ts\n\t * client.reset();\n\t * ```\n\t */\n\treset() {\n\t\tthis.#objectLoader.clearAll();\n\t\tthis.#cache.clear();\n\t}\n\n\t#retryOnPossibleEpochChange<T extends (...args: any[]) => Promise<any>>(fn: T): T {\n\t\treturn (async (...args: Parameters<T>) => {\n\t\t\ttry {\n\t\t\t\treturn await fn.apply(this, args);\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof RetryableWalrusClientError) {\n\t\t\t\t\tthis.reset();\n\t\t\t\t\treturn await fn.apply(this, args);\n\t\t\t\t}\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}) as T;\n\t}\n\n\tasync getBlob({ blobId }: { blobId: string }) {\n\t\treturn new WalrusBlob({\n\t\t\treader: new BlobReader({\n\t\t\t\tclient: this,\n\t\t\t\tblobId,\n\t\t\t\tnumShards: (await this.systemState()).committee.n_shards,\n\t\t\t}),\n\t\t\tclient: this,\n\t\t});\n\t}\n\n\tasync getFiles({ ids }: { ids: string[] }) {\n\t\tconst readersByBlobId = new Map<string, BlobReader>();\n\t\tconst quiltReadersByBlobId = new Map<string, QuiltReader>();\n\t\tconst parsedIds = ids.map((id) => parseWalrusId(id));\n\t\tconst numShards = (await this.systemState()).committee.n_shards;\n\n\t\tfor (const id of parsedIds) {\n\t\t\tconst blobId = id.kind === 'blob' ? id.id : id.id.quiltId;\n\t\t\tif (!readersByBlobId.has(blobId)) {\n\t\t\t\treadersByBlobId.set(\n\t\t\t\t\tblobId,\n\t\t\t\t\tnew BlobReader({\n\t\t\t\t\t\tclient: this,\n\t\t\t\t\t\tblobId,\n\t\t\t\t\t\tnumShards,\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (id.kind === 'quiltPatch') {\n\t\t\t\tif (!quiltReadersByBlobId.has(blobId)) {\n\t\t\t\t\tquiltReadersByBlobId.set(\n\t\t\t\t\t\tblobId,\n\t\t\t\t\t\tnew QuiltReader({\n\t\t\t\t\t\t\tblob: readersByBlobId.get(blobId)!,\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn parsedIds.map((id) => {\n\t\t\tif (id.kind === 'blob') {\n\t\t\t\treturn new WalrusFile({\n\t\t\t\t\treader: readersByBlobId.get(id.id)!,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new WalrusFile({\n\t\t\t\treader: new QuiltFileReader({\n\t\t\t\t\tquilt: quiltReadersByBlobId.get(id.id.quiltId)!,\n\t\t\t\t\tsliverIndex: id.id.patchId.startIndex,\n\t\t\t\t}),\n\t\t\t});\n\t\t});\n\t}\n\n\tasync writeFiles({ files, ...options }: WriteFilesOptions) {\n\t\tconst { blobId, index, blobObject } = await this.writeQuilt({\n\t\t\t...options,\n\t\t\tblobs: await Promise.all(\n\t\t\t\tfiles.map(async (file, i) => ({\n\t\t\t\t\tcontents: await file.bytes(),\n\t\t\t\t\tidentifier: (await file.getIdentifier()) ?? `file-${i}`,\n\t\t\t\t\ttags: (await file.getTags()) ?? {},\n\t\t\t\t})),\n\t\t\t),\n\t\t});\n\n\t\treturn index.patches.map((patch) => ({\n\t\t\tid: patch.patchId,\n\t\t\tblobId,\n\t\t\tblobObject,\n\t\t}));\n\t}\n\n\twriteFilesFlow({ files }: WriteFilesFlowOptions): WriteFilesFlow {\n\t\tconst encode = async () => {\n\t\t\tconst { quilt, index } = await this.encodeQuilt({\n\t\t\t\tblobs: await Promise.all(\n\t\t\t\t\tfiles.map(async (file, i) => ({\n\t\t\t\t\t\tcontents: await file.bytes(),\n\t\t\t\t\t\tidentifier: (await file.getIdentifier()) ?? `file-${i}`,\n\t\t\t\t\t\ttags: (await file.getTags()) ?? {},\n\t\t\t\t\t})),\n\t\t\t\t),\n\t\t\t});\n\t\t\tconst metadata = this.#uploadRelayClient\n\t\t\t\t? await this.computeBlobMetadata({\n\t\t\t\t\t\tbytes: quilt,\n\t\t\t\t\t})\n\t\t\t\t: await this.encodeBlob(quilt);\n\n\t\t\treturn {\n\t\t\t\tmetadata,\n\t\t\t\tsize: quilt.length,\n\t\t\t\tdata: this.#uploadRelayClient ? quilt : undefined,\n\t\t\t\tindex,\n\t\t\t};\n\t\t};\n\n\t\tconst register = (\n\t\t\t{ data, metadata, index, size }: Awaited<ReturnType<typeof encode>>,\n\t\t\t{ epochs, deletable, owner, attributes }: WriteFilesFlowRegisterOptions,\n\t\t) => {\n\t\t\tconst transaction = new Transaction();\n\t\t\ttransaction.setSenderIfNotSet(owner);\n\n\t\t\tif (this.#uploadRelayClient) {\n\t\t\t\tconst meta = metadata as Awaited<ReturnType<typeof this.computeBlobMetadata>>;\n\t\t\t\ttransaction.add(\n\t\t\t\t\tthis.sendUploadRelayTip({\n\t\t\t\t\t\tsize,\n\t\t\t\t\t\tblobDigest: meta.blobDigest,\n\t\t\t\t\t\tnonce: meta.nonce,\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\ttransaction.transferObjects(\n\t\t\t\t[\n\t\t\t\t\tthis.registerBlob({\n\t\t\t\t\t\tsize,\n\t\t\t\t\t\tepochs,\n\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\trootHash: metadata.rootHash,\n\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\tattributes,\n\t\t\t\t\t}),\n\t\t\t\t],\n\t\t\t\towner,\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tregisterTransaction: transaction,\n\t\t\t\tindex,\n\t\t\t\tdata,\n\t\t\t\tmetadata,\n\t\t\t\tdeletable,\n\t\t\t};\n\t\t};\n\n\t\tconst upload = async (\n\t\t\t{ index, data, metadata, deletable }: Awaited<ReturnType<typeof register>>,\n\t\t\t{ digest }: WriteFilesFlowUploadOptions,\n\t\t) => {\n\t\t\tconst blobObject = await this.#getCreatedBlob(digest);\n\n\t\t\tif (this.#uploadRelayClient) {\n\t\t\t\tconst meta = metadata as Awaited<ReturnType<typeof this.computeBlobMetadata>>;\n\t\t\t\treturn {\n\t\t\t\t\tindex,\n\t\t\t\t\tblobObject,\n\t\t\t\t\tmetadata,\n\t\t\t\t\tdeletable,\n\t\t\t\t\tcertificate: (\n\t\t\t\t\t\tawait this.writeBlobToUploadRelay({\n\t\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\t\tblob: data!,\n\t\t\t\t\t\t\tnonce: meta.nonce,\n\t\t\t\t\t\t\ttxDigest: digest,\n\t\t\t\t\t\t\tblobObjectId: blobObject.id.id,\n\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t\tencodingType: meta.metadata.encodingType as EncodingType,\n\t\t\t\t\t\t})\n\t\t\t\t\t).certificate,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst meta = metadata as Awaited<ReturnType<typeof this.encodeBlob>>;\n\n\t\t\treturn {\n\t\t\t\tindex,\n\t\t\t\tblobObject,\n\t\t\t\tmetadata,\n\t\t\t\tdeletable,\n\t\t\t\tconfirmations: await this.writeEncodedBlobToNodes({\n\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\tobjectId: blobObject.id.id,\n\t\t\t\t\tmetadata: meta.metadata,\n\t\t\t\t\tsliversByNode: meta.sliversByNode,\n\t\t\t\t\tdeletable,\n\t\t\t\t}),\n\t\t\t};\n\t\t};\n\n\t\tconst certify = ({\n\t\t\tindex,\n\t\t\tmetadata,\n\t\t\tconfirmations,\n\t\t\tcertificate,\n\t\t\tblobObject,\n\t\t\tdeletable,\n\t\t}: Awaited<ReturnType<typeof upload>>) => {\n\t\t\treturn {\n\t\t\t\tindex,\n\t\t\t\tblobObject,\n\t\t\t\tmetadata,\n\t\t\t\ttransaction: confirmations\n\t\t\t\t\t? this.certifyBlobTransaction({\n\t\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\t\tblobObjectId: blobObject.id.id,\n\t\t\t\t\t\t\tconfirmations,\n\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t})\n\t\t\t\t\t: this.certifyBlobTransaction({\n\t\t\t\t\t\t\tcertificate,\n\t\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\t\tblobObjectId: blobObject.id.id,\n\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t}),\n\t\t\t};\n\t\t};\n\n\t\tasync function listFiles({ index, blobObject, metadata }: Awaited<ReturnType<typeof certify>>) {\n\t\t\treturn index.patches.map((patch) => ({\n\t\t\t\tid: encodeQuiltPatchId({\n\t\t\t\t\tquiltId: metadata.blobId,\n\t\t\t\t\tpatchId: {\n\t\t\t\t\t\tversion: 1,\n\t\t\t\t\t\tstartIndex: patch.startIndex,\n\t\t\t\t\t\tendIndex: patch.endIndex,\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t\tblobId: metadata.blobId,\n\t\t\t\tblobObject,\n\t\t\t}));\n\t\t}\n\n\t\tconst stepResults: {\n\t\t\tencode?: Awaited<ReturnType<typeof encode>>;\n\t\t\tregister?: Awaited<ReturnType<typeof register>>;\n\t\t\tupload?: Awaited<ReturnType<typeof upload>>;\n\t\t\tcertify?: Awaited<ReturnType<typeof certify>>;\n\t\t\tlistFiles?: never;\n\t\t} = {};\n\n\t\tfunction getResults<T extends keyof typeof stepResults>(\n\t\t\tstep: T,\n\t\t\tcurrent: keyof typeof stepResults,\n\t\t): NonNullable<(typeof stepResults)[T]> {\n\t\t\tif (!stepResults[step]) {\n\t\t\t\tthrow new Error(`${step} must be executed before calling ${current}`);\n\t\t\t}\n\t\t\treturn stepResults[step];\n\t\t}\n\n\t\treturn {\n\t\t\tencode: async () => {\n\t\t\t\tif (!stepResults.encode) {\n\t\t\t\t\tstepResults.encode = await encode();\n\t\t\t\t}\n\t\t\t},\n\t\t\tregister: (options: WriteFilesFlowRegisterOptions) => {\n\t\t\t\tstepResults.register = register(getResults('encode', 'register'), options);\n\t\t\t\treturn stepResults.register.registerTransaction;\n\t\t\t},\n\t\t\tupload: async (options: WriteFilesFlowUploadOptions) => {\n\t\t\t\tstepResults.upload = await upload(getResults('register', 'upload'), options);\n\t\t\t},\n\t\t\tcertify: () => {\n\t\t\t\tstepResults.certify = certify(getResults('upload', 'certify'));\n\t\t\t\treturn stepResults.certify.transaction;\n\t\t\t},\n\t\t\tlistFiles: async () => {\n\t\t\t\treturn listFiles(getResults('certify', 'listFiles'));\n\t\t\t},\n\t\t};\n\t}\n\n\twriteBlobFlow({ blob }: WriteBlobFlowOptions): WriteBlobFlow {\n\t\tconst encode = async () => {\n\t\t\tconst metadata = this.#uploadRelayClient\n\t\t\t\t? await this.computeBlobMetadata({\n\t\t\t\t\t\tbytes: blob,\n\t\t\t\t\t})\n\t\t\t\t: await this.encodeBlob(blob);\n\n\t\t\treturn {\n\t\t\t\tmetadata,\n\t\t\t\tsize: blob.length,\n\t\t\t\tdata: this.#uploadRelayClient ? blob : undefined,\n\t\t\t};\n\t\t};\n\n\t\tconst register = (\n\t\t\t{ data, metadata, size }: Awaited<ReturnType<typeof encode>>,\n\t\t\t{ epochs, deletable, owner, attributes }: WriteBlobFlowRegisterOptions,\n\t\t) => {\n\t\t\tconst transaction = new Transaction();\n\t\t\ttransaction.setSenderIfNotSet(owner);\n\n\t\t\tif (this.#uploadRelayClient) {\n\t\t\t\tconst meta = metadata as Awaited<ReturnType<typeof this.computeBlobMetadata>>;\n\t\t\t\ttransaction.add(\n\t\t\t\t\tthis.sendUploadRelayTip({\n\t\t\t\t\t\tsize,\n\t\t\t\t\t\tblobDigest: meta.blobDigest,\n\t\t\t\t\t\tnonce: meta.nonce,\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\ttransaction.transferObjects(\n\t\t\t\t[\n\t\t\t\t\tthis.registerBlob({\n\t\t\t\t\t\tsize,\n\t\t\t\t\t\tepochs,\n\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\trootHash: metadata.rootHash,\n\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\tattributes,\n\t\t\t\t\t}),\n\t\t\t\t],\n\t\t\t\towner,\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tregisterTransaction: transaction,\n\t\t\t\tdata,\n\t\t\t\tmetadata,\n\t\t\t\tdeletable,\n\t\t\t};\n\t\t};\n\n\t\tconst upload = async (\n\t\t\t{ data, metadata, deletable }: Awaited<ReturnType<typeof register>>,\n\t\t\t{ digest }: WriteBlobFlowUploadOptions,\n\t\t) => {\n\t\t\tconst blobObject = await this.#getCreatedBlob(digest);\n\n\t\t\tif (this.#uploadRelayClient) {\n\t\t\t\tconst meta = metadata as Awaited<ReturnType<typeof this.computeBlobMetadata>>;\n\t\t\t\treturn {\n\t\t\t\t\tblobObject,\n\t\t\t\t\tmetadata,\n\t\t\t\t\tdeletable,\n\t\t\t\t\tcertificate: (\n\t\t\t\t\t\tawait this.writeBlobToUploadRelay({\n\t\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\t\tblob: data!,\n\t\t\t\t\t\t\tnonce: meta.nonce,\n\t\t\t\t\t\t\ttxDigest: digest,\n\t\t\t\t\t\t\tblobObjectId: blobObject.id.id,\n\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t\tencodingType: meta.metadata.encodingType as EncodingType,\n\t\t\t\t\t\t})\n\t\t\t\t\t).certificate,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst meta = metadata as Awaited<ReturnType<typeof this.encodeBlob>>;\n\n\t\t\treturn {\n\t\t\t\tblobObject,\n\t\t\t\tmetadata,\n\t\t\t\tdeletable,\n\t\t\t\tconfirmations: await this.writeEncodedBlobToNodes({\n\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\tobjectId: blobObject.id.id,\n\t\t\t\t\tmetadata: meta.metadata,\n\t\t\t\t\tsliversByNode: meta.sliversByNode,\n\t\t\t\t\tdeletable,\n\t\t\t\t}),\n\t\t\t};\n\t\t};\n\n\t\tconst certify = ({\n\t\t\tmetadata,\n\t\t\tconfirmations,\n\t\t\tcertificate,\n\t\t\tblobObject,\n\t\t\tdeletable,\n\t\t}: Awaited<ReturnType<typeof upload>>) => {\n\t\t\treturn {\n\t\t\t\tblobObject,\n\t\t\t\tmetadata,\n\t\t\t\ttransaction: confirmations\n\t\t\t\t\t? this.certifyBlobTransaction({\n\t\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\t\tblobObjectId: blobObject.id.id,\n\t\t\t\t\t\t\tconfirmations,\n\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t})\n\t\t\t\t\t: this.certifyBlobTransaction({\n\t\t\t\t\t\t\tcertificate,\n\t\t\t\t\t\t\tblobId: metadata.blobId,\n\t\t\t\t\t\t\tblobObjectId: blobObject.id.id,\n\t\t\t\t\t\t\tdeletable,\n\t\t\t\t\t\t}),\n\t\t\t};\n\t\t};\n\n\t\tasync function getBlob({ blobObject, metadata }: Awaited<ReturnType<typeof certify>>) {\n\t\t\treturn {\n\t\t\t\tblobId: metadata.blobId,\n\t\t\t\tblobObject,\n\t\t\t};\n\t\t}\n\n\t\tconst stepResults: {\n\t\t\tencode?: Awaited<ReturnType<typeof encode>>;\n\t\t\tregister?: Awaited<ReturnType<typeof register>>;\n\t\t\tupload?: Awaited<ReturnType<typeof upload>>;\n\t\t\tcertify?: Awaited<ReturnType<typeof certify>>;\n\t\t\tgetBlob?: never;\n\t\t} = {};\n\n\t\tfunction getResults<T extends keyof typeof stepResults>(\n\t\t\tstep: T,\n\t\t\tcurrent: keyof typeof stepResults,\n\t\t): NonNullable<(typeof stepResults)[T]> {\n\t\t\tif (!stepResults[step]) {\n\t\t\t\tthrow new Error(`${step} must be executed before calling ${current}`);\n\t\t\t}\n\t\t\treturn stepResults[step];\n\t\t}\n\n\t\treturn {\n\t\t\tencode: async () => {\n\t\t\t\tif (!stepResults.encode) {\n\t\t\t\t\tstepResults.encode = await encode();\n\t\t\t\t}\n\t\t\t},\n\t\t\tregister: (options: WriteBlobFlowRegisterOptions) => {\n\t\t\t\tstepResults.register = register(getResults('encode', 'register'), options);\n\t\t\t\treturn stepResults.register.registerTransaction;\n\t\t\t},\n\t\t\tupload: async (options: WriteBlobFlowUploadOptions) => {\n\t\t\t\tstepResults.upload = await upload(getResults('register', 'upload'), options);\n\t\t\t},\n\t\t\tcertify: () => {\n\t\t\t\tstepResults.certify = certify(getResults('upload', 'certify'));\n\t\t\t\treturn stepResults.certify.transaction;\n\t\t\t},\n\t\t\tgetBlob: async () => {\n\t\t\t\treturn getBlob(getResults('certify', 'getBlob'));\n\t\t\t},\n\t\t};\n\t}\n}\n"],
  "mappings": "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",
  "names": ["DataLoader", "vector", "_BcsType", "options", "name", "BcsStruct", "name", "BcsEnum", "BcsTuple", "BcsTuple", "name", "BcsStruct", "BcsEnum", "name", "val", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "$moduleName", "IntentType", "_StorageNodeAPIError", "error", "__privateAdd", "__privateAdd", "__privateSet", "__privateMethod", "__privateGet", "error", "DataLoader", "__privateAdd", "__privateGet", "name", "ptr", "name", "_fetch", "_timeout", "_onError", "request_fn", "__privateAdd", "__privateSet", "__privateMethod", "__privateGet", "error", "safeParseJSON", "__privateAdd", "__privateSet", "__privateGet", "__privateAdd", "__privateSet", "__privateGet", "__privateMethod", "sliver", "chunk", "_cache", "__privateAdd", "__privateSet", "__privateGet", "columnSize", "_identifier", "_tags", "__privateAdd", "__privateSet", "__privateGet", "_WalrusFile", "__privateAdd", "__privateSet", "__privateGet", "_reader", "_client", "_cache", "__privateAdd", "__privateSet", "__privateGet", "__privateMethod", "_cache", "_WalrusClient", "__privateAdd", "__privateMethod", "__privateSet", "__privateGet", "metadata", "error", "tx", "meta"]
}
