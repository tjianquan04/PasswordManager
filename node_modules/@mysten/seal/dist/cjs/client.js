"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var client_exports = {};
__export(client_exports, {
  SealClient: () => SealClient
});
module.exports = __toCommonJS(client_exports);
var import_bcs = require("./bcs.js");
var import_bls12381 = require("./bls12381.js");
var import_decrypt = require("./decrypt.js");
var import_dem = require("./dem.js");
var import_encrypt = require("./encrypt.js");
var import_error = require("./error.js");
var import_ibe = require("./ibe.js");
var import_key_server = require("./key-server.js");
var import_keys = require("./keys.js");
var import_utils = require("./utils.js");
var _suiClient, _configs, _keyServers, _verifyKeyServers, _cachedKeys, _timeout, _totalWeight, _SealClient_instances, createEncryptionInput_fn, weight_fn, validateEncryptionServices_fn, getWeightedKeyServers_fn, loadKeyServers_fn;
const _SealClient = class _SealClient {
  constructor(options) {
    __privateAdd(this, _SealClient_instances);
    __privateAdd(this, _suiClient);
    __privateAdd(this, _configs);
    __privateAdd(this, _keyServers, null);
    __privateAdd(this, _verifyKeyServers);
    // A caching map for: fullId:object_id -> partial key.
    __privateAdd(this, _cachedKeys, /* @__PURE__ */ new Map());
    __privateAdd(this, _timeout);
    __privateAdd(this, _totalWeight);
    __privateSet(this, _suiClient, options.suiClient);
    if (new Set(options.serverConfigs.map((s) => s.objectId)).size !== options.serverConfigs.length) {
      throw new import_error.InvalidClientOptionsError("Duplicate object IDs");
    }
    if (options.serverConfigs.some((s) => s.apiKeyName && !s.apiKey || !s.apiKeyName && s.apiKey)) {
      throw new import_error.InvalidClientOptionsError(
        "Both apiKeyName and apiKey must be provided or not provided for all key servers"
      );
    }
    __privateSet(this, _configs, new Map(options.serverConfigs.map((server) => [server.objectId, server])));
    __privateSet(this, _totalWeight, options.serverConfigs.map((server) => server.weight).reduce((sum, term) => sum + term, 0));
    __privateSet(this, _verifyKeyServers, options.verifyKeyServers ?? true);
    __privateSet(this, _timeout, options.timeout ?? 1e4);
  }
  static experimental_asClientExtension(options) {
    return {
      name: "seal",
      register: (client) => {
        return new _SealClient({
          suiClient: client,
          ...options
        });
      }
    };
  }
  /**
   * Return an encrypted message under the identity.
   *
   * @param kemType - The type of KEM to use.
   * @param demType - The type of DEM to use.
   * @param threshold - The threshold for the TSS encryption.
   * @param packageId - the packageId namespace.
   * @param id - the identity to use.
   * @param data - the data to encrypt.
   * @param aad - optional additional authenticated data.
   * @returns The bcs bytes of the encrypted object containing all metadata and the 256-bit symmetric key that was used to encrypt the object.
   * 	Since the symmetric key can be used to decrypt, it should not be shared but can be used e.g. for backup.
   */
  async encrypt({
    kemType = import_encrypt.KemType.BonehFranklinBLS12381DemCCA,
    demType = import_encrypt.DemType.AesGcm256,
    threshold,
    packageId,
    id,
    data,
    aad = new Uint8Array()
  }) {
    const packageObj = await __privateGet(this, _suiClient).core.getObject({ objectId: packageId });
    if (String(packageObj.object.version) !== "1") {
      throw new import_error.InvalidPackageError(`Package ${packageId} is not the first version`);
    }
    return (0, import_encrypt.encrypt)({
      keyServers: await __privateMethod(this, _SealClient_instances, getWeightedKeyServers_fn).call(this),
      kemType,
      threshold,
      packageId,
      id,
      encryptionInput: __privateMethod(this, _SealClient_instances, createEncryptionInput_fn).call(this, demType, data, aad)
    });
  }
  /**
   * Decrypt the given encrypted bytes using cached keys.
   * Calls fetchKeys in case one or more of the required keys is not cached yet.
   * The function throws an error if the client's key servers are not a subset of
   * the encrypted object's key servers or if the threshold cannot be met.
   *
   * @param data - The encrypted bytes to decrypt.
   * @param sessionKey - The session key to use.
   * @param txBytes - The transaction bytes to use (that calls seal_approve* functions).
   * @returns - The decrypted plaintext corresponding to ciphertext.
   */
  async decrypt({
    data,
    sessionKey,
    txBytes
  }) {
    const encryptedObject = import_bcs.EncryptedObject.parse(data);
    __privateMethod(this, _SealClient_instances, validateEncryptionServices_fn).call(this, encryptedObject.services.map((s) => s[0]), encryptedObject.threshold);
    await this.fetchKeys({
      ids: [encryptedObject.id],
      txBytes,
      sessionKey,
      threshold: encryptedObject.threshold
    });
    return (0, import_decrypt.decrypt)({ encryptedObject, keys: __privateGet(this, _cachedKeys) });
  }
  async getKeyServers() {
    if (!__privateGet(this, _keyServers)) {
      __privateSet(this, _keyServers, __privateMethod(this, _SealClient_instances, loadKeyServers_fn).call(this).catch((error) => {
        __privateSet(this, _keyServers, null);
        throw error;
      }));
    }
    return __privateGet(this, _keyServers);
  }
  /**
   * Fetch keys from the key servers and update the cache.
   *
   * It is recommended to call this function once for all ids of all encrypted objects if
   * there are multiple, then call decrypt for each object. This avoids calling fetchKey
   * individually for each decrypt.
   *
   * @param ids - The ids of the encrypted objects.
   * @param txBytes - The transaction bytes to use (that calls seal_approve* functions).
   * @param sessionKey - The session key to use.
   * @param threshold - The threshold for the TSS encryptions. The function returns when a threshold of key servers had returned keys for all ids.
   */
  async fetchKeys({
    ids,
    txBytes,
    sessionKey,
    threshold
  }) {
    if (threshold > __privateGet(this, _totalWeight) || threshold < 1) {
      throw new import_error.InvalidThresholdError(
        `Invalid threshold ${threshold} servers with weights ${__privateGet(this, _configs)}`
      );
    }
    const keyServers = await this.getKeyServers();
    const fullIds = ids.map((id) => (0, import_utils.createFullId)(sessionKey.getPackageId(), id));
    let completedWeight = 0;
    const remainingKeyServers = [];
    let remainingKeyServersWeight = 0;
    for (const objectId of keyServers.keys()) {
      if (fullIds.every((fullId) => __privateGet(this, _cachedKeys).has(`${fullId}:${objectId}`))) {
        completedWeight += __privateMethod(this, _SealClient_instances, weight_fn).call(this, objectId);
      } else {
        remainingKeyServers.push(objectId);
        remainingKeyServersWeight += __privateMethod(this, _SealClient_instances, weight_fn).call(this, objectId);
      }
    }
    if (completedWeight >= threshold) {
      return;
    }
    for (const objectId of remainingKeyServers) {
      const server = keyServers.get(objectId);
      if (server.keyType !== import_key_server.KeyServerType.BonehFranklinBLS12381) {
        throw new import_error.InvalidKeyServerError(
          `Server ${server.objectId} has invalid key type: ${server.keyType}`
        );
      }
    }
    const cert = await sessionKey.getCertificate();
    const signedRequest = await sessionKey.createRequestParams(txBytes);
    const controller = new AbortController();
    const errors = [];
    const keyFetches = remainingKeyServers.map(async (objectId) => {
      const server = keyServers.get(objectId);
      try {
        const config = __privateGet(this, _configs).get(objectId);
        const allKeys = await (0, import_keys.fetchKeysForAllIds)(
          server.url,
          signedRequest.requestSignature,
          txBytes,
          signedRequest.decryptionKey,
          cert,
          __privateGet(this, _timeout),
          config?.apiKeyName,
          config?.apiKey,
          controller.signal
        );
        for (const { fullId, key } of allKeys) {
          const keyElement = import_bls12381.G1Element.fromBytes(key);
          if (!import_ibe.BonehFranklinBLS12381Services.verifyUserSecretKey(
            keyElement,
            fullId,
            import_bls12381.G2Element.fromBytes(server.pk)
          )) {
            console.warn("Received invalid key from key server " + server.objectId);
            continue;
          }
          __privateGet(this, _cachedKeys).set(`${fullId}:${server.objectId}`, keyElement);
        }
        if (fullIds.every((fullId) => __privateGet(this, _cachedKeys).has(`${fullId}:${server.objectId}`))) {
          completedWeight += __privateMethod(this, _SealClient_instances, weight_fn).call(this, objectId);
          if (completedWeight >= threshold) {
            controller.abort();
          }
        }
      } catch (error) {
        if (!controller.signal.aborted) {
          errors.push(error);
        }
      } finally {
        remainingKeyServersWeight -= __privateMethod(this, _SealClient_instances, weight_fn).call(this, objectId);
        if (remainingKeyServersWeight < threshold - completedWeight) {
          controller.abort(new import_error.TooManyFailedFetchKeyRequestsError());
        }
      }
    });
    await Promise.allSettled(keyFetches);
    if (completedWeight < threshold) {
      throw (0, import_error.toMajorityError)(errors);
    }
  }
  /**
   * Get derived keys from the given services.
   *
   * @param id - The id of the encrypted object.
   * @param txBytes - The transaction bytes to use (that calls seal_approve* functions).
   * @param sessionKey - The session key to use.
   * @param threshold - The threshold.
   * @returns - Derived keys for the given services that are in the cache as a "service object ID" -> derived key map. If the call is succesful, exactly threshold keys will be returned.
   */
  async getDerivedKeys({
    kemType = import_encrypt.KemType.BonehFranklinBLS12381DemCCA,
    id,
    txBytes,
    sessionKey,
    threshold
  }) {
    switch (kemType) {
      case import_encrypt.KemType.BonehFranklinBLS12381DemCCA:
        const keyServers = await this.getKeyServers();
        if (threshold > __privateGet(this, _totalWeight)) {
          throw new import_error.InvalidThresholdError(
            `Invalid threshold ${threshold} for ${__privateGet(this, _totalWeight)} servers`
          );
        }
        await this.fetchKeys({
          ids: [id],
          txBytes,
          sessionKey,
          threshold
        });
        const fullId = (0, import_utils.createFullId)(sessionKey.getPackageId(), id);
        const derivedKeys = /* @__PURE__ */ new Map();
        let weight = 0;
        for (const objectId of keyServers.keys()) {
          const cachedKey = __privateGet(this, _cachedKeys).get(`${fullId}:${objectId}`);
          if (cachedKey) {
            derivedKeys.set(objectId, new import_key_server.BonehFranklinBLS12381DerivedKey(cachedKey));
            weight += __privateMethod(this, _SealClient_instances, weight_fn).call(this, objectId);
            if (weight >= threshold) {
              break;
            }
          }
        }
        return derivedKeys;
    }
  }
};
_suiClient = new WeakMap();
_configs = new WeakMap();
_keyServers = new WeakMap();
_verifyKeyServers = new WeakMap();
_cachedKeys = new WeakMap();
_timeout = new WeakMap();
_totalWeight = new WeakMap();
_SealClient_instances = new WeakSet();
createEncryptionInput_fn = function(type, data, aad) {
  switch (type) {
    case import_encrypt.DemType.AesGcm256:
      return new import_dem.AesGcm256(data, aad);
    case import_encrypt.DemType.Hmac256Ctr:
      return new import_dem.Hmac256Ctr(data, aad);
  }
};
weight_fn = function(objectId) {
  return __privateGet(this, _configs).get(objectId)?.weight ?? 0;
};
validateEncryptionServices_fn = function(services, threshold) {
  if (services.some((objectId) => {
    const countInClient = __privateMethod(this, _SealClient_instances, weight_fn).call(this, objectId);
    return countInClient > 0 && countInClient !== (0, import_utils.count)(services, objectId);
  })) {
    throw new import_error.InconsistentKeyServersError(
      `Client's key servers must be a subset of the encrypted object's key servers`
    );
  }
  if (threshold > __privateGet(this, _totalWeight)) {
    throw new import_error.InvalidThresholdError(
      `Invalid threshold ${threshold} for ${__privateGet(this, _totalWeight)} servers`
    );
  }
};
getWeightedKeyServers_fn = async function() {
  const keyServers = await this.getKeyServers();
  const keyServersWithMultiplicity = [];
  for (const [objectId, config] of __privateGet(this, _configs)) {
    const keyServer = keyServers.get(objectId);
    for (let i = 0; i < config.weight; i++) {
      keyServersWithMultiplicity.push(keyServer);
    }
  }
  return keyServersWithMultiplicity;
};
loadKeyServers_fn = async function() {
  const keyServers = await (0, import_key_server.retrieveKeyServers)({
    objectIds: [...__privateGet(this, _configs)].map(([objectId]) => objectId),
    client: __privateGet(this, _suiClient)
  });
  if (keyServers.length === 0) {
    throw new import_error.InvalidKeyServerError("No key servers found");
  }
  if (__privateGet(this, _verifyKeyServers)) {
    await Promise.all(
      keyServers.map(async (server) => {
        const config = __privateGet(this, _configs).get(server.objectId);
        if (!await (0, import_key_server.verifyKeyServer)(server, __privateGet(this, _timeout), config?.apiKeyName, config?.apiKey)) {
          throw new import_error.InvalidKeyServerError(`Key server ${server.objectId} is not valid`);
        }
      })
    );
  }
  return new Map(keyServers.map((server) => [server.objectId, server]));
};
let SealClient = _SealClient;
//# sourceMappingURL=client.js.map
