import type { Signer } from '@mysten/sui/cryptography';
import type { SealCompatibleClient } from './types.js';
export declare const RequestFormat: import("@mysten/bcs").BcsStruct<{
    ptb: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    encKey: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
    encVerificationKey: import("@mysten/bcs").BcsType<number[], Iterable<number> & {
        length: number;
    }, string>;
}, string>;
export type Certificate = {
    user: string;
    session_vk: string;
    creation_time: number;
    ttl_min: number;
    signature: string;
    mvr_name?: string;
};
export type SessionKeyType = {
    address: string;
    packageId: string;
    mvrName?: string;
    creationTimeMs: number;
    ttlMin: number;
    personalMessageSignature?: string;
    sessionKey: string;
};
export declare class SessionKey {
    #private;
    /**
     * @deprecated - Use `await SessionKey.create()` instead.
     */
    constructor({ address, packageId, mvrName, ttlMin, signer, suiClient, }: {
        address: string;
        packageId: string;
        mvrName?: string;
        ttlMin: number;
        signer?: Signer;
        suiClient: SealCompatibleClient;
    });
    static create({ address, packageId, mvrName, ttlMin, signer, suiClient, }: {
        address: string;
        packageId: string;
        mvrName?: string;
        ttlMin: number;
        signer?: Signer;
        suiClient: SealCompatibleClient;
    }): Promise<SessionKey>;
    isExpired(): boolean;
    getAddress(): string;
    getPackageName(): string;
    getPackageId(): string;
    getPersonalMessage(): Uint8Array;
    setPersonalMessageSignature(personalMessageSignature: string): Promise<void>;
    getCertificate(): Promise<Certificate>;
    createRequestParams(txBytes: Uint8Array): Promise<{
        decryptionKey: Uint8Array;
        requestSignature: string;
    }>;
    /**
     * Export the Session Key object from the instance. Store the object in IndexedDB to persist.
     */
    export(): SessionKeyType;
    /**
     * Restore a SessionKey instance for the given object.
     * @returns A new SessionKey instance with restored state
     */
    static import(data: SessionKeyType, suiClient: SealCompatibleClient, signer?: Signer): SessionKey;
}
