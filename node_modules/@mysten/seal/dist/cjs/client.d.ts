import { DemType, KemType } from './encrypt.js';
import type { DerivedKey, KeyServer } from './key-server.js';
import type { SessionKey } from './session-key.js';
import type { SealCompatibleClient } from './types.js';
/**
 * Configuration options for initializing a SealClient
 * @property serverConfigs: Array of key server configs consisting of objectId, weight, optional API key name and API key.
 * @property verifyKeyServers: Whether to verify the key servers' authenticity.
 * 	 Should be false if servers are pre-verified (e.g., getAllowlistedKeyServers).
 * 	 Defaults to true.
 * @property timeout: Timeout in milliseconds for network requests. Defaults to 10 seconds.
 */
export interface SealClientExtensionOptions {
    serverConfigs: KeyServerConfig[];
    verifyKeyServers?: boolean;
    timeout?: number;
}
export interface KeyServerConfig {
    objectId: string;
    weight: number;
    apiKeyName?: string;
    apiKey?: string;
}
export interface SealClientOptions extends SealClientExtensionOptions {
    suiClient: SealCompatibleClient;
}
export declare class SealClient {
    #private;
    constructor(options: SealClientOptions);
    static experimental_asClientExtension(options: SealClientExtensionOptions): {
        name: "seal";
        register: (client: SealCompatibleClient) => SealClient;
    };
    /**
     * Return an encrypted message under the identity.
     *
     * @param kemType - The type of KEM to use.
     * @param demType - The type of DEM to use.
     * @param threshold - The threshold for the TSS encryption.
     * @param packageId - the packageId namespace.
     * @param id - the identity to use.
     * @param data - the data to encrypt.
     * @param aad - optional additional authenticated data.
     * @returns The bcs bytes of the encrypted object containing all metadata and the 256-bit symmetric key that was used to encrypt the object.
     * 	Since the symmetric key can be used to decrypt, it should not be shared but can be used e.g. for backup.
     */
    encrypt({ kemType, demType, threshold, packageId, id, data, aad, }: {
        kemType?: KemType;
        demType?: DemType;
        threshold: number;
        packageId: string;
        id: string;
        data: Uint8Array;
        aad?: Uint8Array;
    }): Promise<{
        encryptedObject: Uint8Array;
        key: Uint8Array;
    }>;
    /**
     * Decrypt the given encrypted bytes using cached keys.
     * Calls fetchKeys in case one or more of the required keys is not cached yet.
     * The function throws an error if the client's key servers are not a subset of
     * the encrypted object's key servers or if the threshold cannot be met.
     *
     * @param data - The encrypted bytes to decrypt.
     * @param sessionKey - The session key to use.
     * @param txBytes - The transaction bytes to use (that calls seal_approve* functions).
     * @returns - The decrypted plaintext corresponding to ciphertext.
     */
    decrypt({ data, sessionKey, txBytes, }: {
        data: Uint8Array;
        sessionKey: SessionKey;
        txBytes: Uint8Array;
    }): Promise<Uint8Array<ArrayBufferLike>>;
    getKeyServers(): Promise<Map<string, KeyServer>>;
    /**
     * Fetch keys from the key servers and update the cache.
     *
     * It is recommended to call this function once for all ids of all encrypted objects if
     * there are multiple, then call decrypt for each object. This avoids calling fetchKey
     * individually for each decrypt.
     *
     * @param ids - The ids of the encrypted objects.
     * @param txBytes - The transaction bytes to use (that calls seal_approve* functions).
     * @param sessionKey - The session key to use.
     * @param threshold - The threshold for the TSS encryptions. The function returns when a threshold of key servers had returned keys for all ids.
     */
    fetchKeys({ ids, txBytes, sessionKey, threshold, }: {
        ids: string[];
        txBytes: Uint8Array;
        sessionKey: SessionKey;
        threshold: number;
    }): Promise<void>;
    /**
     * Get derived keys from the given services.
     *
     * @param id - The id of the encrypted object.
     * @param txBytes - The transaction bytes to use (that calls seal_approve* functions).
     * @param sessionKey - The session key to use.
     * @param threshold - The threshold.
     * @returns - Derived keys for the given services that are in the cache as a "service object ID" -> derived key map. If the call is succesful, exactly threshold keys will be returned.
     */
    getDerivedKeys({ kemType, id, txBytes, sessionKey, threshold, }: {
        kemType?: KemType;
        id: string;
        txBytes: Uint8Array;
        sessionKey: SessionKey;
        threshold: number;
    }): Promise<Map<string, DerivedKey>>;
}
