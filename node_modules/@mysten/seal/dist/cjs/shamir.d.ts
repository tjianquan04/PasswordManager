/**
 * A field element in the Rijndael finite field GF(2⁸) with a fixed generator g = 0x03.
 */
export declare class GF256 {
    value: number;
    constructor(value: number);
    log(): number;
    static exp(x: number): GF256;
    add(other: GF256): GF256;
    sub(other: GF256): GF256;
    neg(): GF256;
    mul(other: GF256): GF256;
    div(other: GF256): GF256;
    equals(other: GF256): boolean;
    static zero(): GF256;
    static one(): GF256;
}
export declare class Polynomial {
    coefficients: GF256[];
    /**
     * Construct a new Polynomial over [GF256] from the given coefficients.
     * The first coefficient is the constant term.
     */
    constructor(coefficients: GF256[]);
    static fromBytes(bytes: Uint8Array): Polynomial;
    degree(): number;
    getCoefficient(index: number): GF256;
    add(other: Polynomial): Polynomial;
    mul(other: Polynomial): Polynomial;
    /** The polynomial s * this. */
    scale(s: GF256): Polynomial;
    div(s: GF256): Polynomial;
    /** The polynomial x + c. */
    static monic_linear(c: GF256): Polynomial;
    static zero(): Polynomial;
    static one(): Polynomial;
    /** Given a set of coordinates, interpolate a polynomial. */
    static interpolate(coordinates: {
        x: GF256;
        y: GF256;
    }[]): Polynomial;
    /** Given a set of coordinates, interpolate a polynomial and evaluate it at x = 0. */
    static combine(coordinates: {
        x: GF256;
        y: GF256;
    }[]): GF256;
    /** Evaluate the polynomial at x. */
    evaluate(x: GF256): GF256;
    equals(other: Polynomial): boolean;
}
/** Representation of a share of a secret. The index is a number between 1 and 255. */
export type Share = {
    index: number;
    share: Uint8Array;
};
/**
 * Split a secret into shares.
 *
 * @param secret The secret to split.
 * @param threshold The minimum number of shares required to reconstruct the secret.
 * @param total The total number of shares to generate.
 * @returns The shares.
 */
export declare function split(secret: Uint8Array, threshold: number, total: number): Share[];
/**
 * Combine shares into a secret. If fewer than the threshold number of shares are provided,
 * the result will be indistinguishable from random.
 *
 * @param shares The shares to combine.
 * @returns The secret.
 */
export declare function combine(shares: Share[]): Uint8Array;
/**
 * Interpolate a polynomial from the given shares.
 *
 * @param shares The shares to interpolate from.
 * @returns A function that evaluates the polynomial at a given x.
 */
export declare function interpolate(shares: Share[]): (x: number) => Uint8Array;
