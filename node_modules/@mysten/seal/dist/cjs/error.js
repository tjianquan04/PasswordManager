"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var error_exports = {};
__export(error_exports, {
  DecryptionError: () => DecryptionError,
  DeprecatedSDKVersionError: () => DeprecatedSDKVersionError,
  ExpiredSessionKeyError: () => ExpiredSessionKeyError,
  GeneralError: () => GeneralError,
  InconsistentKeyServersError: () => InconsistentKeyServersError,
  InternalError: () => InternalError,
  InvalidCiphertextError: () => InvalidCiphertextError,
  InvalidClientOptionsError: () => InvalidClientOptionsError,
  InvalidGetObjectError: () => InvalidGetObjectError,
  InvalidKeyServerError: () => InvalidKeyServerError,
  InvalidKeyServerObjectIdError: () => InvalidKeyServerObjectIdError,
  InvalidKeyServerVersionError: () => InvalidKeyServerVersionError,
  InvalidMVRNameError: () => InvalidMVRNameError,
  InvalidPTBError: () => InvalidPTBError,
  InvalidPackageError: () => InvalidPackageError,
  InvalidParameterError: () => InvalidParameterError,
  InvalidPersonalMessageSignatureError: () => InvalidPersonalMessageSignatureError,
  InvalidSDKVersionError: () => InvalidSDKVersionError,
  InvalidSessionKeySignatureError: () => InvalidSessionKeySignatureError,
  InvalidThresholdError: () => InvalidThresholdError,
  InvalidUserSignatureError: () => InvalidUserSignatureError,
  NoAccessError: () => NoAccessError,
  SealAPIError: () => SealAPIError,
  SealError: () => SealError,
  TooManyFailedFetchKeyRequestsError: () => TooManyFailedFetchKeyRequestsError,
  UnsupportedFeatureError: () => UnsupportedFeatureError,
  UnsupportedNetworkError: () => UnsupportedNetworkError,
  UnsupportedPackageIdError: () => UnsupportedPackageIdError,
  UserError: () => UserError,
  toMajorityError: () => toMajorityError
});
module.exports = __toCommonJS(error_exports);
var _SealAPIError_static, generate_fn;
class SealError extends Error {
}
class UserError extends SealError {
}
const _SealAPIError = class _SealAPIError extends SealError {
  constructor(message, requestId, status) {
    super(message);
    this.requestId = requestId;
    this.status = status;
  }
  static async assertResponse(response, requestId) {
    var _a;
    if (response.ok) {
      return;
    }
    let errorInstance;
    try {
      const text = await response.text();
      const error = JSON.parse(text)["error"];
      const message = JSON.parse(text)["message"];
      errorInstance = __privateMethod(_a = _SealAPIError, _SealAPIError_static, generate_fn).call(_a, error, message, requestId);
    } catch (e) {
      errorInstance = new GeneralError(response.statusText, requestId, response.status);
    }
    throw errorInstance;
  }
};
_SealAPIError_static = new WeakSet();
generate_fn = function(error, message, requestId, status) {
  switch (error) {
    case "InvalidPTB":
      return new InvalidPTBError(requestId, message);
    case "InvalidPackage":
      return new InvalidPackageError(requestId);
    case "NoAccess":
      return new NoAccessError(requestId);
    case "InvalidSignature":
      return new InvalidUserSignatureError(requestId);
    case "InvalidSessionSignature":
      return new InvalidSessionKeySignatureError(requestId);
    case "InvalidCertificate":
      return new ExpiredSessionKeyError(requestId);
    case "InvalidSDKVersion":
      return new InvalidSDKVersionError(requestId);
    case "DeprecatedSDKVersion":
      return new DeprecatedSDKVersionError(requestId);
    case "InvalidParameter":
      return new InvalidParameterError(requestId);
    case "InvalidMVRName":
      return new InvalidMVRNameError(requestId);
    case "InvalidServiceId":
      return new InvalidKeyServerObjectIdError(requestId);
    case "UnsupportedPackageId":
      return new UnsupportedPackageIdError(requestId);
    case "Failure":
      return new InternalError(requestId);
    default:
      return new GeneralError(message, requestId, status);
  }
};
__privateAdd(_SealAPIError, _SealAPIError_static);
let SealAPIError = _SealAPIError;
class InvalidPTBError extends SealAPIError {
  constructor(requestId, message) {
    super("PTB does not conform to the expected format " + message, requestId);
  }
}
class InvalidPackageError extends SealAPIError {
  constructor(requestId) {
    super("Package ID used in PTB is invalid", requestId);
  }
}
class InvalidParameterError extends SealAPIError {
  constructor(requestId) {
    super(
      "PTB contains an invalid parameter, possibly a newly created object that the FN has not yet seen",
      requestId
    );
  }
}
class InvalidUserSignatureError extends SealAPIError {
  constructor(requestId) {
    super("User signature on the session key is invalid", requestId);
  }
}
class InvalidSessionKeySignatureError extends SealAPIError {
  constructor(requestId) {
    super("Session key signature is invalid", requestId);
  }
}
class InvalidMVRNameError extends SealAPIError {
  constructor(requestId) {
    super("MVR name is invalid or not consistent with the first version of the package", requestId);
  }
}
class InvalidKeyServerObjectIdError extends SealAPIError {
  constructor(requestId) {
    super("Key server object ID is invalid", requestId);
  }
}
class UnsupportedPackageIdError extends SealAPIError {
  constructor(requestId) {
    super("Requested package is not supported", requestId);
  }
}
class InvalidSDKVersionError extends SealAPIError {
  constructor(requestId) {
    super("SDK version is invalid", requestId);
  }
}
class DeprecatedSDKVersionError extends SealAPIError {
  constructor(requestId) {
    super("SDK version is deprecated", requestId);
  }
}
class NoAccessError extends SealAPIError {
  constructor(requestId) {
    super("User does not have access to one or more of the requested keys", requestId);
  }
}
class ExpiredSessionKeyError extends SealAPIError {
  constructor(requestId) {
    super("Session key has expired", requestId);
  }
}
class InternalError extends SealAPIError {
  constructor(requestId) {
    super("Internal server error, caller should retry", requestId);
  }
}
class GeneralError extends SealAPIError {
}
class InvalidPersonalMessageSignatureError extends UserError {
}
class InvalidGetObjectError extends UserError {
}
class UnsupportedFeatureError extends UserError {
}
class UnsupportedNetworkError extends UserError {
}
class InvalidKeyServerError extends UserError {
}
class InvalidKeyServerVersionError extends UserError {
}
class InvalidCiphertextError extends UserError {
}
class InvalidThresholdError extends UserError {
}
class InconsistentKeyServersError extends UserError {
}
class DecryptionError extends UserError {
}
class InvalidClientOptionsError extends UserError {
}
class TooManyFailedFetchKeyRequestsError extends UserError {
}
function toMajorityError(errors) {
  let maxCount = 0;
  let majorityError = errors[0];
  const counts = /* @__PURE__ */ new Map();
  for (const error of errors) {
    const errorName = error.constructor.name;
    const newCount = (counts.get(errorName) || 0) + 1;
    counts.set(errorName, newCount);
    if (newCount > maxCount) {
      maxCount = newCount;
      majorityError = error;
    }
  }
  return majorityError;
}
//# sourceMappingURL=error.js.map
