import { bcs, fromBase64, fromHex, toHex } from "@mysten/bcs";
import { bls12_381 } from "@noble/curves/bls12-381";
import { KeyServerMove, KeyServerMoveV1 } from "./bcs.js";
import { InvalidKeyServerVersionError, SealAPIError, UnsupportedNetworkError } from "./error.js";
import { DST_POP } from "./ibe.js";
import { PACKAGE_VERSION } from "./version.js";
import { flatten, Version } from "./utils.js";
const EXPECTED_SERVER_VERSION = 1;
var KeyServerType = /* @__PURE__ */ ((KeyServerType2) => {
  KeyServerType2[KeyServerType2["BonehFranklinBLS12381"] = 0] = "BonehFranklinBLS12381";
  return KeyServerType2;
})(KeyServerType || {});
const SERVER_VERSION_REQUIREMENT = new Version("0.4.1");
function getAllowlistedKeyServers(network) {
  if (network === "testnet") {
    return [
      "0x73d05d62c18d9374e3ea529e8e0ed6161da1a141a94d3f76ae3fe4e99356db75",
      "0xf5d14a81a982144ae441cd7d64b09027f116a468bd36e7eca494f750591623c8"
    ];
  } else {
    throw new UnsupportedNetworkError(`Unsupported network ${network}`);
  }
}
async function retrieveKeyServers({
  objectIds,
  client
}) {
  return await Promise.all(
    objectIds.map(async (objectId) => {
      const res = await client.core.getObject({
        objectId
      });
      const ks = KeyServerMove.parse(await res.object.content);
      if (EXPECTED_SERVER_VERSION < Number(ks.firstVersion) || EXPECTED_SERVER_VERSION > Number(ks.lastVersion)) {
        throw new InvalidKeyServerVersionError(
          `Key server ${objectId} supports versions between ${ks.firstVersion} and ${ks.lastVersion} (inclusive), but SDK expects version ${EXPECTED_SERVER_VERSION}`
        );
      }
      const resVersionedKs = await client.core.getDynamicField({
        parentId: objectId,
        name: {
          type: "u64",
          bcs: bcs.u64().serialize(EXPECTED_SERVER_VERSION).toBytes()
        }
      });
      const ksVersioned = KeyServerMoveV1.parse(resVersionedKs.dynamicField.value.bcs);
      return {
        objectId,
        name: ksVersioned.name,
        url: ksVersioned.url,
        keyType: ksVersioned.keyType,
        pk: new Uint8Array(ksVersioned.pk)
      };
    })
  );
}
async function verifyKeyServer(server, timeout, apiKeyName, apiKey) {
  const requestId = crypto.randomUUID();
  const response = await fetch(server.url + "/v1/service?service_id=" + server.objectId, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      "Request-Id": requestId,
      "Client-Sdk-Type": "typescript",
      "Client-Sdk-Version": PACKAGE_VERSION,
      ...apiKeyName && apiKey ? { apiKeyName: apiKey } : {}
    },
    signal: AbortSignal.timeout(timeout)
  });
  await SealAPIError.assertResponse(response, requestId);
  verifyKeyServerVersion(response);
  const serviceResponse = await response.json();
  if (serviceResponse.service_id !== server.objectId) {
    return false;
  }
  const fullMsg = flatten([DST_POP, server.pk, fromHex(server.objectId)]);
  return bls12_381.verifyShortSignature(fromBase64(serviceResponse.pop), fullMsg, server.pk);
}
function verifyKeyServerVersion(response) {
  const keyServerVersion = response.headers.get("X-KeyServer-Version");
  if (keyServerVersion == null) {
    throw new InvalidKeyServerVersionError("Key server version not found");
  }
  if (new Version(keyServerVersion).older_than(SERVER_VERSION_REQUIREMENT)) {
    throw new InvalidKeyServerVersionError(
      `Key server version ${keyServerVersion} is not supported`
    );
  }
}
class BonehFranklinBLS12381DerivedKey {
  constructor(key) {
    this.key = key;
    this.representation = toHex(key.toBytes());
  }
  toString() {
    return this.representation;
  }
}
export {
  BonehFranklinBLS12381DerivedKey,
  KeyServerType,
  SERVER_VERSION_REQUIREMENT,
  getAllowlistedKeyServers,
  retrieveKeyServers,
  verifyKeyServer,
  verifyKeyServerVersion
};
//# sourceMappingURL=key-server.js.map
