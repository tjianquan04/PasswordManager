var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _suiClient, _configs, _keyServers, _verifyKeyServers, _cachedKeys, _timeout, _totalWeight, _SealClient_instances, createEncryptionInput_fn, weight_fn, validateEncryptionServices_fn, getWeightedKeyServers_fn, loadKeyServers_fn;
import { EncryptedObject } from "./bcs.js";
import { G1Element, G2Element } from "./bls12381.js";
import { decrypt } from "./decrypt.js";
import { AesGcm256, Hmac256Ctr } from "./dem.js";
import { DemType, encrypt, KemType } from "./encrypt.js";
import {
  InconsistentKeyServersError,
  InvalidClientOptionsError,
  InvalidKeyServerError,
  InvalidPackageError,
  InvalidThresholdError,
  toMajorityError,
  TooManyFailedFetchKeyRequestsError
} from "./error.js";
import { BonehFranklinBLS12381Services } from "./ibe.js";
import {
  BonehFranklinBLS12381DerivedKey,
  KeyServerType,
  retrieveKeyServers,
  verifyKeyServer
} from "./key-server.js";
import { fetchKeysForAllIds } from "./keys.js";
import { createFullId, count } from "./utils.js";
const _SealClient = class _SealClient {
  constructor(options) {
    __privateAdd(this, _SealClient_instances);
    __privateAdd(this, _suiClient);
    __privateAdd(this, _configs);
    __privateAdd(this, _keyServers, null);
    __privateAdd(this, _verifyKeyServers);
    // A caching map for: fullId:object_id -> partial key.
    __privateAdd(this, _cachedKeys, /* @__PURE__ */ new Map());
    __privateAdd(this, _timeout);
    __privateAdd(this, _totalWeight);
    __privateSet(this, _suiClient, options.suiClient);
    if (new Set(options.serverConfigs.map((s) => s.objectId)).size !== options.serverConfigs.length) {
      throw new InvalidClientOptionsError("Duplicate object IDs");
    }
    if (options.serverConfigs.some((s) => s.apiKeyName && !s.apiKey || !s.apiKeyName && s.apiKey)) {
      throw new InvalidClientOptionsError(
        "Both apiKeyName and apiKey must be provided or not provided for all key servers"
      );
    }
    __privateSet(this, _configs, new Map(options.serverConfigs.map((server) => [server.objectId, server])));
    __privateSet(this, _totalWeight, options.serverConfigs.map((server) => server.weight).reduce((sum, term) => sum + term, 0));
    __privateSet(this, _verifyKeyServers, options.verifyKeyServers ?? true);
    __privateSet(this, _timeout, options.timeout ?? 1e4);
  }
  static experimental_asClientExtension(options) {
    return {
      name: "seal",
      register: (client) => {
        return new _SealClient({
          suiClient: client,
          ...options
        });
      }
    };
  }
  /**
   * Return an encrypted message under the identity.
   *
   * @param kemType - The type of KEM to use.
   * @param demType - The type of DEM to use.
   * @param threshold - The threshold for the TSS encryption.
   * @param packageId - the packageId namespace.
   * @param id - the identity to use.
   * @param data - the data to encrypt.
   * @param aad - optional additional authenticated data.
   * @returns The bcs bytes of the encrypted object containing all metadata and the 256-bit symmetric key that was used to encrypt the object.
   * 	Since the symmetric key can be used to decrypt, it should not be shared but can be used e.g. for backup.
   */
  async encrypt({
    kemType = KemType.BonehFranklinBLS12381DemCCA,
    demType = DemType.AesGcm256,
    threshold,
    packageId,
    id,
    data,
    aad = new Uint8Array()
  }) {
    const packageObj = await __privateGet(this, _suiClient).core.getObject({ objectId: packageId });
    if (String(packageObj.object.version) !== "1") {
      throw new InvalidPackageError(`Package ${packageId} is not the first version`);
    }
    return encrypt({
      keyServers: await __privateMethod(this, _SealClient_instances, getWeightedKeyServers_fn).call(this),
      kemType,
      threshold,
      packageId,
      id,
      encryptionInput: __privateMethod(this, _SealClient_instances, createEncryptionInput_fn).call(this, demType, data, aad)
    });
  }
  /**
   * Decrypt the given encrypted bytes using cached keys.
   * Calls fetchKeys in case one or more of the required keys is not cached yet.
   * The function throws an error if the client's key servers are not a subset of
   * the encrypted object's key servers or if the threshold cannot be met.
   *
   * @param data - The encrypted bytes to decrypt.
   * @param sessionKey - The session key to use.
   * @param txBytes - The transaction bytes to use (that calls seal_approve* functions).
   * @returns - The decrypted plaintext corresponding to ciphertext.
   */
  async decrypt({
    data,
    sessionKey,
    txBytes
  }) {
    const encryptedObject = EncryptedObject.parse(data);
    __privateMethod(this, _SealClient_instances, validateEncryptionServices_fn).call(this, encryptedObject.services.map((s) => s[0]), encryptedObject.threshold);
    await this.fetchKeys({
      ids: [encryptedObject.id],
      txBytes,
      sessionKey,
      threshold: encryptedObject.threshold
    });
    return decrypt({ encryptedObject, keys: __privateGet(this, _cachedKeys) });
  }
  async getKeyServers() {
    if (!__privateGet(this, _keyServers)) {
      __privateSet(this, _keyServers, __privateMethod(this, _SealClient_instances, loadKeyServers_fn).call(this).catch((error) => {
        __privateSet(this, _keyServers, null);
        throw error;
      }));
    }
    return __privateGet(this, _keyServers);
  }
  /**
   * Fetch keys from the key servers and update the cache.
   *
   * It is recommended to call this function once for all ids of all encrypted objects if
   * there are multiple, then call decrypt for each object. This avoids calling fetchKey
   * individually for each decrypt.
   *
   * @param ids - The ids of the encrypted objects.
   * @param txBytes - The transaction bytes to use (that calls seal_approve* functions).
   * @param sessionKey - The session key to use.
   * @param threshold - The threshold for the TSS encryptions. The function returns when a threshold of key servers had returned keys for all ids.
   */
  async fetchKeys({
    ids,
    txBytes,
    sessionKey,
    threshold
  }) {
    if (threshold > __privateGet(this, _totalWeight) || threshold < 1) {
      throw new InvalidThresholdError(
        `Invalid threshold ${threshold} servers with weights ${__privateGet(this, _configs)}`
      );
    }
    const keyServers = await this.getKeyServers();
    const fullIds = ids.map((id) => createFullId(sessionKey.getPackageId(), id));
    let completedWeight = 0;
    const remainingKeyServers = [];
    let remainingKeyServersWeight = 0;
    for (const objectId of keyServers.keys()) {
      if (fullIds.every((fullId) => __privateGet(this, _cachedKeys).has(`${fullId}:${objectId}`))) {
        completedWeight += __privateMethod(this, _SealClient_instances, weight_fn).call(this, objectId);
      } else {
        remainingKeyServers.push(objectId);
        remainingKeyServersWeight += __privateMethod(this, _SealClient_instances, weight_fn).call(this, objectId);
      }
    }
    if (completedWeight >= threshold) {
      return;
    }
    for (const objectId of remainingKeyServers) {
      const server = keyServers.get(objectId);
      if (server.keyType !== KeyServerType.BonehFranklinBLS12381) {
        throw new InvalidKeyServerError(
          `Server ${server.objectId} has invalid key type: ${server.keyType}`
        );
      }
    }
    const cert = await sessionKey.getCertificate();
    const signedRequest = await sessionKey.createRequestParams(txBytes);
    const controller = new AbortController();
    const errors = [];
    const keyFetches = remainingKeyServers.map(async (objectId) => {
      const server = keyServers.get(objectId);
      try {
        const config = __privateGet(this, _configs).get(objectId);
        const allKeys = await fetchKeysForAllIds(
          server.url,
          signedRequest.requestSignature,
          txBytes,
          signedRequest.decryptionKey,
          cert,
          __privateGet(this, _timeout),
          config?.apiKeyName,
          config?.apiKey,
          controller.signal
        );
        for (const { fullId, key } of allKeys) {
          const keyElement = G1Element.fromBytes(key);
          if (!BonehFranklinBLS12381Services.verifyUserSecretKey(
            keyElement,
            fullId,
            G2Element.fromBytes(server.pk)
          )) {
            console.warn("Received invalid key from key server " + server.objectId);
            continue;
          }
          __privateGet(this, _cachedKeys).set(`${fullId}:${server.objectId}`, keyElement);
        }
        if (fullIds.every((fullId) => __privateGet(this, _cachedKeys).has(`${fullId}:${server.objectId}`))) {
          completedWeight += __privateMethod(this, _SealClient_instances, weight_fn).call(this, objectId);
          if (completedWeight >= threshold) {
            controller.abort();
          }
        }
      } catch (error) {
        if (!controller.signal.aborted) {
          errors.push(error);
        }
      } finally {
        remainingKeyServersWeight -= __privateMethod(this, _SealClient_instances, weight_fn).call(this, objectId);
        if (remainingKeyServersWeight < threshold - completedWeight) {
          controller.abort(new TooManyFailedFetchKeyRequestsError());
        }
      }
    });
    await Promise.allSettled(keyFetches);
    if (completedWeight < threshold) {
      throw toMajorityError(errors);
    }
  }
  /**
   * Get derived keys from the given services.
   *
   * @param id - The id of the encrypted object.
   * @param txBytes - The transaction bytes to use (that calls seal_approve* functions).
   * @param sessionKey - The session key to use.
   * @param threshold - The threshold.
   * @returns - Derived keys for the given services that are in the cache as a "service object ID" -> derived key map. If the call is succesful, exactly threshold keys will be returned.
   */
  async getDerivedKeys({
    kemType = KemType.BonehFranklinBLS12381DemCCA,
    id,
    txBytes,
    sessionKey,
    threshold
  }) {
    switch (kemType) {
      case KemType.BonehFranklinBLS12381DemCCA:
        const keyServers = await this.getKeyServers();
        if (threshold > __privateGet(this, _totalWeight)) {
          throw new InvalidThresholdError(
            `Invalid threshold ${threshold} for ${__privateGet(this, _totalWeight)} servers`
          );
        }
        await this.fetchKeys({
          ids: [id],
          txBytes,
          sessionKey,
          threshold
        });
        const fullId = createFullId(sessionKey.getPackageId(), id);
        const derivedKeys = /* @__PURE__ */ new Map();
        let weight = 0;
        for (const objectId of keyServers.keys()) {
          const cachedKey = __privateGet(this, _cachedKeys).get(`${fullId}:${objectId}`);
          if (cachedKey) {
            derivedKeys.set(objectId, new BonehFranklinBLS12381DerivedKey(cachedKey));
            weight += __privateMethod(this, _SealClient_instances, weight_fn).call(this, objectId);
            if (weight >= threshold) {
              break;
            }
          }
        }
        return derivedKeys;
    }
  }
};
_suiClient = new WeakMap();
_configs = new WeakMap();
_keyServers = new WeakMap();
_verifyKeyServers = new WeakMap();
_cachedKeys = new WeakMap();
_timeout = new WeakMap();
_totalWeight = new WeakMap();
_SealClient_instances = new WeakSet();
createEncryptionInput_fn = function(type, data, aad) {
  switch (type) {
    case DemType.AesGcm256:
      return new AesGcm256(data, aad);
    case DemType.Hmac256Ctr:
      return new Hmac256Ctr(data, aad);
  }
};
weight_fn = function(objectId) {
  return __privateGet(this, _configs).get(objectId)?.weight ?? 0;
};
validateEncryptionServices_fn = function(services, threshold) {
  if (services.some((objectId) => {
    const countInClient = __privateMethod(this, _SealClient_instances, weight_fn).call(this, objectId);
    return countInClient > 0 && countInClient !== count(services, objectId);
  })) {
    throw new InconsistentKeyServersError(
      `Client's key servers must be a subset of the encrypted object's key servers`
    );
  }
  if (threshold > __privateGet(this, _totalWeight)) {
    throw new InvalidThresholdError(
      `Invalid threshold ${threshold} for ${__privateGet(this, _totalWeight)} servers`
    );
  }
};
getWeightedKeyServers_fn = async function() {
  const keyServers = await this.getKeyServers();
  const keyServersWithMultiplicity = [];
  for (const [objectId, config] of __privateGet(this, _configs)) {
    const keyServer = keyServers.get(objectId);
    for (let i = 0; i < config.weight; i++) {
      keyServersWithMultiplicity.push(keyServer);
    }
  }
  return keyServersWithMultiplicity;
};
loadKeyServers_fn = async function() {
  const keyServers = await retrieveKeyServers({
    objectIds: [...__privateGet(this, _configs)].map(([objectId]) => objectId),
    client: __privateGet(this, _suiClient)
  });
  if (keyServers.length === 0) {
    throw new InvalidKeyServerError("No key servers found");
  }
  if (__privateGet(this, _verifyKeyServers)) {
    await Promise.all(
      keyServers.map(async (server) => {
        const config = __privateGet(this, _configs).get(server.objectId);
        if (!await verifyKeyServer(server, __privateGet(this, _timeout), config?.apiKeyName, config?.apiKey)) {
          throw new InvalidKeyServerError(`Key server ${server.objectId} is not valid`);
        }
      })
    );
  }
  return new Map(keyServers.map((server) => [server.objectId, server]));
};
let SealClient = _SealClient;
export {
  SealClient
};
//# sourceMappingURL=client.js.map
