import { fromHex } from "@mysten/bcs";
import { sha3_256 } from "@noble/hashes/sha3";
import { G1Element } from "./bls12381.js";
import { flatten, MAX_U8 } from "./utils.js";
const DST = new TextEncoder().encode("SUI-SEAL-IBE-BLS12381-00");
const KDF_DST = new TextEncoder().encode("SUI-SEAL-IBE-BLS12381-H2-00");
const DERIVE_KEY_DST = new TextEncoder().encode("SUI-SEAL-IBE-BLS12381-H3-00");
function hashToG1(id) {
  return G1Element.hashToCurve(flatten([DST, id]));
}
function kdf(element, nonce, id, objectId, index) {
  if (index < 0 || index > MAX_U8) {
    throw new Error(`Invalid index ${index}`);
  }
  const hash = sha3_256.create();
  hash.update(KDF_DST);
  hash.update(element.toBytes());
  hash.update(nonce.toBytes());
  hash.update(hashToG1(id).toBytes());
  hash.update(fromHex(objectId));
  hash.update(new Uint8Array([index]));
  return hash.digest();
}
var KeyPurpose = /* @__PURE__ */ ((KeyPurpose2) => {
  KeyPurpose2[KeyPurpose2["EncryptedRandomness"] = 0] = "EncryptedRandomness";
  KeyPurpose2[KeyPurpose2["DEM"] = 1] = "DEM";
  return KeyPurpose2;
})(KeyPurpose || {});
function tag(purpose) {
  switch (purpose) {
    case 0 /* EncryptedRandomness */:
      return new Uint8Array([0]);
    case 1 /* DEM */:
      return new Uint8Array([1]);
    default:
      throw new Error(`Invalid key purpose ${purpose}`);
  }
}
function deriveKey(purpose, baseKey, encryptedShares, threshold, keyServers) {
  if (threshold <= 0 || threshold > MAX_U8) {
    throw new Error(`Invalid threshold ${threshold}`);
  }
  const hash = sha3_256.create();
  hash.update(DERIVE_KEY_DST);
  hash.update(baseKey);
  hash.update(tag(purpose));
  hash.update(new Uint8Array([threshold]));
  encryptedShares.forEach((share) => hash.update(share));
  keyServers.forEach((keyServer) => hash.update(fromHex(keyServer)));
  return hash.digest();
}
export {
  KeyPurpose,
  deriveKey,
  hashToG1,
  kdf
};
//# sourceMappingURL=kdf.js.map
